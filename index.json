[{"uri":"https://numerics.mathdotnet.com/Build.html","title":"Building Math.NET Numerics\r\n","content":"Building Math.NET Numerics\r\n==========================\r\n\r\nIf you do not want to use the official binaries, or if you like to modify,\r\ndebug or contribute, you can compile locally either using Visual Studio or\r\nmanually with the build scripts.\r\n\r\nSystem Requirements\r\n-------------------\r\n\r\n* .NET Core SDK 3.1.1 ([download](https://dotnet.microsoft.com/download/dotnet-core/3.1))\r\n\r\nVisualStudio and other IDEs\r\n---------------------------\r\n\r\nWe clearly separate dependency management from the IDE and therefore recommend to\r\nrun \u0060restore.cmd\u0060 or \u0060restore.sh\u0060 once after every git checkout in order to restore\r\nthe dependencies exactly as defined. Otherwise Visual Studio and other IDEs\r\nmay fail to compile or provide correct IntelliSense.\r\n\r\nTests can be run with the usual integrated NUnit test runners or ReSharper.\r\n\r\nCommand Line Tools\r\n------------------\r\n\r\nInstead of a compatible IDE you can also build the solutions directly with\r\nthe .NET Core SDK build tools. You may need to run \u0060restore.cmd\u0060 or \u0060restore.sh\u0060\r\nbefore, once after every git checkout in order to restore the dependencies.\r\n\r\n    restore.cmd (or ./restore.sh)\r\n    dotnet build MathNet.Numerics.sln\r\n\r\nFAKE\r\n----\r\n\r\nThe fully automated build including unit tests, documentation and api\r\nreference, NuGet and Zip packages is using [FAKE](https://fsharp.github.io/FAKE/).\r\n\r\nFAKE itself is not included in the repository but it will download and bootstrap\r\nitself automatically when build.cmd is run the first time. Note that this step\r\nis *not* required when using Visual Studio or the .NET Core SDK directly.\r\n\r\n    ./build.sh   # normal build and unit tests, when using bash shell on Windows or Linux.\r\n    build.cmd    # normal build and unit tests, when using Windows CMD shell.\r\n\r\n    ./build.sh build              # normal build\r\n    ./build.sh build strongname   # normal build and also build strong-named variant\r\n\r\n    ./build.sh test          # normal build, run unit tests\r\n    ./build.sh test quick    # normal build, run unit tests except long running ones\r\n\r\n    ./build.sh clean         # cleanup build artifacts\r\n    ./build.sh docs          # generate documentation\r\n    ./build.sh api           # generate api reference\r\n\r\n    ./build.sh all           # build, test, docs, api reference\r\n\r\nIf the build or tests fail claiming that FSharp.Core was not be found, see\r\n[fsharp.org](https://fsharp.org/use/windows/) or install the\r\n[Visual F# 3.0 Tools](https://go.microsoft.com/fwlink/?LinkId=261286) directly.\r\n\r\nDependencies\r\n------------\r\n\r\nWe manage NuGet and other dependencies with [Paket](https://fsprojects.github.io/Paket/).\r\nYou do not normally have to do anything with Paket as it is integrated into our\r\nFAKE build tools, unless you want to actively manage the dependencies.\r\n\r\n\u0060.paket/paket.exe restore\u0060 will restore the packages\r\nto the exact version specified in the \u0060paket.lock\u0060 file,\r\n\u0060.paket/paket.exe install\u0060 will install or migrate packages after you have\r\nmade changes to the \u0060paket.dependencies\u0060 file, \u0060.paket/paket.exe outdated\u0060\r\nwill show whether any packages are out of date and \u0060.paket/paket.exe update\u0060\r\nwill update all packages within the defined constraints. Have a look at the Paket\r\nwebsite for more commands and details.\r\n\r\nDocumentation\r\n-------------\r\n\r\nThis website and documentation is automatically generated from of a set of\r\n[CommonMark](https://commonmark.org/) structured files in \u0060doc/content/\u0060 using\r\n[FSharp.Formatting](https://tpetricek.github.io/FSharp.Formatting/).\r\nThe final documentation can be built by calling \u0060build.sh docs\u0060.\r\n\r\nHowever, for editing and previewing the docs on your local machine it is more\r\nconvenient to run \u0060build.sh DocsWatch\u0060 in a separate console instead, which\r\nmonitors the content files and incrementally regenerates the HTML output\r\nautomatically. DocsWatch will also use local/relative URIs instead of absolute\r\nones, so that the links and styles will work as expected locally. This can\r\nalso be enabled in a full one-time build with \u0060build.sh DocsDev\u0060 instead\r\nof just \u0060Docs\u0060.\r\n\r\nCreating a Release\r\n------------------\r\n\r\nWhile only maintainers can make official releases published on NuGet and\r\nreferred to from the website, you can use the same tools to make your own\r\nreleases for your own purposes.\r\n\r\nVersioning is controlled by the release notes. Before building a new version,\r\nfirst add a new release header and change notes on top of the \u0060RELEASENOTES.md\u0060\r\ndocument in the root directory. The fake builds pick this up and propagate it\r\nto the assembly info files automatically.\r\n\r\nThe build can then be launched by calling:\r\n\r\n    ./build.sh all\r\n\r\nThe build script will print the current version as part of the the header banner,\r\nwhich is also included in the release notes document in the build artifacts.\r\nExample:\r\n\r\n    //  __  __       _   _       _   _ ______ _______\r\n    // |  \\/  |     | | | |     | \\ | |  ____|__   __|\r\n    // | \\  / | __ _| |_| |__   |  \\| | |__     | |\r\n    // | |\\/| |/ _\u0060 | __| \u0027_ \\  | . \u0060 |  __|    | |\r\n    // | |  | | (_| | |_| | | |_| |\\  | |____   | |\r\n    // |_|  |_|\\__,_|\\__|_| |_(_)_| \\_|______|  |_|\r\n    //\r\n    // Math.NET Numerics - https://numerics.mathdotnet.com\r\n    // Copyright (c) Math.NET - Open Source MIT/X11 License\r\n    //\r\n    // Math.NET Numerics                    v3.5.0\r\n    // Math.NET Numerics MKL Provider       v1.7.0\r\n    // Math.NET Numerics Data Extensions    v3.1.0\r\n\r\nThe artifacts are then ready in the \u0060out/packages\u0060 directory.\r\n\r\nExtra Packages\r\n--------------\r\n\r\nIn addition to the core package this repository also include extra packages\r\nlike the data extensions. Most build targets are available for\r\nthese packages as well, with the following prefixes:\r\n\r\n*   \u0060Data\u0060 for the Data Extensions\r\n\r\nExample: \u0060build.sh DataBuild\u0060\r\n\r\nIntel MKL on Windows\r\n--------------------\r\n\r\nBuilding the Intel MKL native provider for Windows requires additionally:\r\n\r\n* Either Intel Parallel Studio 2020 or Intel Math Kernel Library 2020 is installed\r\n* Visual Studio 2019, with the following options\r\n    * Desktop development with C\u002B\u002B workload\r\n    * Windows 10 SDK (10.0.17763.0)\r\n    * MSVC v142 - VS 2019 C\u002B\u002B x64/x86 build tools\r\n\r\nThe build can then be triggered by calling:\r\n\r\n    ./build.sh MklWinBuild  // build both 32 and 64 bit variants\r\n    ./build.sh MklTest      // run all tests with the MKL provider enforced\r\n    ./build.sh MklWinAll    // build and run tests\r\n\r\nIf you run into an error with \u0060mkl_link_tool.exe\u0060 you may need to patch a targets file,\r\nsee [MKL 2020.1, VS2019 linking bug ](https://software.intel.com/en-us/forums/intel-math-kernel-library/topic/851578).\r\n\r\nThe build puts the binaries to \u0060out/MKL/Windows/x64\u0060 (and \u0060x86\u0060), the NuGet package\r\nto \u0060out/MKL/NuGet\u0060 and a Zip archive to \u0060out/MKL/Zip\u0060. You can directly use the provider from\r\nthere by setting \u0060Control.NativeProviderPath\u0060 to the full path pointing to \u0060out/MKL/Windows/\u0060;\r\nthis is also what the unit tests do when you run the \u0060MklTest\u0060 build target.\r\n\r\nOfficial Release Process (Maintainers only)\r\n-------------------------------------------\r\n\r\n*   Update \u0060RELEASENOTES.md\u0060 file with relevant changes, attributed by contributor (if external). Set date.\r\n*   Update \u0060CONTRIBUTORS.md\u0060 file (via \u0060git shortlog -sn\u0060)\r\n\r\n*   Build Release:\r\n\r\n        build.sh all --strongname\r\n\r\n*   Commit and push release notes and (auto-updated) assembly info files with new \u0022Release: v1.2.3\u0022 commit\r\n\r\n*   Publish Release:\r\n\r\n        build.sh PublishDocs\r\n        build.sh PublishApi\r\n        build.sh PublishTag\r\n        build.sh PublishArchive\r\n        build.sh PublishNuGet\r\n\r\n*   Consider a tweet via [@MathDotNet](https://twitter.com/MathDotNet)\r\n*   Update Wikipedia release version and date for the\r\n    [Math.NET Numerics](https://en.wikipedia.org/wiki/Math.NET_Numerics) and\r\n    [Comparison of numerical analysis software](https://en.wikipedia.org/wiki/Comparison_of_numerical_analysis_software) articles.\r\n"},{"uri":"https://numerics.mathdotnet.com/Compatibility.html","title":"Platform Support\r\n","content":"Platform Support\r\n================\r\n\r\nSupported Platforms:\r\n\r\n- .NET 5.0 or higher, with builds for 5.0.\r\n- .NET Framework 4.6.1 or higher, with builds for 4.6.1 and 4.8.\r\n- .NET Standard 2.0 or higher, with builds for 2.0.\r\n- Mono (via .NET Standard)\r\n- Windows, Linux and Mac.\r\n\r\n\r\nDependencies\r\n------------\r\n\r\nPackage Dependencies:\r\n\r\n- .NET 5.0 and higher: None\r\n- .NET Framework 4.6.1: [System.ValueTuple](https://www.nuget.org/packages/System.ValueTuple)\r\n- .NET Framework 4.8 and higher: None\r\n- .Net Standard 2.0 and higher: None\r\n- F#: additionally [FSharp.Core](https://www.nuget.org/packages/FSharp.Core)\r\n"},{"uri":"https://numerics.mathdotnet.com/Constants.html","title":"Constants\r\n","content":"Constants\r\n=========\r\n\r\nMath.NET Numerics contains a set of often used mathematical and scientific\r\nconstants. Mathematical and defined scientific constants are as accurate as\r\ndouble precision allows, while measured constants are implemented according\r\nto 2007 CODATA.\r\n\r\nAll constants are defined as static constant fields of the \u0060Constants\u0060 class.\r\n\r\n\r\nSI Unit Scaling\r\n---------------\r\n\r\nConstant | Factor    | Constant | Factor\r\n-------- | --------- | -------- | ----------\r\nDeca     | $10^{1}$  | Deci     | $10^{-1}$\r\nHecto    | $10^{2}$  | Centi    | $10^{-2}$\r\nKilo     | $10^{3}$  | Milli    | $10^{-3}$\r\nMega     | $10^{6}$  | Micro    | $10^{-6}$\r\nGiga     | $10^{9}$  | Nano     | $10^{-9}$\r\nTera     | $10^{12}$ | Pico     | $10^{-12}$\r\nPeta     | $10^{15}$ | Femto    | $10^{-15}$\r\nExa      | $10^{18}$ | Atto     | $10^{-18}$\r\nZetta    | $10^{21}$ | Zepto    | $10^{-21}$\r\nYotta    | $10^{24}$ | Yocto    | $10^{-24}$\r\n\r\n\r\nMathematical Constants\r\n----------------------\r\n\r\nConstant          | Definition                | Value (Rounded)\r\n----------------- | ------------------------- | ---------------\r\nE                 | $e$                       | 2.7182818284590452354\r\nLog2E             | $\\log_2{e}$               | 1.4426950408889634074\r\nLog10E            | $\\log_{10}{e}$            | 0.4342944819032518277\r\nLn2               | $\\log_e{2}$               | 0.6931471805599453094\r\nLn10              | $\\log_e{10}$              | 2.3025850929940456840\r\nLnPi              | $\\log_e{\\pi}$             | 1.1447298858494001741\r\nLn2PiOver2        | $\\frac{1}{2}\\log_e{2\\pi}$ | 0.9189385332046727418\r\nInvE              | $\\frac{1}{e}$             | 0.3678794411714423216\r\nSqrtE             | $\\sqrt{e}$                | 1.6487212707001281468\r\nSqrt2             | $\\sqrt{2}$                | 1.4142135623730950488\r\nSqrt3             | $\\sqrt{3}$                | 1.7320508075688772935\r\nSqrt1Over2        | $\\sqrt{\\frac{1}{2}} = \\frac{1}{\\sqrt{2}} = \\frac{\\sqrt{2}}{2}$ | 0.7071067811865475244\r\nHalfSqrt3         | $\\frac{1}{2}\\sqrt{3}$     | 0.8660254037844386468\r\nPi                | $\\pi$                     | 3.1415926535897932385\r\nPi2               | $2\\pi$                    | 6.2831853071795864769\r\nPiOver2           | $\\frac{1}{2}\\pi$          | 1.5707963267948966192\r\nPi3Over2          | $\\frac{3}{2}\\pi$          | 4.7123889803846898577\r\nPiOver4           | $\\frac{1}{4}\\pi$          | 0.7853981633974483096\r\nSqrtPi            | $\\sqrt{\\pi}$              | 1.7724538509055160273\r\nSqrt2Pi           | $\\sqrt{2\\pi}$             | 2.5066282746310005024\r\nSqrt2PiE          | $\\sqrt{2\\pi e}$           | 4.1327313541224929385\r\nLogSqrt2Pi        | $\\log_e{\\sqrt{2\\pi}} = \\frac{1}{2}\\log_e{2\\pi}$ | 0.9189385332046727418\r\nLogSqrt2PiE       | $\\log_e{\\sqrt{2\\pi e}}$   | 1.4189385332046727418\r\nLogTwoSqrtEOverPi | $\\log_e{2\\sqrt{\\frac{e}{\\pi}}}$ | 0.6207822376352452223\r\nInvPi             | $\\frac{1}{\\pi}$           | 0.3183098861837906715\r\nTwoInvPi          | $\\frac{2}{\\pi}$           | 0.6366197723675813431\r\nInvSqrtPi         | $\\frac{1}{\\sqrt{\\pi}}$    | 0.5641895835477562869\r\nInvSqrt2Pi        | $\\frac{1}{\\sqrt{2\\pi}}$   | 0.3989422804014326779\r\nTwoInvSqrtPi      | $\\frac{2}{\\sqrt{2\\pi}}$   | 1.1283791670955125739\r\nTwoSqrtEOverPi    | $2\\sqrt{\\frac{e}{\\pi}}$   | 1.8603827342052657173\r\nCatalan           | $\\beta(2) = \\sum_{k=0}^{\\infty}{\\frac{(-1)^k}{(2k\u002B1)^2}}$ | 0.9159655941772190151\r\nEulerMascheroni   | $\\gamma = \\lim_{n\\to\\infty} {\\sum_{k=1}^n{(\\frac{1}{k} - \\log_e{n})}}$ | 0.5772156649015328606\r\nGoldenRatio       | $\\frac{1\u002B\\sqrt{5}}{2}$    | 1.6180339887498948482\r\nGlaisher          | $\\exp{(\\frac{1}{12} - \\zeta{(-1)})}$ | 1.2824271291006226369\r\nKhinchin          | $K_0 = \\prod_{k=1}^{\\infty}{(1\u002B\\frac{1}{k(k\u002B2)})^{\\log_2{k}}}$ | 2.6854520010653064453\r\n\r\n\r\nUniversal Constants\r\n-------------------\r\n\r\nConstant                      | Symbol  | Unit          | Value\r\n----------------------------- | ------- | ------------- | -----\r\nSpeedOfLight                  | $c_0$   | $\\frac{m}{s}$ | 2.99792458e\u002B8\r\nMagneticPermeability          | $\\mu_0$ | $\\frac{N}{A^2}$ = $\\frac{kg\\,m}{A^2s^2}$ | 1.2566370614359172954e-6\r\nElectricPermittivity          | $\\varepsilon_0$ | $\\frac{F}{m}$ = $\\frac{A^2s^4}{kg\\,m^3}$ | 8.8541878171937079245e-12\r\nCharacteristicImpedanceVacuum | $Z_0$   | $\\Omega = \\frac{kg\\,m^2}{A^2s^3}$ | 376.7303134617706554682\r\nGravitationalConstant         | $G$     | $\\frac{m^3}{kg\\,s^2}$ | 6.67429e-11\r\nPlancksConstant               | $h$     | $J\\,s = \\frac{kg\\,m^2}{s}$ | 6.62606896e-34\r\nDiracsConstant                | $\\hbar$ | $J\\,s = \\frac{kg\\,m^2}{s}$ | 1.054571629e-34\r\nPlancksMass                   | $m_p$   | $kg$ | 2.17644e-8\r\nPlancksTemperature            | $T_p$   | $K$ | 1.416786e\u002B32\r\nPlancksLength                 | $l_p$   | $m$ | 1.616253e-35\r\nPlancksTime                   | $t_p$   | $s$ | 5.39124e-44\r\n\r\n\r\nElectromagnetic Constants\r\n-------------------------\r\n\r\nConstant            | Symbol     | Unit                              | Value\r\n------------------- | ---------- | --------------------------------- | -----\r\nElementaryCharge    | $e$        | $C = A\\,s$                        | 1.602176487e-19\r\nMagneticFluxQuantum | $\\Theta_0$ | $Wb = \\frac{kg\\,m^2}{A\\,s^2}$     | 2.067833668e-15\r\nConductanceQuantum  | $G_0$      | $S = \\frac{A^2s^3}{kg\\,m^2}$      | 7.7480917005e-5\r\nJosephsonConstant   | $K_J$      | $\\frac{Hz}{V}$                    | 483597.891e\u002B9\r\nVonKlitzingConstant | $R_K$      | $\\Omega = \\frac{kg\\,m^2}{A^2s^3}$ | 25812.807557\r\nBohrMagneton        | $\\mu_B$    | $\\frac{J}{T}$                     | 927.400915e-26\r\nNuclearMagneton     | $\\mu_N$    | $\\frac{J}{T}$                     | 5.05078324e-27\r\n\r\n\r\nAtomic and Nuclear Constants\r\n----------------------------\r\n\r\nConstant              | Symbol       | Unit              | Value\r\n--------------------- | ------------ | ----------------- | -----\r\nFineStructureConstant | $\\alpha$     | $1$               | 7.2973525376e-3\r\nRydbergConstant       | $T_{\\infty}$ | $\\frac{1}{m}$     | 10973731.568528\r\nBohrRadius            | $a_0$        | $m$               | 0.52917720859e-10\r\nHartreeEnergy         | $E_h$        | $J$               | 4.35974394e-18\r\nQuantumOfCirculation  |              | $\\frac{m^2}{s}$   | 3.6369475199e-4\r\nFermiCouplingConstant |              | $\\frac{1}{GeV^2}$ | 1.16637e-5\r\nWeakMixingAngle       |              |                   | 0.22256\r\nAvogadro              |              | $\\frac{1}{mol}$   | 6.0221412927e23\r\n\r\n#### Electron\r\n\r\nConstant                     | Unit             | Value\r\n---------------------------- | ---------------- | -----\r\nElectronMass                 | $kg$             | 9.10938215e-31\r\nElectronMassEnergyEquivalent | $J$              | 8.18710438e-14\r\nElectronMolarMass            | $\\frac{kg}{mol}$ | 5.4857990943e-7\r\nComptonWavelength            | $m$              | 2.4263102175e-12\r\nClassicalElectronRadius      | $m$              | 2.8179402894e-15\r\nThomsonCrossSection          | $m^2$            | 0.6652458558e-28\r\nElectronMagneticMoment       | $\\frac{J}{T}$    | -928.476377e-26\r\nElectronGFactor              |                  | -2.0023193043622\r\n\r\n#### Muon\r\n\r\nConstant                 | Unit             | Value\r\n------------------------ | ---------------- | -----\r\nMuonMass                 | $kg$             | 1.88353130e-28\r\nMuonMassEnegryEquivalent | $J$              | 1.692833511e-11\r\nMuonMolarMass            | $\\frac{kg}{mol}$ | 0.1134289256e-3\r\nMuonComptonWavelength    | $m$              | 11.73444104e-15\r\nMuonMagneticMoment       | $\\frac{J}{T}$    | -4.49044786e-26\r\nMuonGFactor              |                  | -2.0023318414\r\n\r\n#### Tau\r\n\r\nConstant                | Unit             | Value\r\n----------------------- | ---------------- | -----\r\nTauMass                 | $kg$             | 3.16777e-27\r\nTauMassEnergyEquivalent | $J$              | 2.84705e-10\r\nTauMolarMass            | $\\frac{kg}{mol}$ | 1.90768e-3\r\nTauComptonWavelength    | $m$              | 0.69772e-15\r\n\r\n#### Proton\r\n\r\nConstant                        | Unit             | Value\r\n------------------------------- | ---------------- | -----\r\nProtonMass                      | $kg$             | 1.672621637e-27\r\nProtonMassEnergyEquivalent      | $J$              | 1.503277359e-10\r\nProtonMolarMass                 | $\\frac{kg}{mol}$ | 1.00727646677e-3\r\nProtonComptonWavelength         | $m$              | 1.3214098446e-15\r\nProtonMagneticMoment            | $\\frac{J}{T}$    | 1.410606662e-26\r\nShieldedProtonMagneticMoment    | $\\frac{J}{T}$    | 1.410570419e-26\r\nProtonGFactor                   |                  | 5.585694713\r\nProtonGyromagneticRatio         | $\\frac{1}{T\\,s}$ | 2.675222099e8\r\nShieldedProtonGyromagneticRatio | $\\frac{1}{T\\,s}$ | 2.675153362e8\r\n\r\n#### Neutron\r\n\r\nConstant                    | Unit             | Value\r\n--------------------------- | ---------------- | -----\r\nNeutronMass                 | $kg$             | 1.674927212e-27\r\nNeutronMassEnegryEquivalent | $J$              | 1.505349506e-10\r\nNeutronMolarMass            | $\\frac{kg}{mol}$ | 1.00866491597e-3\r\nNeutronComptonWavelength    | $m$              | 1.3195908951e-1\r\nNeutronMagneticMoment       | $\\frac{J}{T}$    | -0.96623641e-26\r\nNeutronGFactor              |                  | -3.82608545\r\nNeutronGyromagneticRatio    | $\\frac{1}{T\\,s}$ | 1.83247185e8\r\n\r\n#### Deuteron\r\n\r\nConstant                     | Unit             | Value\r\n---------------------------- | ---------------- | -----\r\nDeuteronMass                 | $kg$             | 3.34358320e-27\r\nDeuteronMassEnegryEquivalent | $J$              |  3.00506272e-10\r\nDeuteronMolarMass            | $\\frac{kg}{mol}$ | 2.013553212725e-3\r\nDeuteronMagneticMoment       | $\\frac{J}{T}$    | 0.433073465e-26\r\n\r\n#### Helion\r\n\r\nConstant                   | Unit             | Value\r\n-------------------------- | ---------------- | -----\r\nHelionMass                 | $kg$             | 5.00641192e-27\r\nHelionMassEnegryEquivalent | $J$              | 4.49953864e-10\r\nHelionMolarMass            | $\\frac{kg}{mol}$ | 3.0149322473e-3\r\n"},{"uri":"https://numerics.mathdotnet.com/Contributing.html","title":"Contribute to Math.NET Numerics\r\n","content":"Contribute to Math.NET Numerics\r\n===============================\r\n\r\nMath.NET Numerics is driven by the community and contributors like you. I\u0027m excited that you\u0027re interested to help us move forward and improve Numerics. We usually accept contributions and try to attribute them properly, provided they keep the library consistent, focused and mathematically accurate. Have a look at the following tips to get started quickly. I\u0027m looking forward to your pull requests! Thanks!\r\n\r\n\u2014 *Christoph R\u00FCegg (@cdrnet)*\r\n\r\n## Getting Started\r\n\r\n- Make sure you have a [GitHub account](https://github.com/signup/free), it\u0027s free.\r\n- Please configure a proper name and email address in git ([how to](https://help.github.com/articles/set-up-git)). Real names are preferred, but it is acceptable to use an alias or even an obviously fake email address if you wish not to be contacted, as long as something is explicitly configured (not the default).\r\n- Fork the [mainline repository](https://github.com/mathnet/mathnet-numerics) on GitHub ([how to](https://help.github.com/articles/fork-a-repo)).\r\n\r\nWe use the [Fork \u0026 Pull Model](https://help.github.com/articles/using-pull-requests/), as common for GitHub projects. If you\u0027ve already contributed to another GitHub project then you\u0027re all set. If not, [here is another  introduction](https://gun.io/blog/how-to-github-fork-branch-and-pull-request/).\r\n\r\n**C# Solutions, Projects and Files**  \r\nWe have two kind of C# projects: primary (*Numerics.csproj, UnitTests.csproj*) and secondary (*Numerics-xy.csproj, UnitTests-xy.csproj*). The primary ones are the common VisualStudio project files you usually work with. The secondary projects on the other hand are not intended to be modified and include all files automatically. Whenever you need to add, remove or move a file, please do so in the primary projects only. In most cases we recommend to work with the \u0060MathNet.Numerics.sln\u0060 solution which only includes primary projects anyway - except when working on and testing portability/compatibility.\r\n\r\n**F# Projects**  \r\nF# does not support the wildcard approach of the C# projects by design, so whenever you add, remove or move an F# file please manually update all F# projects accordingly, including the secondary platform specific ones in the \u0060MathNet.Numerics.All.sln\u0060 solution. This is a bit tedious but we have not found a better solution yet.\r\n\r\n**Separate Branch per Pull Request**  \r\nWe recommend that you create a separate branch for each pull request, as opposed to using master. This makes it much easier to continue working on a pull request even after it has been opened on GitHub. Remember that GitHub automatically includes all future commits of the same branch to the pull request.\r\n\r\n**Focused**  \r\nWe prefer a couple small pull requests over a single large one that targets multiple things at once.\r\n\r\n### When fixing a bug ...\r\n\r\nIf you have a good idea how to fix it, directly open a pull request. Otherwise you may want to open an issue first (at GitHub) and discuss it there. If you can reproduce the bug with simple enough code, please consider adding a Unit Test that fails to confirm the bug.\r\n\r\n### When extending features ...\r\n\r\nIf you\u0027re extending some feature which is similar and close to existing code, for example adding a new probability distribution or a new Bessel-related special function, it\u0027s fine to directly open a pull request. We\u0027re likely to accept such pulls.\r\n\r\n### When adding new features ...\r\n\r\nIf you intend to add completely new features, say some spatial routines for geometrical transformations, we recommend to [talk to us](https://discuss.mathdotnet.com/c/numerics) first. This is mostly to avoid wasting your time in case we decide not to accept it, or require major refactoring. If the features is quite small it is perfectly fine to just open a pull request though. Sometimes it\u0027s easier to just show code instead of lengthy explanations.\r\n\r\nNote that your work does not need to be finished or complete at the time you open the pull request (but please do mention this in the message), as GitHub pull requests are an excellent tool to discuss an early prototype or skeleton before it is fully implemented.\r\n\r\n### When you wish to contribute but do not know where to start ...\r\n\r\nIssues marked with \u0022up-for-grabs\u0022 should be good candidates for a first contribution, but you can start with whatever you wish. If you decide to work on an existing issue, consider to add a comment to mention you\u0027re working on it.\r\n\r\nWhat works very well is to try to build something with real world data that uses Math.NET Numerics: you either end up with a nice example that we would love to include or refer to, or you run into things which are missing, unintuitive, broken or just a bit weird, which we\u0027d love to hear about so we (or you?) can fix it.\r\n\r\nShould you stumble on weird English grammar or wording please do fix it - most of the contributors are not native English speakers. That includes this document.\r\n\r\n## What to Avoid\r\n\r\n**Code Reformatting and Refactoring:**  \r\nPlease avoid starting with a major refactoring or any code reformatting without talking to us first.\r\n\r\n**Breaking Compatibility:**  \r\nWe try to follow [semantic versioning](https://semver.org/), meaning that we cannot break compatibility until the next major version. Since Numerics intentionally permits straight access to raw algorithms, a lot of member declarations are public and thus cannot be modified. Instead of breaking compatibility, it is often possible to create a new better version side by side though and mark the original implementation as obsolete and scheduled for removal on the next major version.\r\n\r\n**Merges:**  \r\nPlease avoid merging mainline back into your pull request branch. If you need to leverage some changes recently added to mainline, consider to rebase instead. In other words, please make sure your commits sit directly on top of a recent mainline master.\r\n"},{"uri":"https://numerics.mathdotnet.com/Contributors.html","title":"Math.NET Numerics Contributors\r\n","content":"Math.NET Numerics Contributors\r\n==============================\r\n\r\nThe Math.NET project is a community effort. We accept contributions and pull requests, but other support like submitting issues or helping the community are just as valuable. Why don\u0027t you join us as well?\r\n\r\n**Thanks for all the contributions!**\r\n\r\n### Maintainers\r\n\r\n- [Christoph R\u00FCegg](https://christoph.ruegg.name/) (@cdrnet) ([keybase.io/cdrnet](https://keybase.io/cdrnet))\r\n\r\n### Code Contributors\r\n\r\n*Essentially the output of \u0060git shortlog -sn\u0060 in original order.  \r\nFeel free to add a link to your personal site/blog and/or twitter handle.*\r\n\r\n- [Christoph R\u00FCegg](https://christoph.ruegg.name/) (@cdrnet)\r\n- [Marcus Cuda](https://marcuscuda.com/) (@marcuscuda)\r\n- Jurgen Van Gael (@jvangael)\r\n- Scott Stephens\r\n- Ignas Anikevicius\r\n- Jong Hyun Kim\r\n- Alexander Karatarakis\r\n- Tobias Glaubach\r\n- Erik Oveg\u00E5rd\r\n- Thomas Ibel\r\n- Yoonku Hwang\r\n- Gustavo Guerra\r\n- Kuan Bartel\r\n- Larz White\r\n- Alexander T\u00E4schner\r\n- Hani Medhat\r\n- MaLiN2223\r\n- Matthew Johnson\r\n- manyue\r\n- David Prince\r\n- Evangelink\r\n- Frank A. Krueger\r\n- Andriy Bratiychuk\r\n- Febin\r\n- Jack Pappas\r\n- Jon Smit\r\n- Phil Cleveland\r\n- jnyrup\r\n- Aappo Pulkkinen\r\n- Artyom Baranovskiy\r\n- Ashley Messer\r\n- Candy Chiu\r\n- Evelina Gabasova\r\n- Superbest\r\n- lionpeloux\r\n- mjmckp\r\n- Anders Gustafsson\r\n- Gauthier Segay\r\n- Hythem Sidky\r\n- John C Barstow\r\n- Justin Needham\r\n- Ksero\r\n- P. van der Velde\r\n- Robin Neatherway\r\n- Tom McTiernan\r\n- mikael\r\n- Alex Hildebrand\r\n- Andrew Kazyrevich\r\n- Arthur\r\n- Ethar Alali\r\n- Feodor Fitsner\r\n- Iain McDonald\r\n- Jakub Bialogrodzki\r\n- Jon Larborn\r\n- Juri\r\n- Kyle Parrigan\r\n- Regis Portalez\r\n- Ryan Blackwell\r\n- bdodson\r\n- borfudin\r\n- Aixile\r\n- Albert Pang\r\n- AlexHild\r\n- Amaury Lev\u00E9\r\n- Andrew Willshire\r\n- BenHewins\r\n- Colin Green\r\n- Dan\r\n- Daniel Fox\r\n- David Falkner\r\n- Elias Abou Jaoude\r\n- Eric Salem\r\n- Florian Wechsung\r\n- Gregor959\r\n- Guney Ozsan\r\n- Iain Sproat\r\n- IgorK\r\n- Jakub Arnold\r\n- Jeff Mastry\r\n- Joel Sleppy\r\n- Konstantin Tretyakov\r\n- Kosei ABE\r\n- Lucas Godshalk\r\n- Manor Askenazi\r\n- MarcoRoss84\r\n- Martin Posch\r\n- Matt Heffron\r\n- Max Malook\r\n- Michael Holroyd\r\n- Michel de Ruiter\r\n- Mirth Hickford\r\n- Paul Varkey\r\n- Philip Gruber\r\n- Philipp Huber\r\n- RR\r\n- Ryan Grange\r\n- Sergey Kosukhin\r\n- Sunny Ahuwanya\r\n- Till Hoffmann\r\n- Tomas Petricek\r\n- ViK\r\n- VicPara\r\n- Volker Breuer\r\n- arthurvb\r\n- bbieniek\r\n- bstrausser\r\n- Christoph Alber\r\n- grovesNL\r\n- jb\r\n- kayan\r\n- liuzh\r\n- logophobia\r\n- Matthew Peacock\r\n- nyuriks\r\n- seahearman\r\n- teramonagi\r\n- vvavrychuk\r\n\r\n### Indirect Code Contributors\r\n\r\n*Code submitted by other means that does not appear in the git history.  \r\nThis section is incomplete - let us know if we forgot something.*\r\n\r\n- Christian Woltering\r\n\r\n### dnAnalytics and Math.NET Iridium\r\n\r\n*Math.NET Numerics started by merging the dnAnalytics and Math.NET Iridium projects and their code base.*\r\n\r\n- [Marcus Cuda](https://marcuscuda.com/)\r\n- Jurgen Van Gael\r\n- Patrick van der Velde\r\n- [Christoph R\u00FCegg](https://christoph.ruegg.name/)\r\n- [Joann\u00E8s Vermorel](https://www.vermorel.com/)\r\n- Matthew Kitchin\r\n- Rana Ian\r\n- Andrew Kurochka\r\n- Thaddaeus Parker\r\n\r\n### Other Numerical Works, References \u0026 Resources\r\n\r\n*As inspiration, reference or more - depending on the licensing terms*\r\n\r\n- [ALGLIB](https://www.alglib.net/): Sergey Bochkanov\r\n- [Boost](https://www.boost.org/): John Maddock\r\n- [Netlib/Cephes Math Library](https://www.netlib.org/cephes/): Stephen L. Moshier\r\n- [Stand-alone code for numerical computing](https://www.johndcook.com/stand_alone_code.html): John D. Cook\r\n- [Miscellaneous Utility Library](https://www.yoda.arachsys.com/csharp/miscutil/): Marc Gravell, Jon Skeet\r\n- [NIST Digital Library of Mathematical Functions](https://www.johndcook.com/stand_alone_code.html)\r\n\r\n### Special Thanks\r\n\r\n*For other ways of support, documentation, website, feedback, software licenses, etc.*\r\n\r\n- Marcus Cuda (long time core contributor; license)\r\n- Jurgen Van Gael (long time core contributor)\r\n- F# Foundation \u0026 Community\r\n- Don Syme\r\n- Lokad SAS\r\n- Microsoft Corp\r\n- Xamarin (license)\r\n"},{"uri":"https://numerics.mathdotnet.com/CSV.html","title":"Delimited Text Files (CSV \u0026amp; TSV)\r\n","content":"Delimited Text Files (CSV \u0026 TSV)\r\n================================\r\n\r\nLikely the most common file format for tabular data, delimited files like CSV store data as text\r\nwith one line per row and values within rows separated by a comma.\r\nSuch text files are supported by virtually all software that deals with tabular data.\r\n\r\nExample:\r\n\r\n    [lang=text]\r\n    A,B,C\r\n    0.5,0.6,98.0\r\n    2.0,3.4,5.3\r\n\r\nUnfortunately there is no universal standard on what character is used as separator and how\r\nindividual values are formatted and escaped. CSV files traditionally use a comma as separator, but this\r\ncauses problems e.g. in Germany where the comma is used as decimal point in numbers. The tabulator\r\nproves to be a useful alternative, usually denoted by using the TSV extension instead of CSV.\r\nOther separators like semicolons or colons are common as well.\r\n\r\nMath.NET Numerics provides basic support for delimited files with the **MathNet.Numerics.Data.Text** package,\r\nwhich is available on NuGet as separate package and not included in the basic distribution.\r\n\r\n\r\nReading a matrix from a delimited file\r\n--------------------------------------\r\n\r\nThe \u0060DelimitedReader\u0060 class provides static functions to read a matrix from a file or string in delimited form.\r\nIt can read from:\r\n\r\n* **TextReader**: If you have your delimited data already in memory in a string,\r\n  you can use this method using a StringReader.\r\n* **Stream**: read directly from a stream, e.g. a MemoryStream, FileStream or NetworkStream.\r\n* **File Path (string)**: read from a file, specified by the file system path.\r\n\r\nAll these functions expect the data type of the matrix to be generated as generic type argument.\r\nOnly Double, Single, Complex and Complex32 are supported.\r\n\r\nExample:\r\n\r\n    [lang=csharp]\r\n    using MathNet.Numerics.Data.Text;\r\n\r\n    Matrix\u003Cdouble\u003E matrix = DelimitedReader.Read\u003Cdouble\u003E(\u0022data.csv\u0022, false, \u0022,\u0022, true);\r\n\r\nUnfortunately the lack of standard means that the parsing logic needs to be parametrized accordingly.\r\nThere are ways to automatically profile the provided file to find out the correct parameters automatically,\r\nbut for simplicity the Read functions expects those parameters explicitly as optional arguments:\r\n\r\n* **sparse**: Whether the the returned matrix should be constructed as sparse (true) or dense (false).  \r\n  Default: false.\r\n* **delimiter**: Number delimiter between numbers of the same line. Supports Regex groups.  \r\n  Default: \u0060\\s\u0060 (white space).\r\n* **hasHeaders**: Whether the first row contains column headers or not. If true, the first line will be skipped.  \r\n  Default: false.\r\n* **formatProvider**: The culture to use. It is often a good idea to use InvariantCulture,\r\n  to make the format independent from the local culture.  \r\n  Default: null.\r\n\r\n\r\nWriting a matrix to a delimited file\r\n------------------------------------\r\n\r\nThe dual to the reader above is the \u0060DelimitedWriter\u0060 class that can serialize a matrix\r\nto a delimited text file, stream or TextWriter.\r\n\r\nThe static Write functions accept the following optional arguments to control the output format:\r\n\r\n* **delimiter**: Number delimiter to write between numbers of the same line.  \r\n  Default: \u0060\\t\u0060 (tabulator).\r\n* **columnHeaders**: list of column header strings, or null if no headers should be written.  \r\n  Default: null.\r\n* **format**: The number format to use on each element, similar to what can be provided to Double.ToString().  \r\n  Default: null.\r\n* **formatProvider**: The culture to use. It is often a good idea to use InvariantCulture,\r\n  to make the format independent from the local culture.  \r\n  Default: null.\r\n\r\nExample:\r\n\r\n    [lang=csharp]\r\n    DelimitedWriter.Write(\u0022data.csv\u0022, matrix, \u0022,\u0022);\r\n\r\n\r\nAlternatives\r\n------------\r\n\r\nThe data extension packages also offer other ways to serialize a matrix to a binary stream or file.\r\nAmong others:\r\n\r\n* [NIST MatrixMarket text files](MatrixMarket.html)\r\n* [MATLAB Level-5 Mat files](MatlabFiles.html)\r\n"},{"uri":"https://numerics.mathdotnet.com/DescriptiveStatistics.html","title":"Descriptive Statistics\r\n","content":"    [hide]\r\n    #I \u0022../../out/lib/net40\u0022\r\n    #r \u0022MathNet.Numerics.dll\u0022\r\n    #r \u0022MathNet.Numerics.FSharp.dll\u0022\r\n    open System.Numerics\r\n    open MathNet.Numerics\r\n    open MathNet.Numerics.Statistics\r\n\r\nDescriptive Statistics\r\n======================\r\n\r\nInitialization\r\n--------------\r\n\r\nWe need to reference Math.NET Numerics and open the statistics namespace:\r\n\r\n    [lang=csharp]\r\n    using MathNet.Numerics.Statistics;\r\n\r\nUnivariate Statistical Analysis\r\n-------------------------------\r\n\r\nThe primary class for statistical analysis is \u0060Statistics\u0060 which provides common\r\ndescriptive statics as static extension methods to \u0060IEnumerable\u003Cdouble\u003E\u0060 sequences.\r\nHowever, various statistics can be computed much more efficiently if the data source\r\nhas known properties or structure, that\u0027s why the following classes provide specialized\r\nstatic implementations:\r\n\r\n* **ArrayStatistics** provides routines optimized for single-dimensional arrays. Some\r\n  of these routines end with the \u0060Inplace\u0060 suffix, indicating that they reorder the\r\n  input array slightly towards being sorted during execution - without fully sorting\r\n  them, which could be expensive.\r\n* **SortedArrayStatistics** provides routines optimized for an array sorting ascendingly.\r\n  Especially order-statistics are very efficient this way, some even with constant time complexity.\r\n* **StreamingStatistics** processes large amounts of data without keeping them in memory.\r\n  Useful if data larger than local memory is streamed directly from a disk or network.\r\n\r\nAnother alternative, in case you need to gather a whole set of statistical characteristics\r\nin one pass, is provided by the \u0060DescriptiveStatistics\u0060 class:\r\n\r\n    [lang=csharp]\r\n    var samples = new ChiSquare(5).Samples().Take(1000);\r\n    var statistics = new DescriptiveStatistics(samples);\r\n\r\n    var largestElement = statistics.Maximum;\r\n    var smallestElement = statistics.Minimum;\r\n    var median = statistics.Median;\r\n\r\n    var mean = statistics.Mean;\r\n    var variance = statistics.Variance;\r\n    var stdDev = statistics.StandardDeviation;\r\n\r\n    var kurtosis = statistics.Kurtosis;\r\n    var skewness = statistics.Skewness;\r\n\r\n\r\nMinimum \u0026 Maximum\r\n-----------------\r\n\r\nThe minimum and maximum values of a sample set can be evaluated with the \u0060Minimum\u0060 and \u0060Maximum\u0060\r\nfunctions of all four classes: \u0060Statistics\u0060, \u0060ArrayStatistics\u0060, \u0060SortedArrayStatistics\u0060\r\nand \u0060StreamingStatistics\u0060. The one in \u0060SortedArrayStatistics\u0060 is the fastest with constant\r\ntime complexity, but expects the array to be sorted ascendingly.\r\n\r\nBoth min and max are directly affected by outliers and are therefore no robust statistics at all.\r\nFor a more robust alternative, consider using Quantiles instead.\r\n\r\n    [lang=csharp]\r\n    var samples = new ChiSquare(5).Samples().Take(1000).ToArray();\r\n    var largestElement = samples.Maximum();\r\n    var smallestElement = samples.Minimum();\r\n\r\n\r\nMean\r\n----\r\n\r\nThe *arithmetic mean* or *average* of the provided samples. In statistics, the sample mean is\r\na measure of the central tendency and estimates the expected value of the distribution.\r\nThe mean is affected by outliers, so if you need a more robust estimate consider to use the Median instead.\r\n\r\n\u0060Statistics.Mean(data)\u0060\r\n\u0060StreamingStatistics.Mean(stream)\u0060\r\n\u0060ArrayStatistics.Mean(data)\u0060\r\n\r\n$$$\r\n\\overline{x} = \\frac{1}{N}\\sum_{i=1}^N x_i\r\n\r\n    [lang=fsharp]\r\n    let whiteNoise = Generate.Normal(1000, mean=10.0, standardDeviation=2.0)\r\n    // [fsi:val samples : float [] = [|12.90021939; 9.631515037; 7.810008046; 14.13301053; ...|] ]\r\n    Statistics.Mean whiteNoise\r\n    // [fsi:val it : float = 10.02162347]\r\n\r\n    let wave = Generate.Sinusoidal(1000, samplingRate=100., frequency=5., amplitude=0.5)\r\n    Statistics.Mean wave\r\n    // [fsi:val it : float = -4.133520783e-17]\r\n\r\nVariance and Standard Deviation\r\n-------------------------------\r\n\r\nVariance $\\sigma^2$ and the Standard Deviation $\\sigma$ are measures of how far the samples are spread out.\r\n\r\nIf the whole population is available, the functions with the Population-prefix\r\n will evaluate the respective measures with an $N$ normalizer for a population of size $N$.\r\n\r\n\u0060Statistics.PopulationVariance(population)\u0060\r\n\u0060Statistics.PopulationStandardDeviation(population)\u0060\r\n\r\n$$$\r\n\\sigma^2 = \\frac{1}{N}\\sum_{i=1}^N (x_i - \\mu)^2\r\n\r\nOn the other hand, if only a sample of the full population is available, the functions\r\nwithout the Population-prefix will estimate unbiased population measures by applying\r\nBessel\u0027s correction with an $N-1$ normalizer to a sample set of size $N$.\r\n\r\n\u0060Statistics.Variance(samples)\u0060\r\n\u0060Statistics.StandardDeviation(samples)\u0060\r\n\r\n$$$\r\ns^2 = \\frac{1}{N-1}\\sum_{i=1}^N (x_i - \\overline{x})^2\r\n\r\n    [lang=fsharp]\r\n    Statistics.Variance whiteNoise\r\n    // [fsi:val it : float = 3.819436094]\r\n    Statistics.StandardDeviation whiteNoise\r\n    // [fsi:val it : float = 1.954337764]\r\n\r\n    Statistics.Variance wave\r\n    // [fsi:val it : float = 0.1251251251]\r\n\r\n#### Combined Routines\r\n\r\nSince mean and variance are often needed together, there are routines\r\nthat evaluate both in a single pass:\r\n\r\n\u0060Statistics.MeanVariance(samples)\u0060\r\n\u0060ArrayStatistics.MeanVariance(samples)\u0060\r\n\u0060StreamingStatistics.MeanVariance(samples)\u0060\r\n\r\n    [lang=fsharp]\r\n    Statistics.MeanVariance whiteNoise\r\n    // [fsi:val it : float * float = (10.02162347, 3.819436094)]\r\n\r\nCovariance\r\n----------\r\n\r\nThe sample covariance is an estimation of the Covariance, a measure of how much two random\r\nvariables change together. Similarly to the variance above, there are two versions in order to\r\napply Bessel\u0027s correction to bias in case of sample data.\r\n\r\n\u0060Statistics.Covariance(samples1, samples2)\u0060\r\n\r\n$$$\r\nq = \\frac{1}{N-1}\\sum_{i=1}^N (x_i - \\overline{x})(y_i - \\overline{y})\r\n\r\n\u0060Statistics.PopulationCovariance(population1, population2)\u0060\r\n\r\n$$$\r\nq = \\frac{1}{N}\\sum_{i=1}^N (x_i - \\mu_x)(y_i - \\mu_y)\r\n\r\n    [lang=fsharp]\r\n    Statistics.Covariance(whiteNoise, whiteNoise)\r\n    // [fsi:val it : float = 3.819436094]\r\n    Statistics.Covariance(whiteNoise, wave)\r\n    // [fsi:val it : float = 0.04397985084]\r\n\r\nOrder Statistics\r\n----------------\r\n\r\n#### Order Statistic\r\n\r\nThe k-th order statistic of a sample set is the k-th smallest value. Note that,\r\nas an exception to most of Math.NET Numerics, the order k is one-based, meaning\r\nthe smallest value is the order statistic of order 1 (there is no order 0).\r\n\r\n\u0060Statistics.OrderStatistic(data, order)\u0060\r\n\u0060SortedArrayStatistics.OrderStatistic(data, order)\u0060\r\n\r\nIf the samples are sorted ascendingly, this is trivial and can be evaluated in constant time,\r\nwhich is what the \u0060SortedArrayStatistics\u0060 implementation does.\r\n\r\nIf you have the samples in an array which is not (guaranteed to be) sorted,\r\nbut if it is fine if the array does incrementally get sorted over multiple calls,\r\nyou can also use the following in-place implementation. It is usually faster\r\nthan fully sorting the array, unless you need to compute it for more than a handful orders.\r\n\r\n\u0060ArrayStatistics.OrderStatisticInplace(data, order)\u0060\r\n\r\nFor convenience there\u0027s also an option that returns a function \u0060Func\u003Cint, double\u003E\u0060,\r\nmapping from order to the resulting order statistic. Internally it sorts a copy of the\r\nprovided data and then on each invocation uses efficient sorted algorithms:\r\n\r\n\u0060Statistics.OrderStatisticFunc(data)\u0060\r\n\r\nSuch Inplace and Func variants are a common pattern throughout the Statistics class\r\nand also the rest of the library.\r\n\r\n    [lang=fsharp]\r\n    Statistics.OrderStatistic(whiteNoise, 1)\r\n    // [fsi:val it : float = 3.633070184]\r\n    Statistics.OrderStatistic(whiteNoise, 1000)\r\n    // [fsi:val it : float = 16.65183566]\r\n\r\n    let os = Statistics.orderStatisticFunc whiteNoise\r\n    os 250\r\n    // [fsi:val it : float = 8.645491746]\r\n    os 500\r\n    // [fsi:val it : float = 10.11872428]\r\n    os 750\r\n    // [fsi:val it : float = 11.33170746]\r\n\r\n#### Median\r\n\r\nMedian is a robust indicator of central tendency and much less affected by outliers\r\nthan the sample mean. The median is estimated by the value exactly in the middle of\r\nthe sorted set of samples and thus separating the higher half of the data from the lower half.\r\n\r\n\u0060Statistics.Median(data)\u0060\r\n\u0060SortedArrayStatistics.Median(data)\u0060\r\n\u0060ArrayStatistics.MedianInplace(data)\u0060\r\n\r\nThe median is only unique if the sample size is odd. This implementation internally\r\nuses the default quantile definition, which is equivalent to mode 8 in R and is approximately\r\nmedian-unbiased regardless of the sample distribution. If you need another convention, use\r\n\u0060QuantileCustom\u0060 instead, see below for details.\r\n\r\n    [lang=fsharp]\r\n    Statistics.Median whiteNoise\r\n    // [fsi:val it : float = 10.11872428]\r\n    Statistics.Median wave\r\n    // [fsi:val it : float = -2.452600839e-16]\r\n\r\n#### Quartiles and the 5-number summary\r\n\r\nQuartiles group the ascendingly sorted data into four equal groups, where each\r\ngroup represents a quarter of the data. The lower quartile is estimated by\r\nthe middle number between the first two groups and the upper quartile by the middle\r\nnumber between the remaining two groups. The middle number between the two middle groups\r\nestimates the median as discussed above.\r\n\r\n\u0060Statistics.LowerQuartile(data)\u0060\r\n\u0060Statistics.UpperQuartile(data)\u0060\r\n\u0060SortedArrayStatistics.LowerQuartile(data)\u0060\r\n\u0060SortedArrayStatistics.UpperQuartile(data)\u0060\r\n\u0060ArrayStatistics.LowerQuartileInplace(data)\u0060\r\n\u0060ArrayStatistics.UpperQuartileInplace(data)\u0060\r\n\r\n    [lang=fsharp]\r\n    Statistics.LowerQuartile whiteNoise\r\n    // [fsi:val it : float = 8.645491746]\r\n    Statistics.UpperQuartile whiteNoise\r\n    // [fsi:val it : float = 11.33213732]\r\n\r\nUsing that data we can provide a useful set of indicators usually named 5-number summary,\r\nwhich consists of the minimum value, the lower quartile, the median, the upper quartile and\r\nthe maximum value. All these values can be visualized in the popular box plot diagrams.\r\n\r\n\u0060Statistics.FiveNumberSummary(data)\u0060\r\n\u0060SortedArrayStatistics.FiveNumberSummary(data)\u0060\r\n\u0060ArrayStatistics.FiveNumberSummaryInplace(data)\u0060\r\n\r\n    [lang=fsharp]\r\n    Statistics.FiveNumberSummary whiteNoise\r\n    // [fsi:val it : float [] = [|3.633070184; 8.645937823; 10.12165054; 11.33213732; 16.65183566|] ]\r\n    Statistics.FiveNumberSummary wave\r\n    // [fsi:val it : float [] = [|-0.5; -0.3584185509; -2.452600839e-16; 0.3584185509; 0.5|] ]\r\n\r\nThe difference between the upper and the lower quartile is called inter-quartile range (IQR)\r\nand is a robust indicator of spread. In box plots the IQR is the total height of the box.\r\n\r\n\u0060Statistics.InterquartileRange(data)\u0060\r\n\u0060SortedArrayStatistics.InterquartileRange(data)\u0060\r\n\u0060ArrayStatistics.InterquartileRangeInplace(data)\u0060\r\n\r\nJust like median, quartiles use the default R8 quantile definition internally.\r\n\r\n    [lang=fsharp]\r\n    Statistics.InterquartileRange whiteNoise\r\n    // [fsi:val it : float = 2.686199498]\r\n\r\n#### Percentiles\r\n\r\nPercentiles extend the concept further by grouping the sorted values into 100\r\nequal groups and looking at the 101 places (0,1,..,100) between and around them.\r\nThe 0-percentile represents the minimum value, 25 the first quartile, 50 the median,\r\n75 the upper quartile and 100 the maximum value.\r\n\r\n\u0060Statistics.Percentile(data, p)\u0060\r\n\u0060Statistics.PercentileFunc(data)\u0060\r\n\u0060SortedArrayStatistics.Percentile(data, p)\u0060\r\n\u0060ArrayStatistics.PercentileInplace(data, p)\u0060\r\n\r\nJust like median, percentiles use the default R8 quantile definition internally.\r\n\r\n    [lang=fsharp]\r\n    Statistics.Percentile(whiteNoise, 5)\r\n    // [fsi:val it : float = 6.693373507]\r\n    Statistics.Percentile(whiteNoise, 98)\r\n    // [fsi:val it : float = 13.97580653]\r\n\r\n#### Quantiles\r\n\r\nInstead of grouping into 4 or 100 boxes, quantiles generalize the concept to an infinite number\r\nof boxes and thus to arbitrary real numbers $\\tau$ between 0.0 and 1.0, where 0.0 represents the\r\nminimum value, 0.5 the median and 1.0 the maximum value. Quantiles are closely related to\r\nthe inverse cumulative distribution function of the sample distribution.\r\n\r\n\u0060Statistics.Quantile(data, tau)\u0060\r\n\u0060Statistics.QuantileFunc(data)\u0060\r\n\u0060SortedArrayStatistics.Quantile(data, tau)\u0060\r\n\u0060ArrayStatistics.QuantileInplace(data, tau)\u0060\r\n\r\n    [lang=fsharp]\r\n    Statistics.Quantile(whiteNoise, 0.98)\r\n    // [fsi:val it : float = 13.97580653]\r\n\r\n#### Quantile Conventions and Compatibility\r\n\r\nRemember that all these descriptive statistics do not *compute* but merely *estimate*\r\nstatistical indicators of the value distribution. In the case of quantiles,\r\nthere is usually not a single number between the two groups specified by $\\tau$.\r\nThere are multiple ways to deal with this: the R project supports 9 modes and Mathematica\r\nand SciPy have their own way to parametrize the behavior.\r\n\r\nThe \u0060QuantileCustom\u0060 functions support all 9 modes from the R-project, which includes the one\r\nused by Microsoft Excel, and also the 4-parameter variant of Mathematica:\r\n\r\n\u0060Statistics.QuantileCustom(data, tau, definition)\u0060\r\n\u0060Statistics.QuantileCustomFunc(data, definition)\u0060\r\n\u0060SortedArrayStatistics.QuantileCustom(data, tau, a, b, c, d)\u0060\r\n\u0060SortedArrayStatistics.QuantileCustom(data, tau, definition)\u0060\r\n\u0060ArrayStatistics.QuantileCustomInplace(data, tau, a, b, c, d)\u0060\r\n\u0060ArrayStatistics.QuantileCustomInplace(data, tau, definition)\u0060\r\n\r\nThe \u0060QuantileDefinition\u0060 enumeration has the following options:\r\n\r\n* **R1**, SAS3, EmpiricalInvCDF\r\n* **R2**, SAS5, EmpiricalInvCDFAverage\r\n* **R3**, SAS2, Nearest\r\n* **R4**, SAS1, California\r\n* **R5**, Hydrology, Hazen\r\n* **R6**, SAS4, Nist, Weibull, SPSS\r\n* **R7**, Excel, Mode, S\r\n* **R8**, Median, Default\r\n* **R9**, Normal\r\n\r\n    [lang=fsharp]\r\n    Statistics.QuantileCustom(whiteNoise, 0.98, QuantileDefinition.R3)\r\n    // [fsi:val it : float = 13.97113209]\r\n    Statistics.QuantileCustom(whiteNoise, 0.98, QuantileDefinition.Excel)\r\n    // [fsi:val it : float = 13.97127374]\r\n\r\nRank Statistics\r\n---------------\r\n\r\n#### Ranks\r\n\r\nRank statistics are the counterpart to order statistics. The \u0060Ranks\u0060 function evaluates the rank\r\nof each sample and returns them as an array of doubles. The return type is double instead of int\r\nin order to deal with ties, if one of the values appears multiple times.\r\nSimilar to \u0060QuantileDefinition\u0060, the \u0060RankDefinition\u0060 enumeration controls how ties should be handled:\r\n\r\n* **Average**, Default: Replace ties with their mean (causing non-integer ranks).\r\n* **Min**, Sports: Replace ties with their minimum, as typical in sports ranking.\r\n* **Max**: Replace ties with their maximum.\r\n* **First**: Permutation with increasing values at each index of ties.\r\n* **EmpiricalCDF**\r\n\r\n\u0060Statistics.Ranks(data, definition)\u0060\r\n\u0060SortedArrayStatistics.Ranks(data, definition)\u0060\r\n\u0060ArrayStatistics.RanksInplace(data, definition)\u0060\r\n\r\n    [lang=fsharp]\r\n    Statistics.Ranks(whiteNoise)\r\n    // [fsi:val it : float [] = [|634.0; 736.0; 405.0; 395.0; 197.0; 167.0; 722.0; 44.0; ...|] ]\r\n    Statistics.Ranks([| 13.0; 14.0; 11.0; 12.0; 13.0 |], RankDefinition.Average)\r\n    // [fsi:val it : float [] = [|3.5; 5.0; 1.0; 2.0; 3.5|] ]\r\n    Statistics.Ranks([| 13.0; 14.0; 11.0; 12.0; 13.0 |], RankDefinition.Sports)\r\n    // [fsi:val it : float [] = [|3.0; 5.0; 1.0; 2.0; 3.0|] ]\r\n\r\n#### Quantile Rank\r\n\r\nCounterpart of the \u0060Quantile\u0060 function, estimates $\\tau$ of the provided $\\tau$-quantile value\r\n$x$ from the provided samples. The $\\tau$-quantile is the data value where the cumulative distribution\r\nfunction crosses $\\tau$.\r\n\r\n\u0060Statistics.QuantileRank(data, x, definition)\u0060\r\n\u0060Statistics.QuantileRankFunc(data, definition)\u0060\r\n\u0060SortedArrayStatistics.QuantileRank(data, x, definition)\u0060\r\n\r\n    [lang=fsharp]\r\n    Statistics.QuantileRank(whiteNoise, 13.0)\r\n    // [fsi:val it : float = 0.9370045563]\r\n    Statistics.QuantileRank(whiteNoise, 6.7, RankDefinition.Average)\r\n    // [fsi:val it : float = 0.04960610389]\r\n\r\nEmpirical Distribution Functions\r\n--------------------------------\r\n\r\n\u0060Statistics.EmpiricalCDF(data, x)\u0060\r\n\u0060Statistics.EmpiricalCDFFunc(data)\u0060\r\n\u0060Statistics.EmpiricalInvCDF(data, tau)\u0060\r\n\u0060Statistics.EmpiricalInvCDFFunc(data)\u0060\r\n\u0060SortedArrayStatistics.EmpiricalCDF(data, x)\u0060\r\n\r\n    [lang=fsharp]\r\n    let ecdf = Statistics.EmpiricalCDFFunc whiteNoise\r\n    Generate.LinearSpacedMap(20, start=3.0, stop=17.0, map=ecdf)\r\n    // [fsi:val it : float [] =]\r\n    // [fsi:    [|0.0; 0.001; 0.002; 0.005; 0.022; 0.05; 0.094; 0.172; 0.278; 0.423; 0.555; ]\r\n    // [fsi:      0.705; 0.843; 0.921; 0.944; 0.983; 0.992; 0.997; 0.999; 1.0|] ]\r\n\r\n    let eicdf = Statistics.empiricalInvCDFFunc whiteNoise\r\n    [ for tau in 0.0..0.05..1.0 -\u003E eicdf tau ]\r\n    // [fsi:val it : float [] =]\r\n    // [fsi:    [3.633070184; 6.682142043; 7.520000817; 8.040513497; 8.347587493; ]\r\n    // [fsi:     8.645491746; 9.02681611; 9.298987151; 9.522627142; 9.819352699; 10.11872428; ]\r\n    // [fsi:     10.35991046; 10.57530906; 10.8259542; 11.08605473; 11.33170746; 11.54356436; ]\r\n    // [fsi:     11.90973541; 12.4294346; 13.36889423; 16.65183566] ]\r\n\r\nHistograms\r\n----------\r\n\r\nA histogram can be computed using the [Histogram][hist] class. Its constructor takes\r\nthe samples enumerable, the number of buckets to create, plus optionally the range\r\n(minimum, maximum) of the sample data if available.\r\n\r\n  [hist]: https://numerics.mathdotnet.com/api/MathNet.Numerics.Statistics/Histogram.htm\r\n\r\n    [lang=csharp]\r\n    var histogram = new Histogram(samples, 10);\r\n    var bucket3count = histogram[2].Count;\r\n\r\n\r\nCorrelation\r\n-----------\r\n\r\nThe \u0060Correlation\u0060 class supports computing Pearson\u0027s product-momentum and Spearman\u0027s ranked\r\ncorrelation coefficient, as well as their correlation matrix for a set of vectors.\r\n\r\nCode Sample: Computing the correlation coefficient of 1000 samples of f(x) = 2x and g(x) = x^2:\r\n\r\n    [lang=csharp]\r\n    double[] dataF = Generate.LinearSpacedMap(1000, 0, 100, x =\u003E 2*x);\r\n    double[] dataG = Generate.LinearSpacedMap(1000, 0, 100, x =\u003E x*x);\r\n    double correlation = Correlation.Pearson(dataF, dataG);\r\n"},{"uri":"https://numerics.mathdotnet.com/Distance.html","title":"Distance Metrics\r\n","content":"Distance Metrics\r\n================\r\n\r\nA metric or distance function is a function $d(x,y)$ that defines the distance\r\nbetween elements of a set as a non-negative real number. If the distance is zero, both elements are equivalent\r\nunder that specific metric. Distance functions thus provide a way to measure how close two elements are, where elements\r\ndo not have to be numbers but can also be vectors, matrices or arbitrary objects. Distance functions are often used\r\nas error or cost functions to be minimized in an optimization problem.\r\n\r\nThere are multiple ways to define a metric on a set. A typical distance for real numbers is the absolute difference,\r\n$ d : (x, y) \\mapsto |x-y| $. But a scaled version of the absolute difference, or even $d(x, y) = \\begin{cases} 0 \u0026\\mbox{if } x = y \\\\ 1 \u0026 \\mbox{if } x \\ne y. \\end{cases}$\r\nare valid metrics as well. Every normed vector space induces a distance given by $d(\\vec x, \\vec y) = \\|\\vec x - \\vec y\\|$.\r\n\r\nMath.NET Numerics provides the following distance functions on vectors and arrays:\r\n\r\n\r\nSum of Absolute Difference (SAD)\r\n--------------------------------\r\n\r\n\u003Cimg src=\u0022DistanceSAD.png\u0022 style=\u0022width:87px; height:87px; float:left; margin:10px 10px 10px 0;\u0022 /\u003E\r\n\r\nThe sum of absolute difference is equivalent to the $L_1$-norm of the difference, also known as Manhattan- or Taxicab-norm.\r\nThe \u0060abs\u0060 function makes this metric a bit complicated to deal with analytically, but it is more robust than SSD.\r\n\r\n$$$\r\nd_{\\mathbf{SAD}} : (x, y) \\mapsto \\|x-y\\|_1 = \\sum_{i=1}^{n} |x_i-y_i|\r\n\r\n    [lang=csharp]\r\n    double d = Distance.SAD(x, y);\r\n\r\n\r\nSum of Squared Difference (SSD)\r\n-------------------------------\r\n\r\n\u003Cimg src=\u0022DistanceSSD.png\u0022 style=\u0022width:87px; height:87px; float:left; margin:10px 10px 10px 0;\u0022 /\u003E\r\n\r\nThe sum of squared difference is equivalent to the squared $L_2$-norm, also known as Euclidean norm.\r\nIt is therefore also known as Squared Euclidean distance.\r\nThis is the fundamental metric in least squares problems and linear algebra. The absence of the \u0060abs\u0060\r\nfunction makes this metric convenient to deal with analytically, but the squares cause it to be very\r\nsensitive to large outliers.\r\n\r\n$$$\r\nd_{\\mathbf{SSD}} : (x, y) \\mapsto \\|x-y\\|_2^2 = \\langle x-y, x-y\\rangle = \\sum_{i=1}^{n} (x_i-y_i)^2\r\n\r\n    [lang=csharp]\r\n    double d = Distance.SSD(x, y);\r\n\r\n\r\nMean-Absolute Error (MAE)\r\n-------------------------\r\n\r\n\u003Cimg src=\u0022DistanceMAE.png\u0022 style=\u0022width:87px; height:87px; float:left; margin:10px 10px 10px 0;\u0022 /\u003E\r\n\r\nThe mean absolute error is a normalized version of the sum of absolute difference.\r\n\r\n$$$\r\nd_{\\mathbf{MAE}} : (x, y) \\mapsto \\frac{d_{\\mathbf{SAD}}}{n} = \\frac{\\|x-y\\|_1}{n} = \\frac{1}{n}\\sum_{i=1}^{n} |x_i-y_i|\r\n\r\n    [lang=csharp]\r\n    double d = Distance.MAE(x, y);\r\n\r\n\r\nMean-Squared Error (MSE)\r\n------------------------\r\n\r\n\u003Cimg src=\u0022DistanceMSE.png\u0022 style=\u0022width:87px; height:87px; float:left; margin:10px 10px 10px 0;\u0022 /\u003E\r\n\r\nThe mean squared error is a normalized version of the sum of squared difference.\r\n\r\n$$$\r\nd_{\\mathbf{MSE}} : (x, y) \\mapsto \\frac{d_{\\mathbf{SSD}}}{n} = \\frac{\\|x-y\\|_2^2}{n} = \\frac{1}{n}\\sum_{i=1}^{n} (x_i-y_i)^2\r\n\r\n    [lang=csharp]\r\n    double d = Distance.MSE(x, y);\r\n\r\n\r\nEuclidean Distance\r\n------------------\r\n\r\n\u003Cimg src=\u0022DistanceEuclidean.png\u0022 style=\u0022width:87px; height:87px; float:left; margin:10px 10px 10px 0;\u0022 /\u003E\r\n\r\nThe euclidean distance is the $L_2$-norm of the difference, a special case of the Minkowski distance with p=2.\r\nIt is the natural distance in a geometric interpretation.\r\n\r\n$$$\r\nd_{\\mathbf{2}} : (x, y) \\mapsto \\|x-y\\|_2 = \\sqrt{d_{\\mathbf{SSD}}} = \\sqrt{\\sum_{i=1}^{n} (x_i-y_i)^2}\r\n\r\n    [lang=csharp]\r\n    double d = Distance.Euclidean(x, y);\r\n\r\n\r\nManhattan Distance\r\n------------------\r\n\r\n\u003Cimg src=\u0022DistanceManhattan.png\u0022 style=\u0022width:87px; height:87px; float:left; margin:10px 10px 10px 0;\u0022 /\u003E\r\n\r\nThe Manhattan distance is the $L_1$-norm of the difference, a special case of the Minkowski distance with p=1\r\nand equivalent to the sum of absolute difference.\r\n\r\n$$$\r\nd_{\\mathbf{1}} \\equiv d_{\\mathbf{SAD}} : (x, y) \\mapsto \\|x-y\\|_1 = \\sum_{i=1}^{n} |x_i-y_i|\r\n\r\n    [lang=csharp]\r\n    double d = Distance.Manhattan(x, y);\r\n\r\n\r\nChebyshev Distance\r\n------------------\r\n\r\n\u003Cimg src=\u0022DistanceChebyshev.png\u0022 style=\u0022width:87px; height:87px; float:left; margin:10px 10px 10px 0;\u0022 /\u003E\r\n\r\nThe Chebyshev distance is the $L_\\infty$-norm of the difference, a special case of the Minkowski distance\r\nwhere p goes to infinity. It is also known as Chessboard distance. \r\n\r\n$$$\r\nd_{\\mathbf{\\infty}} : (x, y) \\mapsto \\|x-y\\|_\\infty = \\lim_{p \\rightarrow \\infty}\\bigg(\\sum_{i=1}^{n} |x_i-y_i|^p\\bigg)^\\frac{1}{p} = \\max_{i} |x_i-y_i|\r\n\r\n    [lang=csharp]\r\n    double d = Distance.Chebyshev(x, y);\r\n\r\n\r\nMinkowski Distance\r\n------------------\r\n\r\n\u003Cimg src=\u0022DistanceMinkowski3.png\u0022 style=\u0022width:87px; height:87px; float:left; margin:10px 10px 10px 0;\u0022 /\u003E\r\n\r\nThe Minkowski distance is the generalized $L_p$-norm of the difference.\r\nThe contour plot on the left demonstrates the case of p=3.\r\n\r\n$$$\r\nd_{\\mathbf{p}} : (x, y) \\mapsto \\|x-y\\|_p = \\bigg(\\sum_{i=1}^{n} |x_i-y_i|^p\\bigg)^\\frac{1}{p}\r\n\r\n    [lang=csharp]\r\n    double d = Distance.Minkowski(p, x, y);\r\n\r\n\r\nCanberra Distance\r\n-----------------\r\n\r\n\u003Cimg src=\u0022DistanceCanberra.png\u0022 style=\u0022width:87px; height:87px; float:left; margin:10px 10px 10px 0;\u0022 /\u003E\r\n\r\nThe Canberra distance is a weighted version of the Manhattan distance, introduced and refined 1967 by Lance, Williams and Adkins.\r\nIt is often used for data scattered around an origin, as it is biased for measures around the origin and very sensitive for values close to zero.\r\n\r\n$$$\r\nd_{\\mathbf{CAD}} : (x, y) \\mapsto \\sum_{i=1}^{n} \\frac{|x_i-y_i|}{|x_i|\u002B|y_i|}\r\n\r\n    [lang=csharp]\r\n    double d = Distance.Canberra(x, y);\r\n\r\n\r\nCosine Distance\r\n---------------\r\n\r\n\u003Cimg src=\u0022DistanceCosine.png\u0022 style=\u0022width:87px; height:87px; float:left; margin:10px 10px 10px 0;\u0022 /\u003E\r\n\r\nThe cosine distance contains the dot product scaled by the product of the Euclidean distances from the origin.\r\nIt represents the angular distance of two vectors while ignoring their scale.\r\n\r\n$$$\r\nd_{\\mathbf{cos}} : (x, y) \\mapsto 1-\\frac{\\langle x, y\\rangle}{\\|x\\|_2\\|y\\|_2} = 1-\\frac{\\sum_{i=1}^{n} x_i y_i}{\\sqrt{\\sum_{i=1}^{n} x_i^2}\\sqrt{\\sum_{i=1}^{n} y_i^2}}\r\n\r\n    [lang=csharp]\r\n    double d = Distance.Cosine(x, y);\r\n\r\n\r\nPearson\u0027s Distance\r\n------------------\r\n\r\n\u003Cimg src=\u0022DistancePearson.png\u0022 style=\u0022width:87px; height:87px; float:left; margin:10px 10px 10px 0;\u0022 /\u003E\r\n\r\nThe Pearson distance is a correlation distance based on Pearson\u0027s product-momentum correlation coefficient\r\nof the two sample vectors. Since the correlation coefficient falls between [-1, 1], the Pearson distance\r\nlies in [0, 2] and measures the linear relationship between the two vectors.\r\n\r\n$$$\r\nd_{\\mathbf{Pearson}} : (x, y) \\mapsto 1 - \\mathbf{Corr}(x, y)\r\n\r\n    [lang=csharp]\r\n    double d = Distance.Pearson(x, y);\r\n\r\n\r\nHamming Distance\r\n----------------\r\n\r\nThe hamming distance represents the number of entries in the two sample vectors which are different.\r\nIt is a fundamental distance measure in information theory but less relevant in non-integer numerical problems.\r\n\r\n    [lang=csharp]\r\n    double d = Distance.Hamming(x, y);\r\n"},{"uri":"https://numerics.mathdotnet.com/Euclid.html","title":"Euclid \u0026amp; Number Theory\r\n","content":"Euclid \u0026 Number Theory\r\n======================\r\n\r\nThe static \u0060Euclid\u0060 class in the \u0060MathNet.Numerics\u0060 namespace provides routines related\r\nto the domain of integers.\r\n\r\n\r\nRemainder vs. Canonical Modulus\r\n-------------------------------\r\n\r\nRemainder and modulus are closely related operations with a long tradition of confusing \r\non with the other. The % operator in most computer languages implements one of the two,\r\nbut some even leave which one as an implementation detail (e.g. C-1990).\r\n\r\n*Warning: In C#, like most languages, % is the remainder operator, not the modulus!*\r\n\r\n\r\n#### Remainder\r\n\r\nThe **remainder** is the amount left over after performing the division of a dividend\r\nby a divisor, $\\frac{dividend}{divisor}$, which do not divide evenly, that is,\r\nwhere the result of the division cannot be expressed as an integer. It is thus natural\r\nthat the **remainder has the sign of the dividend**.\r\n\r\nIn C# and F#, the remainder is available as \u0060%\u0060 operator, in VB as \u0060Mod\u0060.\r\nAlternatively you can use the Reminder function:\r\n\r\n    [lang=csharp]\r\n    Euclid.Remainder( 5,  3); // =  2, such that 5 = 1*3 \u002B 2\r\n    Euclid.Remainder(-5,  3); // = -2, such that -5 = -1*3 - 2\r\n    Euclid.Remainder( 5, -3); // =  2, such that 5 = -1*-3 \u002B 2\r\n    Euclid.Remainder(-5, -3); // = -2, such that -5 = 1*-3 - 2\r\n\r\n\r\n#### Modulus\r\n\r\nOn the other hand, in modular arithmetic numbers \u0022wrap around\u0022 upon reaching a certain\r\nvalue n, or when crossing zero. Two real numbers are said to be *congruent modulo n*\r\nwhen their difference is an integer multiple of n. The modulo operator normalizes the dividend\r\nto the fundamental or smallest values congruent modulo n, where n is the divisor, and thus\r\nto the interval from 0 to n (including 0 but excluding n, possibly negative). It is thus natural that\r\nthe **modulus always has the sign of the divisor**.\r\n\r\n    [lang=csharp]\r\n    Euclid.Modulus( 5,  3); // =  2, congruent modulo 3 by 5 - 1*3\r\n    Euclid.Modulus(-5,  3); // =  1, congruent modulo 3 by -5 \u002B 2*3\r\n    Euclid.Modulus( 5, -3); // = -1, congruent modulo -3 by 5 \u002B 2*-3\r\n    Euclid.Modulus(-5, -3); // = -2, congruent modulo -3 by -5 - 1*-3\r\n\r\nA typical case where the modulus appears in daily life is when grouping students into 3 groups\r\nby letting them line up and count through as 0 1 2 0 1 2 0 1 2 etc. This way, each student will\r\nend up in the group of their order within the line modulus 3.\r\n\r\n\r\nInteger Properties\r\n------------------\r\n\r\n#### Even or Odd?\r\n\r\nVery simple question yet still somewhat error-prone to implement such that it works correctly\r\nfor both positive and negative integers: is a number even or odd?\r\n\r\n* \u0060IsEven(number)\u0060\r\n* \u0060IsOdd(number)\u0060\r\n\r\n\r\n#### Powers of two and Squares\r\n\r\nPowers of two are prevalent in computer engineering. For performance reasons it is often preferable\r\nto align data in blocks where the size is a power of two, i.e. $2^k$. The \u0060CeilingToPowerOfTwo\u0060 function\r\nhelps in such situations by finding the smallest perfect power of two larger than or equal to\r\nthe provided argument. There is also \u0060IsPowerOfTwo\u0060 to determine whether a number is such a power of two,\r\nand \u0060PowerOfTwo\u0060 to compute it efficiently.\r\n\r\nWhen switching the operands of $2^k$ we get the square $k^2$. \u0060IsPerfectSquare\u0060 determines whether\r\nthe integer argument is a perfect square, i.e. a square of an integer.\r\n\r\n\r\nEuclid\u0027s Algorithm\r\n------------------\r\n\r\n#### Greatest Common Divisor\r\n\r\nThe \u0060GreatestCommonDivisor\u0060 evaluates the **GCD** of either two integers or a full list or array of them\r\nusing Euclid\u0027s algorithm. An extended version also returns how exactly the GCD can be composed from two\r\ninteger arguments.\r\n\r\n    [lang=csharp]\r\n    Euclid.GreatestCommonDivisor(10, 15, 45); // 5\r\n\r\n    long x, y;\r\n    Euclid.ExtendedGreatestCommonDivisor(45, 18, out x, out y) // 9\r\n    // -\u003E x=1, y=-2, hence 9 == 1*45 \u002B -2*18\r\n\r\n\r\n#### Least Common Multiple\r\n\r\nClosely related to the GCD, \u0060LeastCommonMultiple\u0060 returns the **LCM** of two or more integers.\r\n\r\n    [lang=csharp]\r\n    Euclid.LeastCommonMultiple(3, 5, 6); // 30\r\n"},{"uri":"https://numerics.mathdotnet.com/Functions.html","title":"Special Functions\r\n","content":"Special Functions\r\n=================\r\n\r\nAll the following special functions are available in the static \u0060SpecialFunctions\u0060 class:\r\n\r\n\r\nFactorial\r\n---------\r\n\r\n* \u0060Factorial(x)\u0060\r\n\r\n$$$\r\nx \\mapsto x! = \\prod_{k=1}^{x} k = \\Gamma(x\u002B1)\r\n\r\nCode Sample:\r\n\r\n    [lang=csharp]\r\n    double x = SpecialFunctions.Factorial(14); // 87178291200.0\r\n    double y = SpecialFunctions.Factorial(31); // 8.2228386541779224E\u002B33\r\n\r\n* \u0060FactorialLn(x)\u0060\r\n\r\n$$$\r\nx \\mapsto \\ln x! = \\ln\\Gamma(x\u002B1)\r\n\r\n* \u0060Binomial(n,k)\u0060\r\n\r\nBinomial Coefficient\r\n\r\n$$$\r\n\\binom{n}{k} = \\mathrm{C}_n^k = \\frac{n!}{k! (n-k)!}\r\n\r\n* \u0060BinomialLn(n,k)\u0060\r\n\r\n$$$\r\n\\ln \\binom{n}{k} = \\ln n! - \\ln k! - \\ln(n-k)!\r\n\r\n* \u0060Multinomial(n,k[])\u0060\r\n\r\nMultinomial Coefficient\r\n\r\n$$$\r\n\\binom{n}{k_1,k_2,\\dots,k_r} = \\frac{n!}{k_1! k_2! \\cdots k_r!} = \\frac{n!}{\\prod_{i=1}^{r}k_i!}\r\n\r\n\r\nExponential Integral\r\n--------------------\r\n\r\n* \u0060ExponentialIntegral(x,n)\u0060\r\n\r\nGeneralized Exponential Integral\r\n\r\n$$$\r\nE_n(x) = \\int_1^\\infty t^{-n} e^{-xt}\\,\\mathrm{d}t\r\n\r\n\r\nGamma functions\r\n---------------\r\n\r\n#### Gamma\r\n* \u0060Gamma(a)\u0060\r\n\r\n$$$\r\n\\Gamma(a) = \\int_0^\\infty t^{a-1} e^{-t}\\,\\mathrm{d}t\r\n\r\n* \u0060GammaLn(a)\u0060\r\n\r\n$$$\r\n\\ln\\Gamma(a)\r\n\r\n\r\n#### Incomplete Gamma\r\n* \u0060GammaLowerIncomplete(a,x)\u0060\r\n\r\nLower incomplete Gamma function, unregularized.\r\n\r\n$$$\r\n\\gamma(a,x) = \\int_0^x t^{a-1} e^{-t}\\,\\mathrm{d}t\r\n\r\n* \u0060GammaUpperIncomplete(a,x)\u0060\r\n\r\nUpper incomplete Gamma function, unregularized.\r\n\r\n$$$\r\n\\Gamma(a,x) = \\int_x^\\infty t^{a-1} e^{-t}\\,\\mathrm{d}t\r\n\r\n\r\n#### Regularized Gamma\r\n* \u0060GammaLowerRegularized(a,x)\u0060\r\n\r\nLower regularized incomplete Gamma function.\r\n\r\n$$$\r\n\\mathrm{P}(a,x) = \\frac{\\gamma(a,x)}{\\Gamma(a)}\r\n\r\n* \u0060GammaUpperRegularized(a,x)\u0060\r\n\r\nUpper regularized incomplete Gamma function.\r\n\r\n$$$\r\n\\mathrm{Q}(a,x) = \\frac{\\Gamma(a,x)}{\\Gamma(a)}\r\n\r\n* \u0060GammaLowerRegularizedInv(a, y)\u0060\r\n\r\nInverse $x$ of the lower regularized Gamma function, such that $\\mathrm{P}(a,x) = y$.\r\n\r\n$$$\r\n\\mathrm{P}^{-1}(a,y)\r\n\r\n\r\n#### Psi: Derivative of Logarithmic Gamma\r\n* \u0060DiGamma(x)\u0060\r\n\r\n$$$\r\n\\psi(x) = \\frac{\\mathrm{d}}{\\mathrm{d}x}\\ln\\Gamma(x)\r\n\r\n* \u0060DiGammaInv(p)\u0060\r\n\r\nInverse $x$ of the DiGamma function, such that $\\psi(x) = p$.\r\n\r\n$$$\r\n\\psi^{-1}(p)\r\n\r\n\r\nEuler Beta functions\r\n--------------------\r\n\r\n#### Euler Beta\r\n* \u0060Beta(a,b)\u0060\r\n\r\n$$$\r\n\\mathrm{B}(a,b) = \\int_0^1 t^{a-1} (1-t)^{b-1}\\,\\mathrm{d}t = \\frac{\\Gamma(a)\\Gamma(b)}{\\Gamma(a\u002Bb)}\r\n\r\n* \u0060BetaLn(a,b)\u0060\r\n\r\n$$$\r\n\\ln\\mathrm{B}(a,b) = \\ln\\Gamma(a) \u002B \\ln\\Gamma(b) - \\ln\\Gamma(a\u002Bb)\r\n\r\n\r\n#### Incomplete Beta\r\n* \u0060BetaIncomplete(a,b,x)\u0060\r\n\r\nLower incomplete Beta function (unregularized).\r\n\r\n$$$\r\n\\mathrm{B}_x(a,b) = \\int_0^x t^{a-1} (1-t)^{b-1}\\,\\mathrm{d}t\r\n\r\n\r\n#### Regularized Beta\r\n* \u0060BetaRegularized(a,b,x)\u0060\r\n\r\nLower incomplete regularized Beta function.\r\n\r\n$$$\r\n\\mathrm{I}_x(a,b) = \\frac{\\mathrm{B}(a,b,x)}{\\mathrm{B}(a,b)}\r\n\r\n\r\nError functions\r\n---------------\r\n\r\n#### Error Function\r\n* \u0060Erf(x)\u0060\r\n\r\n$$$\r\n\\mathrm{erf}(x) = \\frac{2}{\\sqrt{\\pi}}\\int_0^x e^{-t^2}\\,\\mathrm{d}t\r\n\r\n* \u0060ErfInv(z)\u0060\r\n\r\nInverse $x$ of the Error function, such that $\\mathrm{erf}(x) = z$.\r\n\r\n$$$\r\nz \\mapsto \\mathrm{erf}^{-1}(z)\r\n\r\n\r\n#### Complementary Error function.\r\n* \u0060Erfc(x)\u0060\r\n\r\n$$$\r\n\\mathrm{erfc}(x) = 1-\\mathrm{erf}(x) = \\frac{2}{\\sqrt{\\pi}}\\int_x^\\infty e^{-t^2}\\,\\mathrm{d}t\r\n\r\n* \u0060ErfcInv(z)\u0060\r\n\r\nInverse $x$ of the complementary Error function, such that $\\mathrm{erfc}(x) = z$.\r\n\r\n$$$\r\nz \\mapsto \\mathrm{erfc}^{-1}(z)\r\n\r\nCode Sample:\r\n\r\n    [lang=csharp]\r\n    double erf = SpecialFunctions.Erf(0.9); // 0.7969082124\r\n\r\n\r\nSigmoid: Logistic function\r\n--------------------------\r\n\r\n* \u0060Logistic(x)\u0060\r\n\r\n$$$\r\nx \\mapsto \\frac{1}{1\u002Be^{-x}}\r\n\r\n* \u0060Logit(y)\u0060\r\n\r\nInverse of the Logistic function, for $y$ between 0 and 1 (where the function is real-valued).\r\n\r\n$$$\r\ny \\mapsto \\ln \\frac{y}{1-y}\r\n\r\n\r\nHarmonic Numbers\r\n----------------\r\n\r\n* \u0060Harmonic(t)\u0060\r\n\r\nThe n-th Harmonic number is the sum of the reciprocals of the first n natural numbers.\r\nWith $\\gamma$ as the Euler-Mascheroni constant and the DiGamma function:\r\n\r\n$$$\r\n\\mathrm{H}_n = \\sum_{k=1}^{n}\\frac{1}{k} = \\gamma - \\psi(n\u002B1)\r\n\r\n* \u0060GeneralHarmonic(n, m)\u0060\r\n\r\nGeneralized harmonic number of order n of m.\r\n\r\n$$$\r\n\\mathrm{H}_{n,m} = \\sum_{k=1}^{n}\\frac{1}{k^m}\r\n\r\n\r\nBessel and Struve Functions\r\n---------------------------\r\n\r\n#### Bessel functions\r\n\r\nBessel functions are canonical solutions $y(x)$ of Bessel\u0027s differential equation\r\n\r\n$$$\r\nx^2\\frac{\\mathrm{d}^2y}{\\mathrm{d}x^2}\u002Bx\\frac{\\mathrm{d}y}{\\mathrm{d}x}\u002B(x^2-\\alpha^2)y = 0\r\n\r\n#### Modified Bessel functions\r\n\r\nModified Bessel\u0027s equation:\r\n\r\n$$$\r\nx^2\\frac{\\mathrm{d}^2y}{\\mathrm{d}x^2}\u002Bx\\frac{\\mathrm{d}y}{\\mathrm{d}x}-(x^2\u002B\\alpha^2)y = 0\r\n\r\nModified Bessel functions:\r\n\r\n$$$\r\n\\begin{align}\r\n\\mathrm{I}_\\alpha(x) \u0026= \\imath^{-\\alpha}\\mathrm{J}_\\alpha(\\imath x) = \\sum_{m=0}^\\infty \\frac{1}{m!\\Gamma(m\u002B\\alpha\u002B1)}\\left(\\frac{x}{2}\\right)^{2m\u002B\\alpha} \\\\\r\n\\mathrm{K}_\\alpha(x) \u0026= \\frac{\\pi}{2} \\frac{\\mathrm{I}_{-\\alpha}(x)-\\mathrm{I}_\\alpha(x)}{\\sin(\\alpha\\pi)}\r\n\\end{align}\r\n\r\n* \u0060BesselI0(x)\u0060\r\n\r\nModified or hyperbolic Bessel function of the first kind, order 0.\r\n\r\n$$$\r\nx \\mapsto \\mathrm{I}_0(x)\r\n\r\n* \u0060BesselI1(x)\u0060\r\n\r\nModified or hyperbolic Bessel function of the first kind, order 1.\r\n\r\n$$$\r\nx \\mapsto \\mathrm{I}_1(x)\r\n\r\n* \u0060BesselK0(x)\u0060\r\n\r\nModified or hyperbolic Bessel function of the second kind, order 0.\r\n\r\n$$$\r\nx \\mapsto \\mathrm{K}_0(x)\r\n\r\n* \u0060BesselK0e(x)\u0060\r\n\r\nExponentionally scaled modified Bessel function of the second kind, order 0.\r\n\r\n$$$\r\nx \\mapsto e^x\\mathrm{K}_0(x)\r\n\r\n* \u0060BesselK1(x)\u0060\r\n\r\nModified or hyperbolic Bessel function of the second kind, order 1.\r\n\r\n$$$\r\nx \\mapsto \\mathrm{K}_1(x)\r\n\r\n* \u0060BesselK1e(x)\u0060\r\n\r\nExponentially scaled modified Bessel function of the second kind, order 1.\r\n\r\n$$$\r\nx \\mapsto e^x\\mathrm{K}_1(x)\r\n\r\n#### Struve functions\r\n\r\nStruve functions are solutions $y(x)$ of the non-homogeneous Bessel\u0027s differential equation\r\n\r\n$$$\r\nx^2\\frac{\\mathrm{d}^2y}{\\mathrm{d}x^2}\u002Bx\\frac{\\mathrm{d}y}{\\mathrm{d}x}\u002B(x^2-\\alpha^2)y = \\frac{4(\\frac{x}{2})^{\\alpha\u002B1}}{\\sqrt{\\pi}\\Gamma(\\alpha\u002B\\frac{1}{2})}\r\n\r\n\r\n#### Modified Struve functions\r\n\r\nModified equation:\r\n\r\n$$$\r\nx^2\\frac{\\mathrm{d}^2y}{\\mathrm{d}x^2}\u002Bx\\frac{\\mathrm{d}y}{\\mathrm{d}x}-(x^2\u002B\\alpha^2)y = \\frac{4(\\frac{x}{2})^{\\alpha\u002B1}}{\\sqrt{\\pi}\\Gamma(\\alpha\u002B\\frac{1}{2})}\r\n\r\nModified Struve functions:\r\n\r\n$$$\r\n\\mathrm{L}_\\alpha(x) = \\left(\\frac{x}{2}\\right)^{\\alpha\u002B1}\\sum_{k=0}^\\infty \\frac{1}{\\Gamma(\\frac{3}{2}\u002Bk)\\Gamma(\\frac{3}{2}\u002Bk\u002B\\alpha)}\\left(\\frac{x}{2}\\right)^{2k}\r\n\r\n* \u0060StruveL0(x)\u0060\r\n\r\nModified Struve function of order 0.\r\n\r\n$$$\r\nx \\mapsto \\mathrm{L}_0(x)\r\n\r\n* \u0060StruveL1(x)\u0060\r\n\r\nModified Struve function of order 1.\r\n\r\n$$$\r\nx \\mapsto \\mathrm{L}_1(x)\r\n\r\n\r\n#### Misc\r\n\r\n* \u0060BesselI0MStruveL0(x)\u0060\r\n\r\nDifference between the Bessel $I_0$ and the Struve $L_0$ functions.\r\n\r\n$$$\r\nx \\mapsto I_0(x) - L_0(x)\r\n\r\n* \u0060BesselI1MStruveL1(x)\u0060\r\n\r\nDifference between the Bessel $I_1$ and the Struve $L_1$ functions.\r\n\r\n$$$\r\nx \\mapsto I_1(x) - L_1(x)\r\n\r\n\r\nNumeric Stability\r\n-----------------\r\n\r\n* \u0060ExponentialMinusOne(power)\u0060\r\n\r\n$\\exp x-1$ is a typical case where a subtraction can be fatal for accuracy.\r\nFor example, at $10^{-13}$ the naive expression is 0.08% off, at $10^{-15}$\r\nroughly 11% and at $10^{-18}$ it just returns 0.\r\n\r\n$$$\r\nx \\mapsto e^x - 1\r\n\r\n* \u0060Hypotenuse(a, b)\u0060\r\n\r\n$$$\r\n(a,b) \\mapsto \\sqrt{a^2 \u002B b^2}\r\n\r\n\r\nTrigonometry\r\n------------\r\n\r\nThe \u0060Trig\u0060 class provides the complete set of fundamental trigonometric functions\r\nfor both real and complex arguments.\r\n\r\n* **Trigonometric**: Sin, Cos, Tan, Cot, Sec, Csc\r\n* **Trigonometric Inverse**: Asin, Acos, Atan, Acot, Asec, Acsc\r\n* **Hyperbolic**: Sinh, Cosh, Tanh, Coth, Sech, Csch\r\n* **Hyperbolic Area**: Asinh, Acosh, Atanh, Acoth, Asech, Acsch\r\n* **Sinc**: Normalized sinc function $x \\mapsto \\frac{\\sin\\pi x}{\\pi x}$\r\n* Conversion routines between radian, degree and grad.\r\n"},{"uri":"https://numerics.mathdotnet.com/Generate.html","title":"Generating Data\r\n","content":"    [hide]\r\n    #I \u0022../../out/lib/net40\u0022\r\n    #r \u0022MathNet.Numerics.dll\u0022\r\n    #r \u0022MathNet.Numerics.FSharp.dll\u0022\r\n    open System.Numerics\r\n    open MathNet.Numerics\r\n    open MathNet.Numerics.Statistics\r\n    let a = [| 2.0; 4.0; 3.0; 6.0 |]\r\n\r\nGenerating Data\r\n===============\r\n\r\nNumerics is all about analyzing and manipulating numeric data. But unless you can read in data from an external\r\nfile, source or e.g. with the excellent [F# Type Providers](https://fsharp.github.io/FSharp.Data/),\r\nyou may need to generate synthetic or random data locally, or transform existing data into a new form.\r\nThe \u0060Generate\u0060 class can help you in all these scenarios with a set of static functions generating either\r\nan array or an IEnumerable sequence.\r\n\r\nThere is some overlap with LINQ, in case of F# also with some integrated language features and its fundamental types.\r\nThis is intended for simplicity and consistency between array and sequence operations, as LINQ only supports sequences.\r\n\r\n\r\nLinear Range\r\n------------\r\n\r\nGenerates a linearly spaced array within the inclusive interval between start and stop,\r\nand either a provided step or a step of 1.0. Linear range is equivalent to the\r\nsingle colon \u0060:\u0060 and double colon \u0060::\u0060 operators in MATLAB.\r\n\r\nF# has built in linear range support in array comprehensions with the colon operator:\r\n\r\n    [lang=fsharp]\r\n    [ 10.0 .. 2.0 .. 15.0 ]\r\n    // [fsi:val it : float list = [10.0; 12.0; 14.0] ]\r\n    [ for x in 10.0 .. 2.0 .. 15.0 -\u003E sin x ]\r\n    // [fsi:val it : float list = [-0.5440211109; -0.536572918; 0.9906073557] ]\r\n\r\nIn C# you can get the same result with \u0060LinearRange\u0060:\r\n\r\n    [lang=csharp]\r\n    Generate.LinearRange(10, 2, 15); // returns array { 10.0, 12.0, 14.0 }\r\n    Generate.LinearRangeMap(10, 2, 15, Math.Sin); // applies sin(x) to each value\r\n\r\nMost of the routines in the \u0060Generate\u0060 class have variants with a \u0060Map\u0060 suffix.\r\nInstead of returning an array with the generated numbers, these routines instead\r\napply the generated numbers to a custom function and return an array with the results.\r\nSimilarly, some routines have variants with a \u0060Sequence\u0060 suffix that return\r\nlazy enumerable sequences instead of arrays.\r\n\r\n\r\nLinear-Spaced and Log-Spaced\r\n----------------------------\r\n\r\nGenerates a linearly or log-spaced array within an interval, but other than linear range\r\nwhere the step is provided, here we instead provide the number of values we want.\r\nThis is equivalent to the linspace and logspace operators in MATLAB.\r\n\r\n    [lang=csharp]\r\n    Generate.LinearSpaced(11, 0.0, 1.0); // returns array { 0.0, 0.1, 0.2, .., 1.0 }\r\n    Generate.LinearSpacedMap(15, 0.0, Math.Pi, Math.Sin); // applies sin(x) to each value\r\n\r\nIn F# you can also use:\r\n\r\n    [lang=fsharp]\r\n    Generate.linearSpacedMap 15 0.0 Math.PI sin\r\n    // [fsi:val it : float [] = ]\r\n    // [fsi:  [|0.0; 0.222520934; 0.4338837391; 0.6234898019; 0.7818314825; 0.9009688679; ]\r\n    // [fsi:    0.9749279122; 1.0; 0.9749279122; 0.9009688679; 0.7818314825; 0.6234898019; ]\r\n    // [fsi:    0.4338837391; 0.222520934; 1.224606354e-16|] ]\r\n\r\n\u0060LogSpaced\u0060 works the same way but instead of the values $10^x$ it spaces the decade exponents $x$ linearly\r\nbetween the provided two exponents.\r\n\r\n    [lang=csharp]\r\n    Generate.LogSpaced(4,0,3); // returns array { 1, 10, 100, 1000 }\r\n\r\n\r\nKronecker Delta Impulse\r\n-----------------------\r\n\r\nThe Kronecker delta $\\delta[n]$ is a fundamental signal in time-discrete signal processing,\r\noften referred to as *unit impulse*. When applied to a system, the resulting output is the system\u0027s *impulse response*.\r\nIt is closely related to the Dirac delta impulse function $\\delta(x)$ in continuous signal processing.\r\n\r\n$$$\r\n\\delta[n] = \\begin{cases} 0 \u0026\\mbox{if } n \\ne 0 \\\\ 1 \u0026 \\mbox{if } n = 0\\end{cases}\r\n\r\nThe \u0060Impulse\u0060 routine generates a Kronecker delta impulse, but also accepts a sample delay\r\nparameter $d$ and amplitude $A$ such that the resulting generated signal is\r\n\r\n$$$\r\ns[n] = A\\cdot\\delta[n-d] = \\begin{cases} 0 \u0026\\mbox{if } n \\ne d \\\\ A \u0026 \\mbox{if } n = d\\end{cases}\r\n\r\nThere is also a periodic version in \u0060PeriodicImpulse\u0060 which accepts an additional \u0060period\u0060 parameter.\r\n\r\n    [lang=fsharp]\r\n    Generate.Impulse(8, 2.0, 3)\r\n    // [fsi:val it : float [] = [|0.0; 0.0; 0.0; 2.0; 0.0; 0.0; 0.0; 0.0|] ]\r\n\r\n    Generate.PeriodicImpulse(8, 3, 10.0, 1)\r\n    // [fsi:val it : float [] = [|0.0; 10.0; 0.0; 0.0; 10.0; 0.0; 0.0; 10.0|] ]\r\n\r\n\r\nHeaviside Step\r\n--------------\r\n\r\nAnother fundamental signal in signal processing, the Heaviside step function $H[n]$\r\nis the integral of the Dirac delta impulse and represents a signal that switches on\r\nat a specified time and then stays on indefinitely. In discrete time:\r\n\r\n$$$\r\nH[n] = \\begin{cases} 0 \u0026\\mbox{if } n \u003C 0 \\\\ 1 \u0026 \\mbox{if } n \\ge 0\\end{cases}\r\n\r\nThe \u0060Step\u0060 routines generates a Heaviside step, but just like the Kronecker Delta impulse\r\n also accepts a sample delay parameter $d$ and amplitude $A$ such that the resulting generated signal is\r\n\r\n$$$\r\ns[n] = A\\cdot H[n-d] = \\begin{cases} 0 \u0026\\mbox{if } n \u003C d \\\\ A \u0026 \\mbox{if } n \\ge d\\end{cases}\r\n\r\n    [lang=fsharp]\r\n    Generate.Step(8, 2.0, 3)\r\n    // [fsi:val it : float [] = [|0.0; 0.0; 0.0; 2.0; 2.0; 2.0; 2.0; 2.0|] ]\r\n\r\n\r\nPeriodic Sawtooth\r\n-----------------\r\n\r\nGenerates an array of the given length with a periodic upper forward sawtooth signal,\r\ni.e. a line starting at zero up to some amplitude $A$, then drop back to zero instantly and start afresh.\r\nThe sawtooth can be used to turn any arbitrary function defined over the interval $[0,A)$ into a\r\nperiodic function by repeating it continuously.\r\n\r\nMathematically, the sawtooth can be described using the fractional part function\r\n$\\mathrm{frac}(x) \\equiv x - \\lfloor x \\rfloor$, frequency $\\nu$ and phase $\\theta$ as\r\n\r\n$$$\r\ns(x) = A\\cdot\\mathrm{frac}\\left(x\\nu\u002B\\frac{\\theta}{A}\\right)\r\n\r\nIn a trigonometric interpretation the signal represents the angular position $\\alpha$ of a point moving endlessly\r\naround a circle with radius $\\frac{A}{2\\pi}$ (and thus circumference $A$) in constant speed,\r\nnormalized to strictly $0\\le\\alpha \u003C A$.\r\n\r\n\u0060Generate.Periodic(length,samplingRate,frequency,amplitude,phase,delay)\u0060\r\n\r\n* **Sampling Rate**: Number of samples $r$ per time unit. If the time unit is 1s, the sampling rate has unit Hz.\r\n* **Frequency**: Frequency $\\nu$ of the signal, in sawtooth-periods per time unit. If the time unit is 1s, the frequency has unit Hz.\r\n  For a desired number of samples $n$ per sawtooth-period and sampling rate $r$ choose $\\nu=\\frac{r}{n}$.\r\n* **Amplitude**: The theoretical maximum value $A$, which is never reached and logically equivalent to zero.\r\n  The circumference of the circle. Typically $1$ or $2\\pi$.\r\n* **Phase**: Optional initial value or phase offset. Contributes to $\\theta$.\r\n* **Delay**: Optional initial delay, in samples. Contributes to $\\theta$.\r\n\r\nThe equivalent map function accepts a custom map lambda as second argument after the length:\r\n\r\n    [lang=fsharp]\r\n    Generate.periodicMap 15 ((\u002B) 100.0) 1000.0 100.0 10.0 0.0 0\r\n    // [fsi:val it : float [] = ]\r\n    // [fsi:  [|100.0; 101.0; 102.0; 103.0; 104.0; 105.0; 106.0; 107.0; 108.0; 109.0; ]\r\n    // [fsi:    100.0; 101.0; 102.0; 103.0; 104.0|] ]\r\n\r\n\r\nSinusoidal\r\n----------\r\n\r\nGenerates a Sine wave array of the given length. This is equivalent to applying a scaled\r\ntrigonometric Sine function to a periodic sawtooth of amplitude $2\\pi$.\r\n\r\n$$$\r\ns(x) = A\\cdot\\sin(2\\pi\\nu x \u002B \\theta)\r\n\r\n\u0060Generate.Sinusoidal(length,samplingRate,frequency,amplitude,mean,phase,delay)\u0060\r\n\r\n    [lang=csharp]\r\n    Generate.Sinusoidal(15, 1000.0, 100.0, 10.0);\r\n    // returns array { 0, 5.9, 9.5, 9.5, 5.9, 0, -5.9, ... }\r\n\r\n\r\nRandom\r\n------\r\n\r\nGenerate random sequences by sampling from a random distribution.\r\n\r\n\r\n#### Uniform Distribution\r\n\r\nGenerate sample sequences distributed uniformly between 0 and 1.\r\n\r\n    [lang=csharp]\r\n    Generate.Uniform(100); // e.g. 0.867421787170424, 0.236744313145403, ... \r\n\r\nUniform supports mapping to functions with not only one but also two uniform variables\r\nas arguments, with \u0060UniformMap\u0060 and \u0060UniformMap2\u0060. As usual, lazy sequences can be\r\ngenerated using the variants with the \u0060Sequence\u0060 suffix, e.g. \u0060UniformMap2Sequence\u0060.\r\n\r\n\r\n#### Non-Uniform Distributions\r\n\r\nInstead of uniform we can also sample from other distributions.\r\n\r\n* \u0060Normal\u0060 - sample an array or sequence form a normal distribution\r\n* \u0060Standard\u0060 - sample an array or sequence form a standard distribution\r\n\r\nIn addition, the \u0060Random\u0060 functions accept a custom distribution instance to sample\r\nfrom. See the section about random numbers and probability distributions for details.\r\n\r\n\r\nMap\r\n---\r\n\r\nGenerates a new array or sequence where each new values is the result of applying the provided function\r\nthe the corresponding value in the input data.\r\n\r\n    [lang=csharp]\r\n    var a = new double[] { 2.0, 4.0, 3.0, 6.0 };\r\n    Generate.Map(a, x =\u003E x \u002B 1.0); // returns array { 3.0, 5.0, 4.0, 7.0 }\r\n\r\nIn F# you\u0027d typically use the Array module to the same effect (and should continue to do so):\r\n\r\n    [lang=fsharp]\r\n    Array.map ((\u002B) 1.0) a\r\n    // [fsi:val it : float [] = [|3.0; 5.0; 4.0; 7.0|] ]\r\n\r\n...but no equivalent operation is available in the .NET base class libraries (BCL) for C#.\r\nYou can use LINQ, but that operates on sequences instead of arrays:\r\n\r\n    [lang=csharp]\r\n    a.Select(x =\u003E x \u002B 1.0).ToArray();\r\n\r\nSimilarly, with \u0060Map2\u0060 you can also map a function accepting two inputs to two input arrays:\r\n\r\n    [lang=fsharp]\r\n    let b = [| 1.0; -1.0; 2.0; -2.0 |]\r\n    Generate.Map2(a, b, fun x y -\u003E x \u002B y)\r\n    // [fsi:val it : float [] = [|3.0; 3.0; 5.0; 4.0|] ]\r\n\r\nTypical F# equivalent:\r\n\r\n    [lang=fsharp]\r\n    Array.map2 (\u002B) a b\r\n    // [fsi:val it : float [] = [|3.0; 3.0; 5.0; 4.0|] ]\r\n\r\nAnd in C# with LINQ:\r\n\r\n    [lang=csharp]\r\n    a.Zip(b, (x, y) =\u003E x \u002B y).ToArray();\r\n"},{"uri":"https://numerics.mathdotnet.com/IFsharpNotebook.html","title":"IF# Notebook\r\n","content":"    [hide]\r\n    #I \u0022../../out/lib/net40\u0022\r\n    #r \u0022MathNet.Numerics.dll\u0022\r\n    #r \u0022MathNet.Numerics.FSharp.dll\u0022\r\n    open System.Numerics\r\n    open MathNet.Numerics\r\n    open MathNet.Numerics.LinearAlgebra\r\n\r\nIF# Notebook\r\n============\r\n\r\n[iPython](https://ipython.org/) provides a rich browser-based interactive notebook with support for code, text, mathematical expressions,\r\ninline plots and other rich media. [IfSharp](https://github.com/BayardRock/IfSharp), developed by Bayard Rock, is an F# profile\r\nfor iPython with IntelliSense and embedded FSharp.Charting. Thanks to its NuGet support it can load other packages like Math.NET Numerics on demand.\r\n\r\n![Screenshot](img/IfSharp-GenerateIS.png)\r\n\r\n\r\nInstalling IF# Notebook\r\n-----------------------\r\n\r\nFollow the instructions at [IfSharp/Installation](https://bayardrock.github.io/IfSharp/installation.html).\r\n\r\nEssentially:\r\n\r\n1. Install [Anaconda](https://continuum.io/downloads)\r\n2. In a shell, run\r\n\r\n    conda update conda\r\n    conda update ipython\r\n\r\n3. Install [IfSharp](https://github.com/BayardRock/IfSharp/releases).\r\n\r\n\r\nDisplay Printers for Matrices and Vectors\r\n-----------------------------------------\r\n\r\nBy itself IfSharp does not know how to display matrices and vectors in a nice way, but we can tell it how to do so by providing our own display printers for them.\r\nSince v3.3 the Math.NET Numerics F# package includes a script \u0060MathNet.Numerics.IfSharp.fsx\u0060 to do so.\r\nUnfortunately loading this script requires the exact version in the path - if you know a way to avoid this please let us know.\r\n\r\n![Screenshot](img/IfSharp-MatrixVector.png)\r\n\r\nAlternatively you can also use the code below and adapt it to your needs, e.g. if you want it to show more rows.\r\n\r\n    [lang=fsharp]\r\n    open MathNet.Numerics.LinearAlgebra\r\n\r\n    let inline (|Float|_|) (v:obj) =\r\n        if v :? float then Some(v :?\u003E float) else None\r\n    let inline (|Float32|_|) (v:obj) =\r\n        if v :? float32 then Some(v :?\u003E float32) else None\r\n    let inline (|PositiveInfinity|_|) (v: ^T) =\r\n        if (^T : (static member IsPositiveInfinity: \u0027T -\u003E bool) (v))\r\n        then Some PositiveInfinity else None\r\n    let inline (|NegativeInfinity|_|) (v: ^T) =\r\n        if (^T : (static member IsNegativeInfinity: \u0027T -\u003E bool) (v))\r\n        then Some NegativeInfinity else None\r\n    let inline (|NaN|_|) (v: ^T) =\r\n        if (^T : (static member IsNaN: \u0027T -\u003E bool) (v))\r\n        then Some NaN else None\r\n\r\n    let inline formatMathValue (floatFormat:string) = function\r\n      | PositiveInfinity -\u003E \u0022\\\\infty\u0022\r\n      | NegativeInfinity -\u003E \u0022-\\\\infty\u0022\r\n      | NaN -\u003E \u0022\\\\times\u0022\r\n      | Float v -\u003E v.ToString(floatFormat)\r\n      | Float32 v -\u003E v.ToString(floatFormat)\r\n      | v -\u003E v.ToString()\r\n\r\n    let inline formatMatrix (matrix: Matrix\u003C\u0027T\u003E) =\r\n      String.concat Environment.NewLine\r\n        [ \u0022\\\\begin{bmatrix}\u0022\r\n          matrix.ToMatrixString(10,4,7,2,\u0022\\\\cdots\u0022,\u0022\\\\vdots\u0022,\u0022\\\\ddots\u0022,\r\n            \u0022 \u0026 \u0022, \u0022\\\\\\\\ \u0022 \u002B Environment.NewLine, (fun x -\u003E formatMathValue \u0022G4\u0022 x))\r\n          \u0022\\\\end{bmatrix}\u0022 ]\r\n\r\n    let inline formatVector (vector: Vector\u003C\u0027T\u003E) =\r\n      String.concat Environment.NewLine\r\n        [ \u0022\\\\begin{bmatrix}\u0022\r\n          vector.ToVectorString(12, 80, \u0022\\\\vdots\u0022, \u0022 \u0026 \u0022, \u0022\\\\\\\\ \u0022 \u002B Environment.NewLine,\r\n            (fun x -\u003E formatMathValue \u0022G4\u0022 x))\r\n          \u0022\\\\end{bmatrix}\u0022 ]\r\n\r\n    App.AddDisplayPrinter (fun (x:Matrix\u003Cfloat\u003E) -\u003E\r\n        { ContentType = \u0022text/latex\u0022; Data = formatMatrix x })\r\n    App.AddDisplayPrinter (fun (x:Matrix\u003Cfloat32\u003E) -\u003E\r\n        { ContentType = \u0022text/latex\u0022; Data = formatMatrix x })\r\n    App.AddDisplayPrinter (fun (x:Vector\u003Cfloat\u003E) -\u003E\r\n        { ContentType = \u0022text/latex\u0022; Data = formatVector x })\r\n    App.AddDisplayPrinter (fun (x:Vector\u003Cfloat32\u003E) -\u003E\r\n        { ContentType = \u0022text/latex\u0022; Data = formatVector x })\r\n"},{"uri":"https://numerics.mathdotnet.com/index.html","title":"Math.NET Numerics\r\n","content":"Math.NET Numerics\r\n=================\r\n\r\nMath.NET Numerics aims to provide methods and algorithms for numerical computations\r\nin science, engineering and every day use. Covered topics include special functions,\r\nlinear algebra, probability models, random numbers, interpolation, integration,\r\nregression, optimization problems and more.\r\n\r\nMath.NET Numerics is part of the [Math.NET initiative](https://www.mathdotnet.com/)\r\nand is the result of merging dnAnalytics with Math.NET Iridium, replacing both.\r\nAvailable for free under the [MIT License](License.html).\r\nIt targets Microsoft .NET 5.0, .NET 4.6.1 and higher, and .NET Standard 2.0\r\nand higher. In addition to a purely managed implementation it also supports\r\nnative hardware optimization. See [Platform Support](Compatibility.html) for full details.\r\n\r\nNuGet Packages\r\n--------------\r\n\r\n- [**MathNet.Numerics**](https://www.nuget.org/packages/MathNet.Numerics/) - core package\r\n- [**MathNet.Numerics.FSharp**](https://www.nuget.org/packages/MathNet.Numerics.FSharp/) - optional extensions for a better experience when using F#.\r\n\r\nSee [NuGet \u0026 Binaries](Packages.html) for a complete list of our NuGet packages,\r\nZip files and the release archive.\r\n\r\n    [hide]\r\n    #I \u0022../../out/lib/net40\u0022\r\n    #r \u0022MathNet.Numerics.dll\u0022\r\n    #r \u0022MathNet.Numerics.FSharp.dll\u0022\r\n\r\nUsing Math.NET Numerics with C#\r\n-------------------------------\r\n\r\nBeing written in it, Math.NET Numerics works very well with C# and related .Net languages.\r\nWhen using Visual Studio or another IDE with built-in NuGet support, you can get started\r\nquickly by adding a reference to the \u0060MathNet.Numerics\u0060 NuGet package. Alternatively you can grab\r\nthat package with the command line tool with \u0060nuget.exe install MathNet.Numerics -Pre\u0060\r\nor simply download the Zip package.\r\n\r\nlet\u0027s say we have a matrix $\\mathrm{A}$ and want to find an orthonormal basis of the kernel or null-space\r\nof that matrix, such that $\\mathrm{A}x = 0$ for all $x$ in that subspace.\r\n\r\n    [lang=csharp]\r\n    using MathNet.Numerics.LinearAlgebra;\r\n    using MathNet.Numerics.LinearAlgebra.Double;\r\n\r\n    Matrix\u003Cdouble\u003E A = DenseMatrix.OfArray(new double[,] {\r\n            {1,1,1,1},\r\n            {1,2,3,4},\r\n            {4,3,2,1}});\r\n    Vector\u003Cdouble\u003E[] nullspace = A.Kernel();\r\n\r\n    // verify: the following should be approximately (0,0,0)\r\n    (A * (2*nullspace[0] - 3*nullspace[1]))\r\n\r\n\r\nF# and F# Interactive\r\n---------------------\r\n\r\nEven though the core of Math.NET Numerics is written in C#, it aims to support F#\r\njust as well. In order to achieve this we recommend to reference the \u0060MathNet.Numerics.FSharp\u0060\r\npackage in addition to \u0060MathNet.Numerics\u0060, which adds a few modules to make it more\r\nidiomatic and includes arbitrary precision types (BigInteger, BigRational).\r\n\r\n    [lang=fsharp]\r\n    open MathNet.Numerics.LinearAlgebra\r\n    let m = matrix [[ 1.0; 2.0 ]\r\n                    [ 3.0; 4.0 ]]\r\n    let m\u0027 = m.Inverse()\r\n\r\nIt also works well in the interactive F# environment (REPL) which can be launched with\r\n\u0060fsharpi\u0060 on all platforms (including Linux). As a start let\u0027s enter the following lines\r\ninto F# interactive. Append \u0060;;\u0060 to the end of a line to run all code up to there\r\nimmediately and print the result to the output. Use the tab key for auto-completion or \u0060#help;;\u0060 for help.\r\nFor convenience our F# packages include a small script that sets everything up properly:\r\n\r\n    [lang=fsharp]\r\n    #load \u0022../packages/MathNet.Numerics.FSharp/MathNet.Numerics.fsx\u0022\r\n\r\n    open MathNet.Numerics\r\n    SpecialFunctions.Gamma(0.5)\r\n\r\n    open MathNet.Numerics.LinearAlgebra\r\n    let m : Matrix\u003Cfloat\u003E = DenseMatrix.randomStandard 50 50\r\n    (m * m.Transpose()).Determinant()\r\n\r\n\r\nVisual Basic\r\n------------\r\n\r\nLet\u0027s use Visual Basic to find the polynomial roots $x$ such that $2x^2 - 2x - 2 = 0$\r\nnumerically. We already know there are two roots, one between -2 and 0, the other between 0 and 2:\r\n\r\n    [lang=visualbasic]\r\n    Imports MathNet.Numerics.RootFinding\r\n\r\n    Dim f As Func(Of Double, Double) = Function(x) 2*x^2 - 2*x - 2\r\n\r\n    Bisection.FindRoot(f, 0, 2) \u0027 returns 1.61803398874989\r\n    Bisection.FindRoot(f, -2, 0) \u0027 returns -0.618033988749895\r\n\r\n    \u0027 Alternative to directly compute the roots for this special case:\r\n    FindRoots.Quadratic(-2, -2, 2)\r\n\r\n\r\nLinux with Mono\r\n---------------\r\n\r\nYou need a recent version of Mono in order to use Math.NET Numerics on anything other than Windows.\r\nLuckily there has been great progress lately to make both Mono and F# available as proper Debian packages.\r\nIn Debian *testing* and Ubuntu *14.04 (trusty/universe)* you can install both of them with APT:\r\n\r\n    [lang=sh]\r\n    sudo apt-get update\r\n    sudo apt-get install mono-complete\r\n    sudo apt-get install fsharp\r\n\r\nIf you don\u0027t have NuGet yet:\r\n\r\n    [lang=sh]\r\n    sudo mozroots --import --sync\r\n    curl -L https://nuget.org/nuget.exe -o nuget.exe\r\n\r\nThen you can use NuGet to fetch the latest binaries in your working directory.\r\nThe \u0060-Pre\u0060 argument causes it to include pre-releases, omit it if you want stable releases only.\r\n\r\n    [lang=sh]\r\n    mono nuget.exe install MathNet.Numerics -Pre -OutputDirectory packages\r\n    # or if you intend to use F#:\r\n    mono nuget.exe install MathNet.Numerics.FSharp -Pre -OutputDirectory packages\r\n\r\nIn practice you\u0027d probably use the Monodevelop IDE instead which can take care of fetching and updating\r\nNuGet packages and maintain assembly references. But for completeness let\u0027s use the compiler directly this time.\r\nLet\u0027s create a C# file \u0060Start.cs\u0060:\r\n\r\n    [lang=csharp]\r\n    using System;\r\n    using MathNet.Numerics;\r\n    using MathNet.Numerics.LinearAlgebra;\r\n\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            // Evaluate a special function\r\n            Console.WriteLine(SpecialFunctions.Erf(0.5));\r\n\r\n            // Solve a random linear equation system with 500 unknowns\r\n            var m = Matrix\u003Cdouble\u003E.Build.Random(500, 500);\r\n            var v = Vector\u003Cdouble\u003E.Build.Random(500);\r\n            var y = m.Solve(v);\r\n            Console.WriteLine(y);\r\n        }\r\n    }\r\n\r\nCompile and run:\r\n\r\n    [lang=sh]\r\n    # single line:\r\n    mcs -optimize -lib:packages/MathNet.Numerics.3.0.0-alpha8/lib/net40/\r\n                  -r:MathNet.Numerics.dll Start.cs -out:Start\r\n    # launch:\r\n    mono Start\r\n\r\nWhich will print something like the following to the output:\r\n\r\n    [lang=text]\r\n    0.520499877813047\r\n    DenseVector 500-Double\r\n       -0.181414     -1.25024    -0.607136      1.12975     -3.31201     0.344146\r\n        0.934095     -2.96364      1.84499      1.20752     0.753055      1.56942\r\n        0.472414      6.10418    -0.359401     0.613927    -0.140105       2.6079\r\n        0.163564     -3.04402    -0.350791      2.37228     -1.65218     -0.84056\r\n         1.51311     -2.17326    -0.220243   -0.0368934    -0.970052     0.580543\r\n        0.755483     -1.01755    -0.904162     -1.21824     -2.24888      1.42923\r\n       -0.971345     -3.16723    -0.822723      1.85148     -1.12235    -0.547885\r\n        -2.01044      4.06481    -0.128382      0.51167     -1.70276          ...\r\n\r\nSee [Intel MKL](MKL.html) for details how to use native providers on Linux.\r\n"},{"uri":"https://numerics.mathdotnet.com/IntegralTransforms.html","title":"Fourier and related linear integral transforms\r\n","content":"    [hide]\r\n    #I \u0022../../out/lib/net40\u0022\r\n    #r \u0022MathNet.Numerics.dll\u0022\r\n    #r \u0022MathNet.Numerics.FSharp.dll\u0022\r\n    open System.Numerics\r\n    open MathNet.Numerics\r\n    open MathNet.Numerics.IntegralTransforms\r\n\r\nFourier and related linear integral transforms\r\n==============================================\r\n\r\nMath.NET Numerics currently supports two linear integral transforms: The discrete Fourier\r\ntransform and the discrete Hartley transform. Both are strongly localized in the frequency\r\nspectrum, but while the Fourier transform operates on complex values, the Hartley transform\r\noperates on real values only.\r\n\r\nThe transforms implement a separate forward and inverse transform method.\r\nHow the forward and inverse methods are related to each other and what exact definition\r\nis to be used can be specified by an additional _options_ parameter.\r\n\r\n\r\nFourier Space: Discrete Fourier Transform and FFT\r\n-------------------------------------------------\r\n\r\nWikipedia has an extensive [article on the discrete Fourier transform (DFT)](https://en.wikipedia.org/wiki/Discrete_Fourier_transform).\r\nWe provide implementations of the following algorithms:\r\n\r\n* *Naive Discrete Fourier Transform (DFT):* Out-place transform for arbitrary vector lengths. Mainly intended for verifying faster algorithms: _[NaiveForward](https://numerics.mathdotnet.com/api/MathNet.Numerics.IntegralTransforms/Fourier.htm#NaiveForward)_, _[NaiveInverse](https://numerics.mathdotnet.com/api/MathNet.Numerics.IntegralTransforms/Fourier.htm#NaiveInverse)_\r\n\r\n* *Radix-2 Fast Fourier Transform (FFT):* In-place fast Fourier transform for vectors with a power-of-two length (Radix-2): _[Radix2Forward](https://numerics.mathdotnet.com/api/MathNet.Numerics.IntegralTransforms/Fourier.htm#Radix2Forward)_, _[url:Radix2Inverse](https://numerics.mathdotnet.com/api/MathNet.Numerics.IntegralTransforms/Fourier.htm#Radix2Inverse)_\r\n\r\n* *Bluestein Fast Fourier Transform (FFT):* In-place fast Fourier transform for arbitrary vector lengths: _[BluesteinForward](https://numerics.mathdotnet.com/api/MathNet.Numerics.IntegralTransforms/Fourier.htm#BluesteinForward)_, _[url:BluesteinInverse](https://numerics.mathdotnet.com/api/MathNet.Numerics.IntegralTransforms/Fourier.htm#BluesteinInverse)_\r\n\r\nFurthermore, the _[Transform](https://numerics.mathdotnet.com/api/MathNet.Numerics.IntegralTransforms/Fourier.htm)_ class provides a shortcut for the Bluestein FFT using static methods which are even easier to use: _[FourierForward](https://numerics.mathdotnet.com/api/MathNet.Numerics.IntegralTransforms/Transform.htm#FourierForward)_, _[FourierInverse](https://numerics.mathdotnet.com/api/MathNet.Numerics.IntegralTransforms/Transform.htm#FourierInverse)_.\r\n\r\nCode Sample using the Transform class:\r\n\r\n    [lang=csharp]\r\n    // create a complex sample vector of length 96\r\n    Complex[] samples = SignalGenerator.EquidistantInterval(\r\n         t =\u003E new Complex(1.0 / (t * t \u002B 1.0), t / (t * t \u002B 1.0)),\r\n         -16, 16, 96);\r\n\r\n    // inplace bluestein FFT with default options\r\n    Transform.FourierForward(samples);\r\n\r\nFourier Options:\r\n\r\n* *Default:* Uses a negative exponent sign in forward transformations, and symmetric scaling (that is, sqrt(1/N) for both forward and inverse transformation). This is the convention used in Maple and is widely accepted in the educational sector (due to the symmetry).\r\n* *AsymmetricScaling:* Set this flag to suppress scaling on the forward transformation but scale the inverse transform with 1/N.\r\n* *NoScaling:* Set this flag to suppress scaling for both forward and inverse transformation. Note that in this case if you apply first the forward and then inverse transformation you won\u0027t get back the original signal (by factor N/2).\r\n* *InverseExponent:* Uses the positive instead of the negative sign in the forward exponent, and the negative (instead of positive) exponent in the inverse transformation.\r\n* *Matlab:* Use this flag if you need MATLAB compatibility. Equals to setting the _AsymmetricScaling_ flag. This matches the definition used in the [url:wikipedia article|https://en.wikipedia.org/wiki/Discrete_Fourier_transform].\r\n* *NumericalRecipes:* Use this flag if you need Numerical Recipes compatibility. Equal to setting both the _InverseExponent_ and the _NoScaling_ flags.\r\n\r\nUseful symmetries of the Fourier transform:\r\n\r\n* h(t) is real valued \u003C=\u003E real part of H(f) is even, imaginary part of H(f) is odd\r\n* h(t) is imaginary valued \u003C=\u003E real part of H(f) is odd, imaginary part of H(f) is even\r\n* h(t) is even \u003C=\u003E H(f) is even\r\n* h(t) is odd \u003C=\u003E H(f) is odd\r\n* h(t) is real-valued even \u003C=\u003E H(f) is real-valued even\r\n* h(t) is real-valued odd \u003C=\u003E H(f) is imaginary-valued odd\r\n* h(t) is imaginary-valued even \u003C=\u003E H(f) is imaginary-valued even\r\n* h(t) is imaginary-valued odd \u003C=\u003E H(f) is real-valued odd\r\n\r\n\r\nHartley Space: Discrete Hartley Transform\r\n-----------------------------------------\r\n\r\n...\r\n"},{"uri":"https://numerics.mathdotnet.com/Integration.html","title":"Numerical Integration\r\n","content":"    [hide]\r\n    #I \u0022../../out/lib/net40\u0022\r\n    #r \u0022MathNet.Numerics.dll\u0022\r\n    #r \u0022MathNet.Numerics.FSharp.dll\u0022\r\n    open System.Numerics\r\n    open MathNet.Numerics\r\n    open MathNet.Numerics.Integration\r\n\r\nNumerical Integration\r\n=====================\r\n\r\nThe following double precision numerical integration or quadrature rules are supported in Math.NET Numerics under the \u0060MathNet.Numerics.Integration\u0060 namespace. Unless stated otherwise, the examples below evaluate the integral $\\int_0^{10} x^2 \\, dx = \\frac{1000}{3} \\approx 333.\\overline{3}$.\r\n\r\nSimpson\u0027s Rule\r\n--------------\r\n\r\n    [lang=csharp]\r\n    // Composite approximation with 4 partitions\r\n    double composite = SimpsonRule.IntegrateComposite(x =\u003E x * x, 0.0, 10.0, 4);\r\n\r\n    // Approximate value using IntegrateComposite with 4 partitions is: 333.33333333333337\r\n    Console.WriteLine(\u0022Approximate value using IntegrateComposite with 4 partitions is: \u0022 \u002B composite);\r\n\r\n    // Three point approximation\r\n    double threePoint = SimpsonRule.IntegrateThreePoint(x =\u003E x * x, 0.0, 10.0);\r\n\r\n    // Approximate value using IntegrateThreePoint is: 333.333333333333\r\n    Console.WriteLine(\u0022Approximate value using IntegrateThreePoint is: \u0022 \u002B threePoint);\r\n\r\nNewton Cotes Trapezium Rule\r\n---------------------------\r\n\r\n    [lang=csharp]\r\n    // Adaptive approximation with a relative error of 1e-5\r\n    double adaptive = NewtonCotesTrapeziumRule.IntegrateAdaptive(x =\u003E x * x, 0.0, 10.0, 1e-5);\r\n\r\n    // Approximate value of the integral using IntegrateAdaptive with a relative error of 1e-5 is: 333.333969116211\r\n    Console.WriteLine(\u0022Approximate value using IntegrateAdaptive with a relative error of 1e-5: \u0022 \u002B adaptive);\r\n\r\n    // Composite approximation with 15 partitions\r\n    double composite = NewtonCotesTrapeziumRule.IntegrateComposite(x =\u003E x * x, 0.0, 10.0, 15);\r\n\r\n    //Approximate value of the integral using IntegrateComposite with 15 partitions is: 334.074074074074\r\n    Console.WriteLine(\u0022Approximate value using IntegrateComposite with 15 partitions is: \u0022 \u002B composite);\r\n\r\n    // Two point approximation\r\n    double twoPoint = NewtonCotesTrapeziumRule.IntegrateTwoPoint(x =\u003E x * x, 0.0, 10.0);\r\n\r\n    //Approximate value using IntegrateTwoPoint is: 500\r\n    Console.WriteLine(\u0022Approximate value using IntegrateTwoPoint is: \u0022 \u002B twoPoint);\r\n\r\nDouble-Exponential Transformation\r\n---------------------------------\r\nThe Double-Exponential Transformation is suited for integration of smooth functions with no discontinuities, derivative discontinuities, and poles inside the interval.\r\n\r\n    [lang=csharp]\r\n    // Approximate using a relative error of 1e-5.\r\n    double integrate = DoubleExponentialTransformation.Integrate(x =\u003E x * x, 0.0, 10.0, 1e-5);\r\n\r\n    // Approximate value using a relative error of 1e-5 is: 333.333333333332\r\n    Console.WriteLine(\u0022Approximate value using a relative error of 1e-5 is: \u0022 \u002B integrate);\r\n\r\nGauss-Legendre Rule\r\n-------------------\r\nA fixed-order Gauss-Legendre integration routine is provided for fast integration of smooth functions with known polynomial order. The N-point Gauss-Legendre rule is exact for polynomials of order $2N-1$ or less. For example, these rules are useful when integrating basis functions to form mass matrices for the Galerkin method [[GSL]](https://www.gnu.org/software/gsl/).\r\n\r\nThe basic idea of Gauss-Legendre integration is to approximate the integral of a function $f(x)$ using $N$ Weights $w_i$ and abscissas (or nodes) $x_i$.\r\n\r\n$$$\r\n\\int_a^b f(x) \\, dx \\approx \\sum_{i = 0}^{N - 1} w_i f(x_i)\r\n\r\nThis algorithm calculates the abscissas and weights for a given order and integration interval. For efficiency, pre-computed abscissas and weights for the orders $ N = 2 - 20, \\, 32, \\, 64, \\, 96, 100, \\, 128, \\, 256, \\, 512, \\, 1024$ are used. Otherwise, they are calculated on the fly using Newton\u0027s method. For more information on the algorithm see [[Holoborodko, Pavel] ](https://www.holoborodko.com/pavel/numerical-methods/numerical-integration/).\r\n\r\n### Abscissas and Weights\r\n\r\nWe\u0027ll first use the abscissas and weights to approximate an integral using a 5-point Gauss-Legendre rule\r\n\r\n    [lang=csharp]\r\n    // Create a 5-point Gauss-Legendre rule over the integration interval [0, 10]\r\n    GaussLegendreRule rule = new GaussLegendreRule(0.0, 10.0, 5);\r\n\r\n    double sum = 0; // Will hold the approximate value of the integral\r\n    for (int i = 0; i \u003C rule.Order; i\u002B\u002B) // rule.Order = 5\r\n    {\r\n        // Access the ith abscissa and weight\r\n        sum \u002B= rule.GetWeight(i) * rule.GetAbscissa(i) * rule.GetAbscissa(i);\r\n    }\r\n\r\n    // Approximate value is: 333.333333333333\r\n    Console.WriteLine(\u0022Approximate value is: \u0022 \u002B sum);\r\n\r\nIf you prefer direct access to the abscissas and weights, as opposed to using the methods\r\n\r\n- \u0060\u0060\u0060double GetAbscissa(int i)\u0060\u0060\u0060\r\n- \u0060\u0060\u0060double GetWeight(int i)\u0060\u0060\u0060\r\n\r\nthen use the properties \u0060Abscissas\u0060 and \u0060Weights\u0060\r\n\r\n    [lang=csharp]\r\n    // Create a 5-point Gauss-Legendre rule over the integration interval [0, 10]\r\n    GaussLegendreRule rule = new GaussLegendreRule(0.0, 10.0, 5);\r\n\r\n    double[] x = rule.Abscissas; // Creates a clone and returns array of abscissas\r\n    double[] w = rule.Weights; // Creates a clone and returns array of weights\r\n\r\n    double sum = 0; // Will hold the approximate value of the integral\r\n    for (int i = 0; i \u003C rule.Order; i\u002B\u002B) // rule.Order = 5\r\n    {\r\n        // Access the ith abscissa and weight\r\n        sum \u002B= w[i] * x[i] * x[i];\r\n    }\r\n\r\n    // Approximate value is: 333.333333333333\r\n    Console.WriteLine(\u0022Approximate value is: \u0022 \u002B sum);;\r\n\r\nIn addition to obtaining the abscissas and weights, the order and integration interval can be obtained\r\n\r\n    [lang=csharp]\r\n    // Create a 5-point Gauss-Legendre rule over the integration interval [0, 10]\r\n    GaussLegendreRule rule = new GaussLegendreRule(0.0, 10.0, 5);\r\n\r\n    // The order of the rule is: 5\r\n    Console.WriteLine(\u0022The order of the rule is: \u0022 \u002B rule.Order);\r\n\r\n    // The lower integral bound is 0\r\n    Console.WriteLine(\u0022The lower integral bound is: \u0022 \u002B rule.IntervalBegin);\r\n\r\n    // The upper integral bound is 10\r\n    Console.WriteLine(\u0022The upper integral bound is: \u0022 \u002B rule.IntervalEnd);\r\n\r\n### Integrate Method\r\n\r\nFor convenience, we provide an overloaded static method \u0060double Integrate(...)\u0060 which preforms 1D and 2D integration of a function. The first parameter to the method is a delegate of type \u0060Func\u003Cdouble, double\u003E\u0060 or \u0060Func\u003Cdouble, double, double\u003E\u0060 for 1D and 2D integration respectively. So for example\r\n\r\n    [lang=csharp]\r\n    // 1D integration using a 5-point Gauss-Legendre rule over the integration interval [0, 10]\r\n    double integrate1D = GaussLegendreRule.Integrate(x =\u003E x * x, 0.0, 10.0, 5);\r\n\r\n    // Approximate value of the 1D integral is: 333.333333333333\r\n    Console.WriteLine(\u0022Approximate value of the 1D integral is: \u0022 \u002B integrate1D);\r\n\r\n    // 2D integration using a 5-point Gauss-Legendre rule over the integration interval [0, 10] X [1, 2]\r\n    double integrate2D = GaussLegendreRule.Integrate((x, y) =\u003E (x * x) * (y * y), 0.0, 10.0, 1.0, 2.0, 5);\r\n\r\n    // Approximate value of the 2D integral is: 777.777777777778\r\n    Console.WriteLine(\u0022Approximate value of the 2D integral is: \u0022 \u002B integrate2D);\r\n\r\nwhere we used $\\int_0^{10}\\int_1^2 x^2 y^2 \\,dydx = \\frac{7000}{9} \\approx 777.\\overline{7}$ for the 2D integral example.\r\n"},{"uri":"https://numerics.mathdotnet.com/Interpolation.html","title":"Interpolation\r\n","content":"    [hide]\r\n    #I \u0022../../out/lib/net40\u0022\r\n    #r \u0022MathNet.Numerics.dll\u0022\r\n    #r \u0022MathNet.Numerics.FSharp.dll\u0022\r\n    open System.Numerics\r\n    open MathNet.Numerics\r\n    open MathNet.Numerics.Interpolation\r\n\r\nInterpolation\r\n=============\r\n\r\nNamespace: MathNet.Numerics.Interpolation\r\n\r\nInterpolation is a two-phased operation in Math.NET Numerics:\r\n\r\n1. Create an interpolation scheme for the chosen algorithm and optimized for the given sample points. You get back a class that implements the _IInterpolation_ interface.\r\n2. Use this scheme to compute values at arbitrary points. Some interpolation algorithms also allow you to compute the derivative and the indefinite integral at that point.\r\n\r\nThe static \u0060Interpolate\u0060 class provides simple factory methods to create the interpolation scheme in a simple method call:\r\n\r\n* _RationalWithoutPoles_, creates a Floater-Hormann barycentric interpolation\r\n* _RationalWithPoles_, creates a Bulirsch \u0026 Stoer rational interpolation\r\n* _LinearBetweenPoints_, creates a linear spline interpolation\r\n\r\nIf unsure, we recommend using _RationalWithoutPoles_ for most cases.\r\n\r\nAlternatively you can also use the algorithms directly, they\u0027re publicly available in the _Algorithms_ sub-namespace for those who want to use a specific algorithm. The following algorithms are available:\r\n\r\n\r\nInterpolation on equidistant sample points\r\n------------------------------------------\r\n\r\n* *Polynomial*: Barycentric Algorithm\r\n\r\n\r\nInterpolation on arbitrary sample points\r\n----------------------------------------\r\n\r\n* *Rational pole-free*: Barycentric Floater-Hormann Algorithm\r\n* *Rational with poles*: Bulirsch \u0026 Stoer Algorithm\r\n* *Neville Polynomial*: Neville Algorithm. Note that the Neville algorithm performs very badly on equidistant points. If you need to interpolate a polynomial on equidistant points, we recommend to use the barycentric algorithm instead.\r\n* *Linear Spline*\r\n* *Cubic Spline* with boundary conditions\r\n* *Natural Cubic Spline*\r\n* *Akima Cubic Spline*\r\n* *Monotone Cubic Spline*: Monotone-preserving piecewise cubic Hermite interpolating polynomial (PCHIP), based on Fritsch \u0026 Carlson (1980).\r\n\r\n\r\nInterpolation with additional data\r\n----------------------------------\r\n\r\n* *Generic Barycentric Interpolation*, requires barycentric weights\r\n* *Generic Spline*, requires spline coefficients\r\n* *Generic Cubic Hermite Spline*, requires the derivatives\r\n"},{"uri":"https://numerics.mathdotnet.com/License-MKL.html","title":"License-MKL","content":"Intel Simplified Software License (Version August 2021)\r\n\r\nUse and Redistribution. You may use and redistribute the software (the \u0022Software\u0022), without modification, provided the following conditions are met:\r\n\r\n* Redistributions must reproduce the above copyright notice and the following terms of use in the Software and in the documentation and/or other materials provided with the distribution.\r\n* Neither the name of Intel nor the names of its suppliers may be used to endorse or promote products derived from this Software without specific prior written permission.\r\n* No reverse engineering, decompilation, or disassembly of this Software is permitted.\r\n\r\nNo other licenses. Except as provided in the preceding section, Intel grants no licenses or other rights by implication, estoppel or otherwise to, patent, copyright, trademark, trade name, service mark or other intellectual property licenses or rights of Intel.\r\n\r\nThird party software. The Software may contain Third Party Software. \u0022Third Party Software\u0022 is open source software, third party software, or other Intel software that may be identified in the Software itself or in the files (if any) listed in the \u0022third-party-software.txt\u0022 or similarly named text file included with the Software. Third Party Software, even if included with the distribution of the Software, may be governed by separate license terms, including without limitation, open source software license terms, third party software license terms, and other Intel software license terms. Those separate license terms solely govern your use of the Third Party Software, and nothing in this license limits any rights under, or grants rights that supersede, the terms of the applicable license terms.\r\n\r\nDISCLAIMER. THIS SOFTWARE IS PROVIDED \u0022AS IS\u0022 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT ARE DISCLAIMED. THIS SOFTWARE IS NOT INTENDED FOR USE IN SYSTEMS OR APPLICATIONS WHERE FAILURE OF THE SOFTWARE MAY CAUSE PERSONAL INJURY OR DEATH AND YOU AGREE THAT YOU ARE FULLY RESPONSIBLE FOR ANY CLAIMS, COSTS, DAMAGES, EXPENSES, AND ATTORNEYS  FEES ARISING OUT OF ANY SUCH USE, EVEN IF ANY CLAIM ALLEGES THAT INTEL WAS NEGLIGENT REGARDING THE DESIGN OR MANUFACTURE OF THE SOFTWARE.\r\n\r\nLIMITATION OF LIABILITY. IN NO EVENT WILL INTEL BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\nNo support. Intel may make changes to the Software, at any time without notice, and is not obligated to support, update or provide training for the Software.\r\n\r\nTermination. Your right to use the Software is terminated in the event of your breach of this license.\r\n\r\nFeedback. Should you provide Intel with comments, modifications, corrections, enhancements or other input (\u0022Feedback\u0022) related to the Software, Intel will be free to use, disclose, reproduce, license or otherwise distribute or exploit the Feedback in its sole discretion without any obligations or restrictions of any kind, including without limitation, intellectual property rights or licensing obligations.\r\n\r\nCompliance with laws. You agree to comply with all relevant laws and regulations governing your use, transfer, import or export (or prohibition thereof) of the Software.\r\n\r\nGoverning law. All disputes will be governed by the laws of the United States of America and the State of Delaware without reference to conflict of law principles and subject to the exclusive jurisdiction of the state or federal courts sitting in the State of Delaware, and each party agrees that it submits to the personal jurisdiction and venue of those courts and waives any objections. The United Nations Convention on Contracts for the International Sale of Goods (1980) is specifically excluded and will not apply to the Software.\r\n"},{"uri":"https://numerics.mathdotnet.com/License.html","title":"License","content":"Copyright (c) 2002-2022 Math.NET\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n\u0022Software\u0022), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be\r\nincluded in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \u0022AS IS\u0022, WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n"},{"uri":"https://numerics.mathdotnet.com/LinearEquations.html","title":"Linear Equation Systems\r\n","content":"    [hide]\r\n    #I \u0022../../out/lib/net40\u0022\r\n    #r \u0022MathNet.Numerics.dll\u0022\r\n    #r \u0022MathNet.Numerics.FSharp.dll\u0022\r\n    open System.Numerics\r\n    open MathNet.Numerics\r\n    open MathNet.Numerics.LinearAlgebra\r\n\r\nLinear Equation Systems\r\n=======================\r\n\r\nA system of linear equations is a collection of linear equations involving the same set of variables:\r\n\r\n$$$\r\n\\begin{alignat}{7}\r\n3x \u0026\\; \u002B \\;\u0026 2y             \u0026\\; - \\;\u0026 z  \u0026\\; = \\;\u0026 1 \u0026 \\\\\r\n2x \u0026\\; - \\;\u0026 2y             \u0026\\; \u002B \\;\u0026 4z \u0026\\; = \\;\u0026 -2 \u0026 \\\\\r\n-x \u0026\\; \u002B \\;\u0026 \\tfrac{1}{2} y \u0026\\; - \\;\u0026 z  \u0026\\; = \\;\u0026 0 \u0026\r\n\\end{alignat}\r\n\r\nMore generally, we can write\r\n\r\n$$$\r\n\\begin{alignat}{7}\r\na_{11} x_1 \u0026\u0026\\; \u002B \\;\u0026\u0026 a_{12} x_2   \u0026\u0026\\; \u002B \\cdots \u002B \\;\u0026\u0026 a_{1n} x_n \u0026\u0026\\; = \\;\u0026\u0026\u0026 b_1 \\\\\r\na_{21} x_1 \u0026\u0026\\; \u002B \\;\u0026\u0026 a_{22} x_2   \u0026\u0026\\; \u002B \\cdots \u002B \\;\u0026\u0026 a_{2n} x_n \u0026\u0026\\; = \\;\u0026\u0026\u0026 b_2 \\\\\r\n\\vdots\\;\\;\\; \u0026\u0026     \u0026\u0026 \\vdots\\;\\;\\; \u0026\u0026                \u0026\u0026 \\vdots\\;\\;\\; \u0026\u0026     \u0026\u0026\u0026 \\;\\vdots \\\\\r\na_{m1} x_1 \u0026\u0026\\; \u002B \\;\u0026\u0026 a_{m2} x_2   \u0026\u0026\\; \u002B \\cdots \u002B \\;\u0026\u0026 a_{mn} x_n \u0026\u0026\\; = \\;\u0026\u0026\u0026 b_m \\\\\r\n\\end{alignat}\r\n\r\nwhere we all parameters $a_{ij}$ and $b_i$ are known and we would like to find $x_j$ that satisfy\r\nall these equations. If we have the same number $n$ of unknown variables $x_j$ as number of\r\nequations $m$, and all these equations are independent, then there is a unique solution.\r\n\r\nThis is a fundamental problem in the domain of linear algebra, and we can use its power to find the solution.\r\nAccordingly we can write the equivalent problem with matrices and vectors:\r\n\r\n$$$\r\n\\mathbf{A}=\r\n\\begin{bmatrix}\r\na_{11} \u0026 a_{12} \u0026 \\cdots \u0026 a_{1n} \\\\\r\na_{21} \u0026 a_{22} \u0026 \\cdots \u0026 a_{2n} \\\\\r\n\\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\\r\na_{m1} \u0026 a_{m2} \u0026 \\cdots \u0026 a_{mn}\r\n\\end{bmatrix},\\quad\r\n\\mathbf{x}=\\begin{bmatrix}x_1\\\\x_2\\\\ \\vdots \\\\x_n\\end{bmatrix},\\quad\r\n\\mathbf{b}=\\begin{bmatrix}b_1\\\\b_2\\\\ \\vdots \\\\b_m\\end{bmatrix}\r\n\r\nsuch that\r\n\r\n$$$\r\n\\mathbf{A}\\mathbf{x}=\\mathbf{b}\r\n\r\nThe initial example system would then look like this:\r\n\r\n$$$\r\n\\begin{bmatrix}3 \u0026 2 \u0026 -1 \\\\2 \u0026 -2 \u0026 4 \\\\-1 \u0026 \\tfrac{1}{2} \u0026 -1\\end{bmatrix}\r\n\\begin{bmatrix}x\\\\y\\\\z\\end{bmatrix}\r\n\\;=\\;\r\n\\begin{bmatrix}1\\\\-2\\\\0\\end{bmatrix}\r\n\r\nWhich we can solve explicitly with the LU-decomposition, or simply by using the Solve method:\r\n\r\n    [lang=csharp]\r\n    var A = Matrix\u003Cdouble\u003E.Build.DenseOfArray(new double[,] {\r\n        { 3, 2, -1 },\r\n        { 2, -2, 4 },\r\n        { -1, 0.5, -1 }\r\n    });\r\n    var b = Vector\u003Cdouble\u003E.Build.Dense(new double[] { 1, -2, 0 });\r\n    var x = A.Solve(b);\r\n\r\nThe resulting $\\mathbf{x}$ is $[1,\\;-2,\\;-2]$, hence the solution $x=1,\\;y=-2,\\;z=-2$.\r\n\r\nIn F# the syntax is a bit lighter:\r\n\r\n    [lang=fsharp]\r\n    let A = matrix [[ 3.0; 2.0; -1.0 ]\r\n                    [ 2.0; -2.0; 4.0 ]\r\n                    [ -1.0; 0.5; -1.0 ]]\r\n    let b = vector [ 1.0; -2.0; 0.0 ]\r\n    let x = A.Solve(b) // 1;-2;-2\r\n\r\n\r\nNormalizing Equation Systems\r\n----------------------------\r\n\r\nIn practice, a linear equation system to be solved is often not in the standard form required\r\nto use the linear algebra approach. For example, let\u0027s have a look at the following system:\r\n\r\n$$$\r\n\\begin{bmatrix}1 \u0026 2 \u0026 3 \u0026 4\\\\2 \u0026 3 \u0026 4 \u0026 5\\\\3 \u0026 4 \u0026 5 \u0026 6\\\\4 \u0026 5 \u0026 6 \u0026 7\\end{bmatrix}\r\n\\begin{bmatrix}0\\\\0\\\\V\\\\T\\end{bmatrix}\r\n\\;=\\;\r\n\\begin{bmatrix}F\\\\M\\\\20\\\\0\\end{bmatrix}\r\n\r\nThe first two values of the solution vector $[0,\\;0,\\;V,\\;T]$ are constant zero, so we can simplify\r\nthe system to:\r\n\r\n$$$\r\n\\begin{bmatrix}3 \u0026 4\\\\4 \u0026 5\\\\5 \u0026 6\\\\6 \u0026 7\\end{bmatrix}\r\n\\begin{bmatrix}V\\\\T\\end{bmatrix}\r\n\\;=\\;\r\n\\begin{bmatrix}F\\\\M\\\\20\\\\0\\end{bmatrix}\r\n\r\nThen we need to subtract the two unknowns from the right side back from the left (so that they\r\nbecome zero on the right side), by introducing a new column each. First we subtract\r\n$[F,\\;0,\\;0,\\;0]^T$ from both sides:\r\n\r\n$$$\r\n\\begin{bmatrix}3 \u0026 4 \u0026 -1\\\\4 \u0026 5 \u0026 0\\\\5 \u0026 6 \u0026 0\\\\6 \u0026 7 \u0026 0\\end{bmatrix}\r\n\\begin{bmatrix}V\\\\T\\\\F\\end{bmatrix}\r\n\\;=\\;\r\n\\begin{bmatrix}0\\\\M\\\\20\\\\0\\end{bmatrix}\r\n\r\nThen we subtract $[0,\\;M,\\;0,\\;0]^T$ from both sides the same way:\r\n\r\n$$$\r\n\\begin{bmatrix}3 \u0026 4 \u0026 -1 \u0026 0\\\\4 \u0026 5 \u0026 0 \u0026 -1\\\\5 \u0026 6 \u0026 0 \u0026 0\\\\6 \u0026 7 \u0026 0 \u0026 0\\end{bmatrix}\r\n\\begin{bmatrix}V\\\\T\\\\F\\\\M\\end{bmatrix}\r\n\\;=\\;\r\n\\begin{bmatrix}0\\\\0\\\\20\\\\0\\end{bmatrix}\r\n\r\nWhich is in standard from, so we can solve normally:\r\n\r\n    [lang=fsharp]\r\n    let A\u0027 = matrix [[ 3.0; 4.0; -1.0; 0.0 ]\r\n                     [ 4.0; 5.0; 0.0; -1.0 ]\r\n                     [ 5.0; 6.0; 0.0; 0.0; ]\r\n                     [ 6.0; 7.0; 0.0; 0.0 ]]\r\n    let b\u0027 = vector [ 0.0; 0.0; 20.0; 0.0 ]\r\n    let x\u0027 = A\u0027.Solve(b\u0027) // -140; 120; 60; 40\r\n"},{"uri":"https://numerics.mathdotnet.com/MatlabFiles.html","title":"MATLAB Level-5 Mat Files\r\n","content":"MATLAB Level-5 Mat Files\r\n========================\r\n\r\nLevel-5 MATLAB Mat files are popular as binary file container for storing one or more matrices.\r\nMath.NET Numerics provides basic support for such Mat files with the **MathNet.Numerics.Data.Matlab** package,\r\nwhich is available on NuGet as separate package and not included in the basic distribution.\r\n\r\n\r\nReading matrices from a MATLAB file\r\n-----------------------------------\r\n\r\nThe \u0060MatlabReader\u0060 class provides static functions to list all matrices stored in a MAT file or stream,\r\nand to read them individually as Math.NET matrices:\r\n\r\n    [lang=csharp]\r\n    using MathNet.Numerics.LinearAlgebra;\r\n    using MathNet.Numerics.Data.Matlab;\r\n\r\n    // read the first matrix as double\r\n    Matrix\u003Cdouble\u003E m = MatlabReader.Read\u003Cdouble\u003E(\u0022collection.mat\u0022);\r\n\r\n    // read a specific matrix named \u0022vd\u0022:\r\n    Matrix\u003Cdouble\u003E m = MatlabReader.Read\u003Cdouble\u003E(\u0022collection.mat\u0022, \u0022vd\u0022);\r\n\r\n    // we can also choose to convert to a different type:\r\n    Matrix\u003CComplex\u003E m = MatlabReader.Read\u003CComplex\u003E(\u0022collection.mat\u0022);\r\n\r\n    // read all matrices of a file by name into a dictionary\r\n    Dictionary\u003Cstring,Matrix\u003Cdouble\u003E\u003E ms =\r\n        MatlabReader.ReadAll\u003Cdouble\u003E(\u0022collection.mat\u0022);\r\n\r\n    // read the matrices named \u0022Ad\u0022 and \u0022vd\u0022 into a dictionary\r\n    var ms = MatlabReader.ReadAll\u003Cdouble\u003E(\u0022collection.mat\u0022, \u0022vd\u0022, \u0022Ad\u0022);\r\n\r\nAlternatively the reader can list all matrices of a file into named data elements,\r\nwhich can then be read into matrices individually. This is useful e.g. if we need to\r\nread some of the matrices to a different type:\r\n\r\n    [lang=csharp]\r\n    List\u003CMatlabMatrix\u003E ms = MatlabReader.List(\u0022collection.mat\u0022);\r\n    Matrix\u003Cdouble\u003E Ad = MatlabReader.Unpack\u003Cdouble\u003E(ms.Find(m =\u003E m.Name == \u0022Ad\u0022));\r\n    Matrix\u003Cfloat\u003E vd = MatlabReader.Unpack\u003Cfloat\u003E(ms.Find(m =\u003E m.Name == \u0022vd\u0022));\r\n\r\n\r\nWriting matrices to a MATLAB file\r\n---------------------------------\r\n\r\nThe dual to the reader above is the \u0060MatlabWriter\u0060 class that can serialize matrices\r\nto a MATLAB file or stream. Like the reader, the writer can use \u0060MatlabMatrix\u0060 data elements\r\nto compose packed matrices into a file. Each matrix has a name which must not contain spaces.\r\n\r\n    [lang=csharp]\r\n    var matrices = new List\u003CMatlabMatrix\u003E();\r\n    m.Add(MatlabWriter.Pack(myFirstMatrix, \u0022m1\u0022);\r\n    m.Add(MatlabWriter.Pack(mySecondMatrix, \u0022m2\u0022);\r\n    MatlabWrier.Store(\u0022file.mat\u0022, matrices);\r\n\r\nBut there are also direct routines if only a single matrix or matrices of all the same data type\r\nare to be stored in a file:\r\n\r\n    [lang=csharp]\r\n    // write a single matrix \u0022myMatrix\u0022 and name it \u0022m1\u0022.\r\n    MatlabWriter.Write(\u0022file.mat\u0022, myMatrix, \u0022m1\u0022);\r\n\r\n    // write multiple matrices, from a list of matrices and a list of their names:\r\n    MatlabWriter.Write(\u0022file.mat\u0022, new[] { m1, m2 }, new[] { \u0022m1\u0022, \u0022m2\u0022 });\r\n\r\n    // write a dictionary of matrices:\r\n    var dict = new Dictionary\u003Cstring, Matrix\u003Cdouble\u003E\u003E();\r\n    dict.Add(\u0022m1\u0022, m1);\r\n    dict.Add(\u0022m2\u0022, m2);\r\n    MatlabWriter.Write(\u0022file.mat\u0022, dict);\r\n\r\n\r\nAlternatives\r\n------------\r\n\r\nThe data extension packages also offer other ways to serialize a matrix to a text file.\r\nAmong others:\r\n\r\n* [Delimited Text Files (CSV \u0026 TSV)](CSV.html)\r\n* [NIST MatrixMarket text files](MatrixMarket.html)\r\n"},{"uri":"https://numerics.mathdotnet.com/Matrix.html","title":"Matrices and Vectors\r\n","content":"    [hide]\r\n    #I \u0022../../out/lib/net40\u0022\r\n    #r \u0022MathNet.Numerics.dll\u0022\r\n    #r \u0022MathNet.Numerics.FSharp.dll\u0022\r\n    open System.Numerics\r\n    open MathNet.Numerics\r\n    open MathNet.Numerics.LinearAlgebra\r\n    open MathNet.Numerics.Distributions\r\n\r\nMatrices and Vectors\r\n====================\r\n\r\nMath.NET Numerics includes rich types for matrices and vectors.\r\nThey support both single and double precision, real and complex floating point numbers.\r\n\r\n$$$\r\n\\mathbf{A}=\r\n\\begin{bmatrix}\r\na_{0,0} \u0026 a_{0,1} \u0026 \\cdots \u0026 a_{0,(n-1)} \\\\\r\na_{1,0} \u0026 a_{1,1} \u0026 \\cdots \u0026 a_{1,(n-1)} \\\\\r\n\\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\\r\na_{(m-1),0} \u0026 a_{(m-1),1} \u0026 \\cdots \u0026 a_{(m-1),(n-1)}\r\n\\end{bmatrix},\\quad\r\n\\mathbf{v}=\\begin{bmatrix}v_0\\\\v_1\\\\ \\vdots \\\\v_{n-1}\\end{bmatrix}\r\n\r\nLike all data structures in .Net they are 0-indexed, i.e. the top left cell has index (0,0). In matrices,\r\nthe first index always refers to the row and the second index to the column.\r\nEmpty matrices or vectors are not supported, i.e. each dimension must have a length of at least 1.\r\n\r\n### Context: Linear Algebra\r\n\r\nThe context and primary scenario for these types is linear algebra. Their API is broad enough\r\nto use them in other contexts as well, but they are *not* optimized for geometry or\r\nas general purpose storage structure as common in MATLAB. This is intentional, as\r\nspatial problems, geography and geometry have quite different usage patterns and requirements\r\nto linear algebra. All places where Math.NET Numerics can be used have a strong\r\nprogramming language with their own data structures. For example, if you have a collection of vectors,\r\nconsider to store them in a list or array of vectors, not in a matrix (unless you need matrix operations, of course).\r\n\r\nStorage Layout\r\n--------------\r\n\r\nBoth dense and sparse vectors are supported:\r\n\r\n* **Dense Vector** uses a single array of the same length as the vector.\r\n* **Sparse Vector** uses two arrays which are usually much shorter than the vector.\r\n  One array stores all values that are not zero, the other stores their indices.\r\n  They are sorted ascendingly by index.\r\n\r\nMatrices can be either dense, diagonal or sparse:\r\n\r\n* **Dense Matrix** uses a single array in column-major order.\r\n* **Diagonal Matrix** stores only the diagonal values, in a single array.\r\n* **Sparse Matrix** stores non-zero values in 3 arrays in the standard compressed sparse row (CSR) format.\r\n  One array stores all values that are not zero, another array of the same length stores\r\n  the their corresponding column index. The third array of the length of the number of rows plus one,\r\n  stores the offsets where each row starts, and the total number of non-zero values in the last field.\r\n\r\nIf your data  contains only very few zeros, using the sparse variant is orders of magnitudes\r\nslower than their dense counterparts, so consider to use dense types unless the data is very sparse (i.e. almost all zeros).\r\n\r\nCreating Matrices and Vectors\r\n-----------------------------\r\n\r\nThe \u0060Matrix\u003CT\u003E\u0060 and \u0060Vector\u003CT\u003E\u0060 types are defined in the \u0060MathNet.Numerics.LinearAlgebra\u0060 namespace.\r\n\r\nFor technical and performance reasons there are distinct implementations for each data type.\r\nFor example, for double precision numbers there is a \u0060DenseMatrix\u0060 class in the \u0060MathNet.Numerics.LinearAlgebra.Double\u0060\r\nnamespace. You do not normally need to be aware of that, but as consequence the generic \u0060Matrix\u003CT\u003E\u0060 type is abstract\r\nand we need other ways to create a matrix or vector instance.\r\n\r\nThe matrix and vector builder provide functions to create instances from a variety of formats or approaches.\r\n\r\n    [lang=csharp]\r\n    // create a dense matrix with 3 rows and 4 columns\r\n    // filled with random numbers sampled from the standard distribution\r\n    Matrix\u003Cdouble\u003E m = Matrix\u003Cdouble\u003E.Build.Random(3, 4);\r\n\r\n    // create a dense zero-vector of length 10\r\n    Vector\u003Cdouble\u003E v = Vector\u003Cdouble\u003E.Build.Dense(10);\r\n\r\nSince within an application you often only work with one specific data type, a common trick to keep this a bit shorter\r\nis to define shortcuts to the builders:\r\n\r\n    [lang=csharp]\r\n    var M = Matrix\u003Cdouble\u003E.Build;\r\n    var V = Vector\u003Cdouble\u003E.Build;\r\n\r\n    // build the same as above\r\n    var m = M.Random(3, 4);\r\n    var v = V.Dense(10);\r\n\r\nThe builder functions usually start with the layout (Dense, Sparse, Diagonal),\r\nso if we\u0027d like to build a sparse matrix, intellisense will list all available options\r\ntogether once you type \u0060M.Sparse\u0060.\r\n\r\nThere are variants to generate synthetic matrices, for example:\r\n\r\n    [lang=csharp]\r\n    // 3x4 dense matrix filled with zeros\r\n    M.Dense(3, 4);\r\n\r\n    // 3x4 dense matrix filled with 1.0.\r\n    M.Dense(3, 4, 1.0);\r\n\r\n    // 3x4 dense matrix where each field is initialized using a function\r\n    M.Dense(3, 4, (i,j) =\u003E 100*i \u002B j);\r\n\r\n    // 3x4 square dense matrix with each diagonal value set to 2.0\r\n    M.DenseDiagonal(3, 4, 2.0);\r\n\r\n    // 3x3 dense identity matrix\r\n    M.DenseIdentity(3);\r\n\r\n    // 3x4 dense random matrix sampled from a Gamma distribution\r\n    M.Random(3, 4, new Gamma(1.0, 5.0));\r\n\r\n\r\nBut often we already have data available in some format and\r\nneed a matrix representing the same data. Whenever a function contains\r\n\u0022Of\u0022 in its name it does create a copy of the original data.\r\n\r\n    [lang=csharp]\r\n    // Copy of an existing matrix (can also be sparse or diagonal)\r\n    Matrix\u003Cdouble\u003E x = ...\r\n    M.DenseOfMatrix(x);\r\n\r\n    // Directly bind to an existing column-major array without copying (note: no \u0022Of\u0022)\r\n    double[] x = existing...\r\n    M.Dense(3, 4, x);\r\n\r\n    // From a 2D-array\r\n    double[,] x = {{ 1.0, 2.0 },\r\n                   { 3.0, 4.0 }};\r\n    M.DenseOfArray(x);\r\n\r\n    // From an enumerable of values and their coordinates\r\n    Tuple\u003Cint,int,double\u003E[] x = {Tuple.Create(0,0,2.0), Tuple.Create(0,1,-3.0)};\r\n    M.DenseOfIndexed(3,4,x);\r\n\r\n    // From an enumerable in column major order (column by column)\r\n    double[] x = {1.0, 2.0, 3.0, 4.0};\r\n    M.DenseOfColumnMajor(2, 2, x);\r\n\r\n    // From an enumerable of enumerable-columns (optional with explicit size)\r\n    IEnumerable\u003CIEnumerable\u003Cdouble\u003E\u003E x = ...\r\n    M.DenseOfColumns(x);\r\n\r\n    // From a params-array of array-columns (or an enumerable of them)\r\n    M.DenseOfColumnArrays(new[] {2.0, 3.0}, new[] {4.0, 5.0});\r\n\r\n    // From a params-array of column vectors (or an enumerable of them)\r\n    M.DenseOfColumnVectors(V.Random(3), V.Random(3));\r\n\r\n    // Equivalent variants also for rows or diagonals:\r\n    M.DenseOfRowArrays(new[] {2.0, 3.0}, new[] {4.0, 5.0});\r\n    M.DenseOfDiagonalArray(new[] {2.0, 3.0, 4.0});\r\n\r\n    // if you already have existing matrices and want to concatenate them\r\n    Matrix\u003Cdouble\u003E[,] x = ...\r\n    M.DenseOfMatrixArray(x);\r\n\r\nVery similar variants also exist for sparse and diagonal matrices, prefixed\r\nwith \u0060Sparse\u0060 and \u0060Diagonal\u0060 respectively.\r\n\r\nThe approach for vectors is exactly the same:\r\n\r\n    [lang=csharp]\r\n    // Standard-distributed random vector of length 10\r\n    V.Random(10);\r\n\r\n    // All-zero vector of length 10\r\n    V.Dense(10);\r\n\r\n    // Each field is initialized using a function\r\n    V.Dense(10, i =\u003E i*i);\r\n\r\n    // From an enumerable of values and their index\r\n    Tuple\u003Cint,double\u003E[] x = {Tuple.Create(3,2.0), Tuple.Create(1,-3.0)};\r\n    V.DenseOfIndexed(x);\r\n\r\n    // Directly bind to an existing array without copying (note: no \u0022Of\u0022)\r\n    double[] x = existing...\r\n    V.Dense(x);\r\n\r\n### Creating matrices and vectors in F#\r\n\r\nIn F# we can use the builders just like in C#, but we can also use the F# modules:\r\n\r\n    [lang=fsharp]\r\n    let m1 = matrix [[ 2.0; 3.0 ]\r\n                     [ 4.0; 5.0 ]]\r\n\r\n    let v1 = vector [ 1.0; 2.0; 3.0 ]\r\n\r\n    // dense 3x4 matrix filled with zeros.\r\n    // (usually the type is inferred, but not for zero matrices)\r\n    let m2 = DenseMatrix.zero\u003Cfloat\u003E 3 4\r\n\r\n    // dense 3x4 matrix initialized by a function\r\n    let m3 = DenseMatrix.init 3 4 (fun i j -\u003E float (i\u002Bj))\r\n\r\n    // diagonal 4x4 identity matrix of single precision\r\n    let m4 = DiagonalMatrix.identity\u003Cfloat32\u003E 4\r\n\r\n    // dense 3x4 matrix created from a sequence of sequence-columns\r\n    let x = Seq.init 4 (fun c -\u003E Seq.init 3 (fun r -\u003E float (100*r \u002B c)))\r\n    let m5 = DenseMatrix.ofColumnSeq x\r\n\r\n    // random matrix with standard distribution:\r\n    let m6 = DenseMatrix.randomStandard\u003Cfloat\u003E 3 4\r\n\r\n    // random matrix with a uniform and one with a Gamma distribution:\r\n    let m7a = DenseMatrix.random\u003Cfloat\u003E 3 4 (ContinuousUniform(-2.0, 4.0))\r\n    let m7b = DenseMatrix.random\u003Cfloat\u003E 3 4 (Gamma(1.0, 2.0))\r\n\r\nOr using any other of all the available functions.\r\n\r\n\r\nArithmetics\r\n-----------\r\n\r\nAll the common arithmetic operators like \u0060\u002B\u0060, \u0060-\u0060, \u0060*\u0060, \u0060/\u0060 and \u0060%\u0060 are provided,\r\nbetween matrices, vectors and scalars. In F# there are additional pointwise\r\noperators \u0060.*\u0060, \u0060./\u0060 and \u0060.%\u0060 available for convenience.\r\n\r\n    [lang=fsharp]\r\n    let m = matrix [[ 1.0; 4.0; 7.0 ]\r\n                    [ 2.0; 5.0; 8.0 ]\r\n                    [ 3.0; 6.0; 9.0 ]]\r\n\r\n    let v = vector [ 10.0; 20.0; 30.0 ]\r\n\r\n    let v\u0027 = m * v\r\n    let m\u0027 = m \u002B 2.0*m\r\n\r\n### Arithmetic Instance Methods\r\n\r\nAll other operations are covered by methods, like \u0060Transpose\u0060 and \u0060Conjugate\u0060,\r\nor in F# as functions in the Matrix module, e.g. \u0060Matrix.transpose\u0060.\r\nBut even the operators have equivalent methods. The equivalent code from\r\nabove when using instance methods:\r\n\r\n    [lang=csharp]\r\n    var v2 = m.Multiply(v);\r\n    var m2 = m.Add(m.Multiply(2));\r\n\r\nThese methods also have an overload that accepts the result data structure as last argument,\r\nallowing to avoid allocating new structures for every single operation. Provided the\r\ndimensions match, most also allow one of the arguments to be passed as result,\r\nresulting in an in-place application. For example, an in-place version of the code above:\r\n\r\n    [lang=csharp]\r\n    m.Multiply(v, v); // v \u003C- m*v\r\n    m.Multiply(3, m); // m \u003C- 3*m\r\n\r\n### Shortcut Methods\r\n\r\nA typical linear algebra problem is the regression normal equation\r\n$\\mathbf{X}^T\\mathbf y = \\mathbf{X}^T\\mathbf X \\mathbf p$ which we would like to solve\r\nfor $p$. By matrix inversion we get $\\mathbf p = (\\mathbf{X}^T\\mathbf X)^{-1}(\\mathbf{X}^T\\mathbf y)$.\r\nThis can directly be translated to the following code:\r\n\r\n    [lang=csharp]\r\n    (X.Transpose() * X).Inverse() * (X.Transpose() * y)\r\n\r\nSince products where one of the arguments is transposed are common, there are a few shortcut routines\r\nthat are more efficient:\r\n\r\n    [lang=csharp]\r\n    X.TransposeThisAndMultiply(X).Inverse() * X.TransposeThisAndMultiply(y)\r\n\r\nOf course in practice you would not use the matrix inverse but a decomposition:\r\n\r\n    [lang=csharp]\r\n    X.TransposeThisAndMultiply(X).Cholesky().Solve(X.TransposeThisAndMultiply(y))\r\n    \r\n    // or if the problem is small enough, simply:\r\n    X.Solve(y);\r\n\r\n\r\nNorms\r\n-----\r\n\r\nWith norms we assign a \u0022size\u0022 to vectors and matrices, satisfying certain\r\nproperties pertaining to scalability and additivity. Except for the zero element,\r\nthe norm is strictly positive.\r\n\r\nVectors support the following norms:\r\n\r\n* **L1Norm** or Manhattan norm (p=1): the sum of the absolute values.\r\n* **L2Norm** or Euclidean norm (p=2): the square root of the sum of the squared values.\r\n  This is the most common norm and assumed if nothing else is stated.\r\n* **InfinityNorm** (p=infinity): the maximum absolute value.\r\n* **Norm(p)**: generalized norm, essentially the p-th root of the sum of the absolute p-power of the values.\r\n\r\nSimilarly, matrices support the following norms:\r\n\r\n* **L1Norm** (induced): the maximum absolute column sum.\r\n* **L2Norm** (induced): the largest singular value of the matrix (expensive).\r\n* **InfinityNorm** (induced): the maximum absolute row sum.\r\n* **FrobeniusNorm** (entry-wise): the square root of the sum of the squared values.\r\n* **RowNorms(p)**: the generalized p-norm for each row vector.\r\n* **ColumnNorms(p)**: the generalized p-norm for each column vector.\r\n\r\nVectors can be normalized to unit p-norm with the \u0060Normalize\u0060 method, matrices can\r\nnormalize all rows or all columns to unit p-norm with \u0060NormalizeRows\u0060 and \u0060NormalizeColumns\u0060.\r\n\r\n\r\nSums\r\n----\r\n\r\nClosely related to the norms are sum functions. Vectors have a \u0060Sum\u0060 function\r\nthat returns the sum of all vector elements, and \u0060SumMagnitudes\u0060 that returns\r\nthe sum of the absolute vector elements (and is identical to the L1-norm).\r\n\r\nMatrices provide \u0060RowSums\u0060 and \u0060ColumnSums\u0060 functions that return the sum of each\r\nrow or column vector, and \u0060RowAbsoluteSums\u0060 and \u0060ColumnAbsoluteSums\u0060 for the\r\nsums of the absolute elements.\r\n\r\n\r\nCondition Number\r\n----------------\r\n\r\nThe condition number of a function measures how much the output value can change\r\nfor a small change in the input arguments. A problem with a low condition number\r\nis said to be *well-conditioned*, with a high condition number *ill-conditioned*.\r\nFor a linear equation $Ax=b$ the condition number is the maximum ratio of the\r\nrelative error in $x$ divided by the relative error in $b$. It therefore gives a bound on how\r\ninaccurate the solution $x$ will be after approximation.\r\n\r\n    [lang=csharp]\r\n    M.Random(4,4).ConditionNumber(); // e.g. 14.829\r\n\r\n\r\nTrace and Determinant\r\n---------------------\r\n\r\nFor a square matrix, the trace of a matrix is the sum of the elements on the main diagonal,\r\nwhich is equal to the sum of all its eigenvalues with multiplicities. Similarly, the determinant\r\nof a square matrix is the product of all its eigenvalues with multiplicities.\r\nA matrix is said to be *singular* if its determinant is zero and *non-singular* otherwise.\r\nIn the latter case the matrix is invertible and the linear equation system it\r\nrepresents has a single unique solution.\r\n\r\n    [lang=csharp]\r\n    var m = M.DenseOfArray(new[,] {{ 1.0,  2.0, 1.0},\r\n                                   {-2.0, -3.0, 1.0},\r\n                                   { 3.0,  5.0, 0.0}});\r\n\r\n    m.Trace();       // -2\r\n    m.Determinant(); // ~0 hence not invertible, either none or multiple solutions\r\n\r\n\r\nColumn Space, Rank and Range\r\n-----------------------------\r\n\r\nThe rank of a matrix is the dimension of its column and row space, i.e. the maximum\r\nnumber of linearly independent column and row vectors of the matrix. It is a measure\r\nof the non-degenerateness of the linear equation system the matrix represents.\r\n\r\nAn orthonormal basis of the column space can be computed with the range method.\r\n\r\n    [lang=csharp]\r\n    // with the same m as above\r\n    m.Rank();  // 2\r\n    m.Range(); // [-0.30519,0.503259,-0.808449], [-0.757315,-0.64296,-0.114355]\r\n\r\n\r\nNull Space, Nullity and Kernel\r\n------------------------------\r\n\r\nThe null space or kernel of a matrix $A$ is the set of solutions to the equation $Ax=0$.\r\nIt is the orthogonal complement to the row space of the matrix.\r\n\r\nThe nullity of a matrix is the dimension of its null space.\r\nAn orthonormal basis of the null space can be computed with the kernel method.\r\n\r\n    [lang=csharp]\r\n    // with the same m as above\r\n    m.Nullity(); // 1\r\n    m.Kernel();  // [0.845154,-0.507093,0.169031]\r\n\r\n    // verify:\r\n    (m * (10*m.Kernel()[0])); // ~[0,0,0]\r\n\r\n\r\nMatrix Decompositions\r\n---------------------\r\n\r\nMost common matrix decompositions are directly available as instance methods.\r\nComputing a decomposition can be expensive for large matrices, so if you need\r\nto access multiple properties of a decomposition, consider to reuse the returned instance.\r\n\r\nAll decompositions provide Solve methods than can be used to solve linear\r\nequations of the form $Ax=b$ or $AX=B$. For simplicity the Matrix class\r\nalso provides direct \u0060Solve\u0060 methods that automatically choose\r\na decomposition. See [Linear Equation Systems](LinearEquations.html) for details.\r\n\r\nCurrently these decompositions are optimized for dense matrices only,\r\nand can leverage native providers like Intel MKL if available.\r\nFor sparse data consider to use the iterative solvers instead if appropriate,\r\nor convert to dense if small enough.\r\n\r\n* **Cholesky**: Cholesky decomposition of symmetric positive definite matrices\r\n* **LU**: LU decomposition of square matrices\r\n* **QR(method)**: QR by Householder transformation.\r\n  Thin by default (Q: mxn, R: nxn) but can optionally be computed fully (Q: mxm, R: mxn).\r\n* **GramSchmidt**: QR by Modified Gram-Schmidt Orthogonalization\r\n* **Svd(computeVectors)**: Singular Value Decomposition.\r\n  Computation of the singular U and VT vectors can optionally be disabled.\r\n* **Evd(symmetricity)**: Eigenvalue Decomposition.\r\n  If the symmetricity of the matrix is known, the algorithm can optionally skip its own check.\r\n\r\n\r\nManipulating Matrices and Vectors\r\n---------------------------------\r\n\r\nIndividual values can be get and set in matrices and vectors using the indexers\r\nor the \u0060At\u0060 methods. Using \u0060At\u0060 instead of the indexers is slightly faster but\r\nskips some range checks, so use it only after checking the range yourself.\r\n\r\n    [lang=csharp]\r\n    var m = Matrix\u003Cdouble\u003E.Build.Dense(3,4,(i,j) =\u003E 10*i \u002B j);\r\n    m[0,0]; // 0   (row 0, column 0)\r\n    m[2,0]; // 20 (row 2, column 0)\r\n    m[0,2]; // 2   (row 0, column 2)\r\n    m[0,2] = -1.0;\r\n    m[0,2]; // -1\r\n\r\nIn F#:\r\n\r\n    [lang=fsharp]\r\n    m.[2,0] // 20\r\n\r\nWe can also get entire column or row vectors, or a new matrix from parts of an existing one.\r\n\r\n    [lang=csharp]\r\n    var m = M.Dense(6,4,(i,j) =\u003E 10*i \u002B j);\r\n    m.Column(2);          // [2,12,22,32,42,52]\r\n    m.Row(3);             // [30,31,32,33]\r\n    m.SubMatrix(1,2,1,2); // [11,12; 21,22]\r\n\r\nFor each of these methods there is also a variant prefixed with \u0060Set\u0060 that can be used\r\nto overwrite those elements with the provided data.\r\n\r\n    [lang=csharp]\r\n    m.SetRow(3, V.Random(4));\r\n\r\nIn F# we can also use its slicing syntax:\r\n\r\n    [lang=fsharp]\r\n    let m = DenseMatrix.init 6 4 (fun i j -\u003E float (10*i \u002B j))\r\n    m.[0,0..3]    // vector [0,1,2,3]\r\n    m.[1..2,0..3] // matrix [10,11,12,13; 20,21,22,23]\r\n    // overwrite a sub-matrix with the content of another matrix:\r\n    m.[0..1,1..2] \u003C- matrix [[ 3.0; 4.0 ]; [ 5.0; 6.0 ]]\r\n\r\nTo set the whole matrix or some of its columns or rows to zero, use one of the clear methods:\r\n\r\n    [lang=csharp]\r\n    m.Clear(); // set all elements to 0\r\n    m.ClearColumn(2); // set the 3rd column to 0 (0-based indexing)\r\n    m.ClearColumns(1,3); // set the 2nd and 4th columns to 0 (params-array)\r\n    m.ClearSubMatrix(1,2,1,2); // set the 2x2 submatrix with offset 1,1 to zero\r\n\r\nBecause of the limitations of floating point numbers, we may want to set very small numbers to zero:\r\n\r\n    [lang=csharp]\r\n    m.CoerceZero(1e-14); // set all elements smaller than 1e-14 to 0\r\n    m.CoerceZero(x =\u003E x \u003C 10); // set all elements that match a predicate function to 0.\r\n\r\nEven though matrices and vectors are mutable, their dimension is fixed and cannot be changed\r\nafter creation. However, we can still insert or remove rows or columns, or concatenate matrices together.\r\nBut all these operations will create and return a new instance.\r\n\r\n    [lang=csharp]\r\n    var m2 = m.RemoveRow(2); // remove the 3rd rows\r\n    var m3 = m2.RemoveColumn(3); // remove the 4th column\r\n\r\n    var m4 = m.Stack(m2); // new matrix with m on top and m2 on the bottom\r\n    var m5 = m2.Append(m3); // new matrix with m2 on the left and m3 on the right\r\n    var m6 = m.DiagonalStack(m3); // m on the top left and m3 on the bottom right\r\n\r\n\r\nEnumerators and Higher Order Functions\r\n--------------------------------------\r\n\r\nSince looping over all entries of a matrix or vector with direct access is inefficient,\r\nespecially with a sparse storage layout, and working with the raw structures is non-trivial,\r\nboth vectors and matrices provide specialized enumerators and higher order functions that\r\nunderstand the actual layout and can use it more efficiently.\r\n\r\nMost of these functions can optionally skip zero-value entries. If you do not need to handle\r\nzero-value elements, skipping them can massively speed up execution on sparse layouts.\r\n\r\n### Iterate\r\n\r\nBoth vectors and matrices have Enumerate methods that return an \u0060IEnumerable\u003CT\u003E\u0060,\r\nthat can be used to iterate through all elements. All these methods optionally\r\naccept a \u0060Zeros\u0060 enumeration to control whether zero-values may be skipped or not.\r\n\r\n* **Enumerate**: returns a straight forward enumerator over all values.\r\n* **EnumerateIndexed**: returns an enumerable with index-value-tuples.\r\n\r\nMatrices can also enumerate over all column or row vectors, or all of them\r\nwithin a range:\r\n\r\n* **EnumerateColumns**: returns an enumerable with all or a range of the column vectors.\r\n* **EnumerateColumnsIndexed**: like EnumerateColumns buth returns index-column tuples.\r\n* **EnumerateRows**: returns an enumerable with all or a range of the row vectors.\r\n* **EnumerateRowsIndexed**: like EnumerateRows buth returns index-row tuples.\r\n\r\n### Map\r\n\r\nSimilarly there are also Map methods that replace each element with the result\r\nof applying a function to its value. Or, if indexed, to its index and value.\r\n\r\n* **MapInplace(f,zeros)**: map in-place with a function on the element\u0027s value\r\n* **MapIndexedInplace(f,zeros)**: map in-place with a function on the element\u0027s index and value.\r\n* **Map(f,result,zeros)**: map into a result structure provided as argument.\r\n* **MapIndexed(f,result,zeros)**: indexed variant of Map.\r\n* **MapConvert(f,result,zeros)**: variant where the function can return a different type\r\n* **MapIndexedConvert(f,result,zeros)**: indexed variant of MapConvert.\r\n* **Map(f,zeros)**: like MapConvert but returns a new structure instead of the result argument.\r\n* **MapIndexed(f,zeros)**: indexed variant of Map.\r\n\r\nExample: Convert a complex vector to a real vector containing only the real parts in C#:\r\n\r\n    [lang=csharp]\r\n    Vector\u003CComplex\u003E u = Vector\u003CComplex\u003E.Build.Random(10);\r\n    Vector\u003CDouble\u003E v = u.Map(c =\u003E c.Real);\r\n\r\nOr in F#:\r\n\r\n    [lang=fsharp]\r\n    let u = DenseVector.randomStandard\u003CComplex\u003E 10\r\n    let v = u |\u003E Vector.map (fun c -\u003E c.Real)\r\n\r\n### Fold and Reduce\r\n\r\nMatrices also provide column/row fold and reduce routines:\r\n\r\n* **FoldByRow(f,state,zeros)**: fold through the values of each row, returns an column-array.\r\n* **FoldRows(f,state)**: fold over all row vectors, returns a row vector.\r\n* **ReduceRows(f)**: reduce all row vectors, returns a row vector.\r\n\r\n\r\nPrinting and Strings\r\n--------------------\r\n\r\nMatrices and vectors try to print themselves to a string with the \u0060ToString\u0060\r\nin a reasonable way, without overflowing the output device on a large matrix.\r\n\r\nNote that this function is not intended to export a data structure to a string or\r\nfile, but to give an informative summary about it. For data import/export,\r\nuse one of the MathNet.Numerics.Data packages instead.\r\n\r\nSome matrix examples:\r\n\r\n    [lang=text]\r\n    // Matrix\u003Cdouble\u003E.Build.Dense(3,4,(i,j) =\u003E i*10*j).ToString()\r\n    DenseMatrix 3x4-Double\r\n    0   0   0   0\r\n    0  10  20  30\r\n    0  20  40  60\r\n\r\n    // Matrix\u003Cdouble\u003E.Build.Dense(100,100,(i,j) =\u003E i*10*j).ToString()\r\n    DenseMatrix 100x100-Double\r\n     0    0     0     0     0     0     0     0     0     0     0  ..      0      0\r\n     0   10    20    30    40    50    60    70    80    90   100  ..    980    990\r\n     0   20    40    60    80   100   120   140   160   180   200  ..   1960   1980\r\n     0   30    60    90   120   150   180   210   240   270   300  ..   2940   2970\r\n     0   40    80   120   160   200   240   280   320   360   400  ..   3920   3960\r\n     0   50   100   150   200   250   300   350   400   450   500  ..   4900   4950\r\n     0   60   120   180   240   300   360   420   480   540   600  ..   5880   5940\r\n     0   70   140   210   280   350   420   490   560   630   700  ..   6860   6930\r\n    ..   ..    ..    ..    ..    ..    ..    ..    ..    ..    ..  ..     ..     ..\r\n     0  960  1920  2880  3840  4800  5760  6720  7680  8640  9600  ..  94080  95040\r\n     0  970  1940  2910  3880  4850  5820  6790  7760  8730  9700  ..  95060  96030\r\n     0  980  1960  2940  3920  4900  5880  6860  7840  8820  9800  ..  96040  97020\r\n     0  990  1980  2970  3960  4950  5940  6930  7920  8910  9900  ..  97020  98010\r\n\r\n    // Matrix\u003Cdouble\u003E.Build.Random(4,4).ToString()\r\n    DenseMatrix 4x4-Double\r\n      1.6286    -1.1126    1.95526  0.950545\r\n    0.537503  -0.465534    2.00984   1.90885\r\n    -1.62816    1.04109   -2.06876  0.812197\r\n    0.452355  -0.689394  -0.277921   2.72224\r\n\r\n    // Matrix\u003Cdouble\u003E.Build.SparseOfIndexed(4,100,new[] {Tuple.Create(1,2,3.0)})\r\n    SparseMatrix 4x100-Double 0.25% Filled\r\n    0  0    0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  ..  0  0\r\n    0  0  3.5  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  ..  0  0\r\n    0  0    0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  ..  0  0\r\n    0  0    0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  ..  0  0\r\n\r\nVectors are printed as a column that can wrap over to multiple columns if needed:\r\n\r\n    [lang=text]\r\n    // Vector\u003Cdouble\u003E.Build.Random(15).ToString()\r\n    DenseVector 15-Double\r\n     0.519184  0.0950414\r\n      1.65913    2.56783\r\n     0.743408   0.574037\r\n     -1.73394           \r\n    -0.906662           \r\n     0.853759           \r\n    -0.162181           \r\n    -0.231667           \r\n     -1.26393           \r\n    -0.434873           \r\n     0.693421           \r\n    -0.513683           \r\n\r\n    // Vector\u003Cdouble\u003E.Build.Dense(500,i =\u003E i).ToString()\r\n    DenseVector 500-Double\r\n     0  12  24  36  48  60  72  84   96  108  120  132  144  156  168  180  192\r\n     1  13  25  37  49  61  73  85   97  109  121  133  145  157  169  181  193\r\n     2  14  26  38  50  62  74  86   98  110  122  134  146  158  170  182  194\r\n     3  15  27  39  51  63  75  87   99  111  123  135  147  159  171  183  195\r\n     4  16  28  40  52  64  76  88  100  112  124  136  148  160  172  184  196\r\n     5  17  29  41  53  65  77  89  101  113  125  137  149  161  173  185  197\r\n     6  18  30  42  54  66  78  90  102  114  126  138  150  162  174  186  198\r\n     7  19  31  43  55  67  79  91  103  115  127  139  151  163  175  187  199\r\n     8  20  32  44  56  68  80  92  104  116  128  140  152  164  176  188   ..\r\n     9  21  33  45  57  69  81  93  105  117  129  141  153  165  177  189   ..\r\n    10  22  34  46  58  70  82  94  106  118  130  142  154  166  178  190  498\r\n    11  23  35  47  59  71  83  95  107  119  131  143  155  167  179  191  499\r\n\r\nThe format is customizable to some degree, for example we can choose the\r\nfloating point format and culture, or how many rows or columns should be shown:\r\n\r\n    [lang=text]\r\n    // var m = Matrix\u003Cdouble\u003E.Build.Random(5,100,42); // 42 = random seed\r\n    \r\n    // m.ToString()\r\n    DenseMatrix 5x100-Double\r\n     0.408388  -0.847291  -0.320552   0.162242    2.46434  ..   0.180466   -0.278793\r\n     -1.06988   0.063008  -0.527378    1.40716    -0.5962  ..  -0.622447   -0.488186\r\n    -0.734176  -0.703003    1.33158   0.286498    1.44158  ..  -0.834335  -0.0756724\r\n      1.78532   0.020217    1.94275  -0.742821  -0.790251  ..    1.52823     2.49427\r\n    -0.660645    1.28166   -1.71351   -1.33282  -0.328162  ..   0.110989    0.252272\r\n\r\n    // m.ToString(\u0022G2\u0022, CultureInfo.GetCultureInfo(\u0022de-DE\u0022))\r\n    DenseMatrix 5x100-Double\r\n     0,41  -0,85  -0,32   0,16    2,5     -0,77   0,12   0,58  ..   0,18   -0,28\r\n     -1,1  0,063  -0,53    1,4   -0,6      -2,8  -0,35    0,3  ..  -0,62   -0,49\r\n    -0,73   -0,7    1,3   0,29    1,4  -0,00022   -0,3   0,51  ..  -0,83  -0,076\r\n      1,8   0,02    1,9  -0,74  -0,79     0,088   0,78  -0,94  ..    1,5     2,5\r\n    -0,66    1,3   -1,7   -1,3  -0,33     -0,69  -0,27  -0,68  ..   0,11    0,25\r\n\r\n    // m.ToString(3,5) // max 3 rows, 5 columns\r\n    DenseMatrix 5x100-Double\r\n     0.408388  -0.847291  -0.320552  ..   0.180466   -0.278793\r\n     -1.06988   0.063008  -0.527378  ..  -0.622447   -0.488186\r\n    -0.734176  -0.703003    1.33158  ..  -0.834335  -0.0756724\r\n           ..         ..         ..  ..         ..          ..\r\n\r\n    // Matrix\u003Cdouble\u003E.Build.Random(100,100,42)\r\n    // .ToMatrixString(2,4,3,4,\u0022=\u0022,\u0022||\u0022,@\u0022\\\\\u0022,\u0022 \u0022,Environment.NewLine,x=\u003Ex.ToString(\u0022G2\u0022))\r\n     0.41   0.36  0.29  =  0.43 0.56   -0.56  0.98\r\n     -1.1  -0.64   0.9  =  0.49 -0.3       2  -0.5\r\n       ||     ||    || \\\\    ||   ||      ||    ||\r\n    -0.87   -2.2  0.79  =  0.96  1.8     1.4 0.067\r\n    -0.14 -0.016 -0.55  = -0.36 0.33    0.24  0.52\r\n     -1.3     -1 -0.81  =   1.3    1    -1.1 -0.28\r\n    -0.21   -1.7   2.6  =  -1.5 -1.2 -0.0014   3.4\r\n\r\nIf you are using Math.NET Numerics from within F# interactive, you may want\r\nto load the MathNet.Numerics.fsx script of the F# package. Besides loading\r\nthe assemblies it also adds proper FSI printers for both matrices and vectors.\r\n"},{"uri":"https://numerics.mathdotnet.com/MatrixMarket.html","title":"NIST MatrixMarket Text Files\r\n","content":"NIST MatrixMarket Text Files\r\n============================\r\n\r\nMatrixMarket is both a [vast repository of test data](https://math.nist.gov/MatrixMarket/)\r\nand a text-based [exchange file format](https://math.nist.gov/MatrixMarket/formats.html) provided by NIST.\r\nBeing text-based makes it convenient to deal with and program against, and also works well with versioning\r\ntools like [Git](https://www.git-scm.com/). But other than [CSV](CSV.html) it can also store sparse matrices in a compact way.\r\n\r\nMath.NET Numerics provides basic support for MatrixMarket files with the **MathNet.Numerics.Data.Text** package,\r\nwhich is available on NuGet as separate package and not included in the basic distribution.\r\n\r\n\r\nReading a matrix from a MatrixMarket file\r\n-----------------------------------------\r\n\r\nThe \u0060MatrixMarketReader\u0060 class provides static functions to read a matrix or a vector from a file or string.\r\nIt can read from:\r\n\r\n* **TextReader**: If you have your delimited data already in memory in a string,\r\n  you can use this method using a StringReader.\r\n* **Stream**: read directly from a stream, e.g. a MemoryStream, FileStream or NetworkStream.\r\n* **File Path (string)**: read from a file, specified by the file system path. Optionally GZip compressed.\r\n\r\nAll these functions expect the data type of the matrix to be generated as generic type argument.\r\nOnly Double, Single, Complex and Complex32 are supported.\r\n\r\nExample:\r\n\r\n    [lang=csharp]\r\n    using MathNet.Numerics.Data.Text;\r\n\r\n    Matrix\u003Cdouble\u003E matrix = MatrixMarketReader.ReadMatrix\u003Cdouble\u003E(\u0022fidap007.mtx\u0022);\r\n\r\n\r\nWriting a matrix to a MatrixMarket file\r\n---------------------------------------\r\n\r\nThe dual to the reader above is the \u0060MatrixMarketWriter\u0060 class that can serialize a matrix or vector\r\nto a MatrixMarket text file, stream or TextWriter.\r\n\r\nExample:\r\n\r\n    [lang=csharp]\r\n    MatrixMarketWriter.WriteMatrix(\u0022matrix.mtx\u0022, m);\r\n\r\n\r\nAlternatives\r\n------------\r\n\r\nThe data extension packages also offer other ways to serialize a matrix to a binary stream or file.\r\nAmong others:\r\n\r\n* [Delimited Text Files (CSV \u0026 TSV)](CSV.html)\r\n* [MATLAB Level-5 Mat files](MatlabFiles.html)\r\n"},{"uri":"https://numerics.mathdotnet.com/MKL.html","title":"Intel Math Kernel Library (MKL)\r\n","content":"Intel Math Kernel Library (MKL)\r\n===============================\r\n\r\nMath.NET Numerics is designed such that performance-sensitive algorithms\r\ncan be swapped with alternative implementations by the concept of providers.\r\nThere is currently only a provider for [linear algebra related routines](https://numerics.mathdotnet.com/api/MathNet.Numerics.Providers.LinearAlgebra.Mkl/MklLinearAlgebraProvider.htm), but there\r\nare plans to add additional more e.g. related to nonlinear optimization problems or signal processing.\r\n\r\nProviders become interesting when they can leverage a platform-native high performance library\r\nlike Intel MKL instead of the default purely managed provider. Math.NET Numerics\r\nprovides such a provider as NuGet packages:\r\n\r\n* MathNet.Numerics.MKL.Win\r\n* MathNet.Numerics.MKL.Linux\r\n\r\nSince these native libraries can become very big, there are also variants supporting\r\nonly a single platform, for example:\r\n\r\n* MathNet.Numerics.MKL.Win-x86\r\n* MathNet.Numerics.MKL.Win-x64\r\n\r\nIn order to leverage the MKL linear algebra provider, we need to make sure the .NET\r\nruntime can find the native libraries (see below) and then enable it by calling:\r\n\r\n    [lang=csharp]\r\n    Control.UseNativeMKL();\r\n\r\nAlternatively you can also enable it by setting the environment variable \u0060MathNetNumericsLAProvider=MKL\u0060.\r\n\r\nYou can also explicitly disable the MKL provider by forcing it to use the managed provider by calling:\r\n\r\n    [lang=csharp]\r\n    Control.UseManaged();\r\n\r\nYou can tell what provider is effectively loaded by calling \u0060Control.LinearAlgebraProvider.ToString()\u0060,\r\nwhich will return something along the lines of \u0060Intel MKL (x86; revision 7)\u0060.\r\n\r\n\r\nNative Binaries\r\n---------------\r\n\r\nIn .Net, the fusion engine is responsible for finding referenced\r\nassemblies in the file system and loading them into the executing process.\r\nHowever, native binaries like our MKL provider are platform specific,\r\nso we need to load them with services of the platform instead of the .Net runtime.\r\nWe use P/Invoke to talk to the binaries, but for this to work they must\r\nhave already been loaded or the platform service needs to be able to find and\r\nload them on its own.\r\n\r\nIn order to make providers easier to use, since v3.6.0 Math.NET Numerics\r\nfirst tries to load native providers from a set of known directories before\r\nfalling back to the platform\u0027s default behavior. In each of these directories\r\nit first looks for a processor-architecture specific folder within the directory,\r\nbefore looking at the directory itself:\r\n\r\n1. If \u0060Control.NativeProviderPath\u0060 is set: \u0060{NativeProviderPath}/{Platform}/\u0060\r\n2. If \u0060Control.NativeProviderPath\u0060 is set: \u0060{NativeProviderPath}/\u0060\r\n3. \u0060{AppDomain.BaseDirectory}/{Platform}/\u0060\r\n4. \u0060{AppDomain.BaseDirectory}/\u0060\r\n5. \u0060{ExecutingAssemblyPath}/{Platform}/\u0060\r\n6. \u0060{ExecutingAssemblyPath}/\u0060\r\n7. Fall back to the platform\u0027s default behavior (see below)\r\n\r\nWhere \u0060{Platform}\u0060 can be one of the following: \u0060x86\u0060, \u0060x64\u0060, \u0060ia64\u0060, \u0060arm\u0060 or \u0060arm64\u0060.\r\n\r\nThis means that you can, for example, place the 32 bit MKL provider binaries into \u0060C:\\MKL\\x86\u0060\r\nand the 64 bit ones into \u0060C:\\MKL\\x64\u0060, and then set \u0060Control.NativeProviderPath = @\u0022C:\\MKL\u0022;\u0060.\r\nNumerics will automatically choose the right one depending on whether your process is\r\nrunning in 32 or 64 bit mode, and there is no more need to copy the large binaries to the\r\noutput folder of every script or project.\r\n\r\n\r\nDefault Behavior on Windows\r\n---------------------------\r\n\r\nOn Windows it is usually enough to make sure the native libraries are in the\r\nsame folder as the executable. Reference the appropriate NuGet package and set\r\n\u0022Copy to Output Directory\u0022 for both libMathNetNumericsMKL.dll and libiomp5md.dll\r\nto \u0022Copy always\u0022, or place the two native DLLs manually into the same directory\r\nas your application\u0027s executable. There is no need to set the native provider\r\npath explicitly.\r\n\r\nFor more details how the platform default behavior works and what influences it,\r\nsee [Dynamic-Link Library Search Order](https://msdn.microsoft.com/en-us/library/windows/desktop/ms682586.aspx).\r\n\r\n\r\nDefault Behavior on Linux\r\n-------------------------\r\n\r\nNative assembly resolving is very different on Linux than on Windows, simply putting the native\r\nlibraries into the same folder as the executable is not enough. The safe way is to edit \u0060/etc/ld.so.conf\u0060\r\nand use \u0060ldconfig\u0060 to tell where to look for the libraries. Alternatively you could add the path\r\nto \u0060LD_LIBRARY_PATH\u0060 or even just copy them to \u0060/usr/lib\u0060.\r\n\r\nFor details see Mono\u0027s [Interop with Native Libraries](https://www.mono-project.com/docs/advanced/pinvoke/#linux-shared-library-search-path).\r\n\r\n\r\nDefault Behavior on Mac OS X\r\n----------------------------\r\n\r\nYou can configure the search path on one of the environment variables like \u0060DYLD_LIBRARY_PATH\u0060\r\nor just copy them e.g. to \u0060/usr/lib\u0060.\r\n\r\nFor details see Mono\u0027s [Interop with Native Libraries](https://www.mono-project.com/docs/advanced/pinvoke/#mac-os-x-framework-and-dylib-search-path).\r\n\r\nTo build the MKL native provider for OSX:\r\n\r\n1. Make sure you\u0027ve a valid [Intel MKL](https://software.intel.com/en-us/qualify-for-free-software/academicresearcher) licence installed on your mac (look at opt/intel).\r\n   If not, you can get a free trial on intel\u0027s web site.\r\n2. Open the terminal\r\n3. cd to the folder mathnet-numerics/src/NativeProviders/OSX\r\n4. Run the .sh script by typing sh mkl_build.sh\r\n5. ... wait for the build\r\n\r\n\r\n    [lang=sh]\r\n    lionel:~ Lionel$ cd /Users/Lionel/Public/Git/GitHub/mathnet-numerics/src/NativeProviders/OSX\r\n    lionel:OSX Lionel$ ls\r\n    mkl_build.sh\r\n    lionel:OSX Lionel$ sh mkl_build.sh\r\n\r\nCheck the /x86 and /x64 folders in mathnet-numerics/out/MKL: you should now find the \u0060libiomp5.dylib\u0060 and \u0060libMathNetNumericsMKL.dll\u0060 libaries.\r\nYou need to add the path to the generated libraries in your \u0060DYLD_LIBRARY_PATH\u0060 environment variable (which you can move to the folder of you choice before).\r\nTo do that, open your /Users/Lionel/.bas_profile.sh file with a text editor and add the following statements.\r\n\r\n\t[lang=sh]\r\n    export DYLD_LIBRARY_PATH=$DYLD_LIBRARY_PATH:/Users/Lionel/../mathnet-numerics/out/MKL/OSX/x64\r\n    export DYLD_LIBRARY_PATH=$DYLD_LIBRARY_PATH:/Users/Lionel/../mathnet-numerics/out/MKL/OSX/x86\r\n\r\nOf course replace \u0060Lionel\u0060 by your account login.\r\n\r\nHave a look a the example down this page to compare MKL-provider vs. managed-provider performances.\r\n\r\n\r\nF# Interactive\r\n--------------\r\n\r\nIn F# Interactive, the easiest way to use native providers is to copy them to a shared\r\ndirectory somewhere and use them directly from there:\r\n\r\n    [lang=fsharp]\r\n    Control.NativeProviderPath \u003C- @\u0022C:\\MKL\u0022\r\n    Control.UseNativeMKL()\r\n\r\nIf you are using the F# Power Tools in VisualStudio, you can also let it generate \u0022Reference\r\nscripts for F# Interactive\u0022 right from the context menu. This will generate a script called\r\n\u0060load-references.fsx\u0060 in a \u0060Scripts\u0060 folder, which you can extend as follows to load the\r\nMKL provider automatically.\r\n\r\n    [lang=fsharp]\r\n    open System.IO\r\n    open MathNet.Numerics\r\n\r\n    Control.NativeProviderPath \u003C- Path.Combine(__SOURCE_DIRECTORY__,\u0022../\u0022)\r\n    Control.UseNativeMKL()\r\n\r\nThis script assumes that the MKL binaries have been copied to the project directory,\r\nwhich is also where the NuGet packages place them by default. If you place them somewhere\r\nelse, adapt the path accordingly.\r\n\r\nSee also [Loading Native DLLs in F# Interactive](https://christoph.ruegg.name/blog/loading-native-dlls-in-fsharp-interactive.html)\r\nfor more alternatives.\r\n\r\nLINQPad and assembly shadowing\r\n------------------------------\r\n\r\nThe automatic strategy may still work if assembly shadowing is involved,\r\nbut it often simpler and more reliable to provide the folder explicitly.\r\nThis also works well in LINQPad, with and without assembly shadowing:\r\n\r\n    [lang=csharp]\r\n    Control.NativeProviderPath = @\u0022C:\\MKL\u0022;\r\n    Control.UseNativeMKL();\r\n\r\n\r\nExample: Intel MKL on Linux with Mono\r\n-------------------------------------\r\n\r\nWe also provide MKL NuGet package for Linux if you do not want to build them yourself. Assuming you have\r\nMono and NuGet installed (here v3.2.8), you can fetch the MKL package of the right architecture\r\n(x64 or x86, \u0060uname -m\u0060 if you don\u0027t know) as usual:\r\n\r\n    [lang=sh]\r\n    mono nuget.exe install MathNet.Numerics -Pre -OutputDirectory packages\r\n    mono nuget.exe install MathNet.Numerics.MKL.Linux-x64 -Pre -OutputDirectory packages\r\n\r\nNative assembly resolving is very different on Linux than on Windows, simply putting the native\r\nlibraries into the same folder as the executable is not enough. The safe way is to edit \u0060/etc/ld.so.conf\u0060\r\nand use \u0060ldconfig\u0060 to tell where to look for the libraries, but for now we\u0027ll just copy them to \u0060/usr/lib\u0060:\r\n\r\n    [lang=sh]\r\n    sudo cp packages/MathNet.Numerics.MKL.Linux-x64.1.3.0/content/libiomp5.so /usr/lib/\r\n    sudo cp packages/MathNet.Numerics.MKL.Linux-x64.1.3.0/content/libMathNetNumericsMKL.dll /usr/lib/\r\n\r\nThen we\u0027re all set and can just call \u0060Control.UseNativeMKL()\u0060 if we want to use the native provider.\r\nLet\u0027s create the following C# file \u0060Example.cs\u0060:\r\n\r\n    [lang=csharp]\r\n    using System;\r\n    using System.Diagnostics;\r\n    using MathNet.Numerics;\r\n    using MathNet.Numerics.LinearAlgebra;\r\n\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            // Using managed code only\r\n            Control.UseManaged();\r\n            Console.WriteLine(Control.LinearAlgebraProvider);\r\n\r\n            var m = Matrix\u003Cdouble\u003E.Build.Random(500, 500);\r\n            var v = Vector\u003Cdouble\u003E.Build.Random(500);\r\n\r\n            var w = Stopwatch.StartNew();\r\n            var y1 = m.Solve(v);\r\n            Console.WriteLine(w.Elapsed);\r\n            Console.WriteLine(y1);\r\n\r\n            // Using the Intel MKL native provider\r\n            Control.UseNativeMKL();\r\n            Console.WriteLine(Control.LinearAlgebraProvider);\r\n\r\n            w.Restart();\r\n            var y2 = m.Solve(v);\r\n            Console.WriteLine(w.Elapsed);\r\n            Console.WriteLine(y2);\r\n        }\r\n    }\r\n\r\nCompile and run:\r\n\r\n    [lang=sh]\r\n    # single line:\r\n    mcs -optimize -lib:packages/MathNet.Numerics.3.0.0-alpha8/lib/net40/\r\n                  -r:MathNet.Numerics.dll Example.cs -out:Example\r\n    # launch:\r\n    mono Example\r\n\r\n\r\nLicensing Restrictions\r\n----------------------\r\n\r\nThe MKL Provider is available for free under the terms of the [Intel Simplified Software License](License-MKL.html).\r\n"},{"uri":"https://numerics.mathdotnet.com/Packages.html","title":"NuGet Packages \u0026amp; Binaries\r\n","content":"NuGet Packages \u0026 Binaries\r\n=========================\r\n\r\nThe recommended way to get Math.NET Numerics is NuGet. The following packages are\r\nprovided and maintained in the public [NuGet Gallery](https://nuget.org/profiles/mathnet/).\r\nThe complete set of Zip and NuGet packages including symbol packages is also available in the\r\n[release archive](https://archive.mathdotnet.com/Math.NET%20Numerics/).\r\n\r\n\r\nMath.NET Numerics\r\n-----------------\r\n\r\nIn most scenarios you\u0027ll only need the primary package named \u0060MathNet.Numerics\u0060.\r\nIf you are working with F# we recommend to also use the F# extension package\r\nfor a more natural and idiomatic experience.\r\n\r\n[MathNet.NET Numerics Release Notes](ReleaseNotes.html)\r\n\r\n- [**MathNet.Numerics**](https://www.nuget.org/packages/MathNet.Numerics/) - core package, including .Net 4.0, .Net Standard 1.3 and higher.\r\n- [**MathNet.Numerics.FSharp**](https://www.nuget.org/packages/MathNet.Numerics.FSharp/) - optional extensions for a better F# experience. BigRational.\r\n\r\nBoth packages above do not have a strong name. While we do not recommend it,\r\nthere are valid scenarios where strong named assemblies are required. That\u0027s why\r\nwe also provide strong-named variants with the \u0060.Signed\u0060 suffix. Note that signed\r\npackages do not contain portable builds.\r\n\r\n- [**MathNet.Numerics.Signed**](https://www.nuget.org/packages/MathNet.Numerics.Signed/) - strong-named version of the core package.\r\n- [**MathNet.Numerics.FSharp.Signed**](https://www.nuget.org/packages/MathNet.Numerics.FSharp.Signed/) - strong-named version of the F# package.\r\n\r\nIntel MKL Native Provider\r\n-------------------------\r\n\r\nThe new combined package includes both 32 and 64 bit binaries and can automatically\r\npick the right one at runtime. It is also MsBuild integrated, so there is no\r\nmore need to any manual file handling. But it is only supported by Math.NET Numerics\r\nv3.6.0 and higher.\r\n\r\nIf you intend to [maintain the native binaries manually](MKL.html#Native-Binaries)\r\nit may be easier to download the Zip file in the [release archive](https://archive.mathdotnet.com/Math.NET%20Numerics/Zip/).\r\n\r\n[Intel MKL Native Provider Release Notes](ReleaseNotes-MKL.html)\r\n\r\n- [**MathNet.Numerics.MKL.Win**](https://www.nuget.org/packages/MathNet.Numerics.MKL.Win/) - Windows (combined, MsBuild integrated).\r\n- [**MathNet.Numerics.MKL.Win-x64**](https://www.nuget.org/packages/MathNet.Numerics.MKL.Win-x64/) - Windows 64-bit only.\r\n- [**MathNet.Numerics.MKL.Win-x86**](https://www.nuget.org/packages/MathNet.Numerics.MKL.Win-x86/) - Windows 32-bit only.\r\n- [**MathNet.Numerics.MKL.Linux-x64**](https://www.nuget.org/packages/MathNet.Numerics.MKL.Linux-x64/) - Linux 64-bit.\r\n- [**MathNet.Numerics.MKL.Linux-x86**](https://www.nuget.org/packages/MathNet.Numerics.MKL.Linux-x86/) - Linux 32-bit.\r\n\r\nData Extensions\r\n---------------\r\n\r\nData/IO Packages for reading and writing data.\r\n\r\n[Data Extensions Release Notes](ReleaseNotes-Data.html)\r\n\r\n- [**MathNet.Numerics.Data.Text**](https://www.nuget.org/packages/MathNet.Numerics.Data.Text/) - Text-based matrix formats like [CSV](CSV.html) and [MatrixMarket](MatrixMarket.html).\r\n- [**MathNet.Numerics.Data.Matlab**](https://www.nuget.org/packages/MathNet.Numerics.Data.Matlab/) - [MATLAB Level-5](MatlabFiles.html) matrix file format.\r\n"},{"uri":"https://numerics.mathdotnet.com/Probability.html","title":"Probability Distributions\r\n","content":"    [hide]\r\n    #I \u0022../../out/lib/net40\u0022\r\n    #r \u0022MathNet.Numerics.dll\u0022\r\n    #r \u0022MathNet.Numerics.FSharp.dll\u0022\r\n    open System.Numerics\r\n    open MathNet.Numerics\r\n    open MathNet.Numerics.Random\r\n    open MathNet.Numerics.Distributions\r\n\r\nProbability Distributions\r\n=========================\r\n\r\nMath.NET Numerics provides a wide range of probability distributions. Given the\r\ndistribution parameters they can be used to investigate their statistical properties\r\nor to sample non-uniform random numbers.\r\n\r\nAll the distributions implement a common set of operations such as\r\nevaluating the density (PDF) and the cumulative distribution (CDF)\r\nat a given point, or to compute the mean, standard deviation and other properties.\r\nBecause it is often numerically more stable and faster to compute such statistical quantities\r\nin the logarithmic domain, we also provide a selection of them in the log domain with the \u0022Ln\u0022 suffix,\r\ne.g. DensityLn for the logarithmic density.\r\n\r\n    [lang=csharp]\r\n    using MathNet.Numerics.Distributions;\r\n    using MathNet.Numerics.Random;\r\n\r\n    // create a parametrized distribution instance\r\n    var gamma = new Gamma(2.0, 1.5);\r\n\r\n    // distribution properties\r\n    double mean = gamma.Mean;\r\n    double variance = gamma.Variance;\r\n    double entropy = gamma.Entropy;\r\n\r\n    // distribution functions\r\n    double a = gamma.Density(2.3); // PDF\r\n    double b = gamma.DensityLn(2.3); // ln(PDF)\r\n    double c = gamma.CumulativeDistribution(0.7); // CDF\r\n\r\n    // non-uniform number sampling\r\n    double randomSample = gamma.Sample();\r\n\r\nBoth probability functions and sampling are also available as static functions\r\nfor simpler usage scenarios:\r\n\r\n    [lang=csharp]\r\n    // distribution parameters must be passed as arguments\r\n    double a2 = Gamma.PDF(2.0, 1.5, 2.3);\r\n    double randomSample2 = Gamma.Sample(2.0, 1.5);\r\n\r\n\u003Cdiv style=\u0022overflow:auto;\u0022\u003E\r\n\u003Cdiv style=\u0022float: left; width: 50%;\u0022\u003E\r\n\r\n### Continuous Distributions\r\n\r\n* [Continuous Uniform](https://en.wikipedia.org/wiki/Uniform_distribution_%28continuous%29)\r\n* [Normal](https://en.wikipedia.org/wiki/Normal_distribution)\r\n* [Log Normal](https://en.wikipedia.org/wiki/Log-normal_distribution)\r\n* [Beta](https://en.wikipedia.org/wiki/Beta_distribution)\r\n* [Cauchy](https://en.wikipedia.org/wiki/cauchy_distribution) (Cauchy-Lorentz)\r\n* [Chi](https://en.wikipedia.org/wiki/Chi_distribution)\r\n* [Chi Squared](https://en.wikipedia.org/wiki/Chi-square_distribution)\r\n* [Erlang](https://en.wikipedia.org/wiki/Erlang_distribution)\r\n* [Exponential](https://en.wikipedia.org/wiki/exponential_distribution)\r\n* [Fisher-Snedecor](https://en.wikipedia.org/wiki/F-distribution) (F-Distribution)\r\n* [Gamma](https://en.wikipedia.org/wiki/Gamma_distribution)\r\n* [Inverse Gamma](https://en.wikipedia.org/wiki/inverse-gamma_distribution)\r\n* [Laplace](https://en.wikipedia.org/wiki/Laplace_distribution)\r\n* [Pareto](https://en.wikipedia.org/wiki/Pareto_distribution)\r\n* [Rayleigh](https://en.wikipedia.org/wiki/Rayleigh_distribution)\r\n* [Stable](https://en.wikipedia.org/wiki/Stable_distribution)\r\n* [Student-T](https://en.wikipedia.org/wiki/Student%27s_t-distribution)\r\n* [Weibull](https://en.wikipedia.org/wiki/Weibull_distribution)\r\n* [Triangular](https://en.wikipedia.org/wiki/Triangular_distribution)\r\n\r\n\u003C/div\u003E\r\n\u003Cdiv style=\u0022float: right; width: 50%;\u0022\u003E\r\n\r\n### Discrete Distributions\r\n\r\n* [Discrete Uniform](https://en.wikipedia.org/wiki/Uniform_distribution_%28discrete%29)\r\n* [Bernoulli](https://en.wikipedia.org/wiki/Bernoulli_distribution)\r\n* [Binomial](https://en.wikipedia.org/wiki/Binomial_distribution)\r\n* [Negative Binomial](https://en.wikipedia.org/wiki/Negative_binomial_distribution)\r\n* [Geometric](https://en.wikipedia.org/wiki/geometric_distribution)\r\n* [Hypergeometric](https://en.wikipedia.org/wiki/Hypergeometric_distribution)\r\n* [Poisson](https://en.wikipedia.org/wiki/Poisson_distribution)\r\n* [Categorical](https://en.wikipedia.org/wiki/Categorical_distribution)\r\n* [Conway-Maxwell-Poisson](https://en.wikipedia.org/wiki/Conway%E2%80%93Maxwell%E2%80%93Poisson_distribution)\r\n* [Zipf](https://en.wikipedia.org/wiki/Zipf%27s_law)\r\n\r\n### Multivariate Distributions\r\n\r\n* [Dirichlet](https://en.wikipedia.org/wiki/Dirichlet_distribution)\r\n* [Inverse Wishart](https://en.wikipedia.org/wiki/Inverse-Wishart_distribution)\r\n* [Matrix Normal](https://en.wikipedia.org/wiki/Matrix_normal_distribution)\r\n* [Multinomial](https://en.wikipedia.org/wiki/Multinomial_distribution)\r\n* [Normal Gamma](https://en.wikipedia.org/wiki/Normal-gamma_distribution)\r\n* [Wishart](https://en.wikipedia.org/wiki/Wishart_distribution)\r\n\r\n\u003C/div\u003E\r\n\u003C/div\u003E\r\n\r\n\r\nDistribution Parameters\r\n-----------------------\r\n\r\nThere are many ways to parametrize a distribution in the literature. When using the\r\ndefault constructor, read carefully which parameters it requires. For distributions where\r\nmultiple ways are common there are also static methods, so you can use the one that fits best.\r\nFor example, a normal distribution is usually parametrized with mean and standard deviation,\r\nbut if you\u0027d rather use mean and precision:\r\n\r\n    [lang=csharp]\r\n    var normal = Normal.WithMeanPrecision(0.0, 0.5);\r\n\r\nSince probability distributions can also be sampled to generate random numbers\r\nwith the configured distribution, all constructors optionally accept a random generator\r\nas last argument.\r\n\r\n    [lang=csharp]\r\n    var gamma2 = new Gamma(2.0, 1.5, new MersenneTwister());\r\n\r\n    // the random generator can also be replaced on an existing instance\r\n    gamma2.RandomSource = new Mrg32k3a();\r\n\r\nA few more examples, this time in F#:\r\n\r\n    [lang=fsharp]\r\n    // some probability distributions\r\n    let normal = Normal.WithMeanVariance(3.0, 1.5, a)\r\n    let exponential = Exponential(2.4)\r\n    let gamma = Gamma(2.0, 1.5, Random.crypto())\r\n    let cauchy = Cauchy(0.0, 1.0, Random.mrg32k3aWith 10 false)\r\n    let poisson = Poisson(3.0)\r\n    let geometric = Geometric(0.8, Random.system())\r\n\r\nSome of the distributions also have routines for maximum-likelihood parameter\r\nestimation from a set of samples:\r\n\r\n    [lang=fsharp]\r\n    let estimation = LogNormal.Estimate([| 2.0; 1.5; 2.1; 1.2; 3.0; 2.4; 1.8 |])\r\n    let mean, variance = estimation.Mean, estimation.Variance\r\n    let moreSamples = estimation.Samples() |\u003E Seq.take 10 |\u003E Seq.toArray\r\n\r\nor in C#:\r\n\r\n    [lang=csharp]\r\n    LogNormal estimation = LogNormal.Estimate(new [] {2.0, 1.5, 2.1, 1.2, 3.0, 2.4, 1.8});\r\n    double mean = estimation.Mean, variance = estimation.Variance;\r\n    double[] moreSamples = estimation.Samples().Take(10).ToArray();\r\n\r\n\r\nSampling a Probability Distribution\r\n-----------------------------------\r\n\r\nEach distribution provides methods to generate random numbers from that distribution.\r\nThese random variate generators work by accessing the distribution\u0027s member RandomSource\r\nto provide uniform random numbers. By default, this member is an instance of System.Random\r\nbut one can easily replace this with more sophisticated random number generators from\r\n\u0060MathNet.Numerics.Random\u0060 (see [Random Numbers](Random.html) for details).\r\n\r\n    [lang=fsharp]\r\n    // sample some random numbers from these distributions\r\n    // continuous distributions sample to floating-point numbers:\r\n    let continuous =\r\n      [ yield normal.Sample()\r\n        yield exponential.Sample()\r\n        yield! gamma.Samples() |\u003E Seq.take 10 ]\r\n\r\n    // discrete distributions on the other hand sample to integers:\r\n    let discrete =\r\n      [ poisson.Sample()\r\n        poisson.Sample()\r\n        geometric.Sample() ]\r\n\r\nInstead of creating a distribution object we can also sample directly with static functions.\r\nNote that no intermediate value caching is possible this way and parameters must be validated on each call.\r\n\r\n    [lang=fsharp]\r\n    // using the default number generator (SystemRandomSource.Default)\r\n    let w = Rayleigh.Sample(1.5)\r\n    let x = Hypergeometric.Sample(100, 20, 5)\r\n\r\n    // or by manually providing the uniform random number generator\r\n    let u = Normal.Sample(Random.system(), 2.0, 4.0)\r\n    let v = Laplace.Samples(Random.mersenneTwister(), 1.0, 3.0) |\u003E Seq.take 100 |\u003E List.ofSeq\r\n\r\nIf you need to sample not just one or two values but a large number of them,\r\nthere are routines that either fill an existing array or return an enumerable.\r\nThe variant that fills an array is generally the fastest. Routines to sample\r\nmore than one value use the plural form \u0060Samples\u0060 instead of \u0060Sample\u0060.\r\n\r\nLet\u0027s sample 100\u0027000 values from a laplace distribution with mean 1.0 and scale 2.0 in C#:\r\n\r\n    [lang=csharp]\r\n    var samples = new double[100000];\r\n    Laplace.Samples(samples, 1.0, 2.0);\r\n\r\nLet\u0027s do some random walks in F# (TODO: Graph):\r\n\r\n    [lang=fsharp]\r\n    Seq.scan (\u002B) 0.0 (Normal.Samples(0.0, 1.0)) |\u003E Seq.take 10 |\u003E Seq.toArray\r\n    Seq.scan (\u002B) 0.0 (Cauchy.Samples(0.0, 1.0)) |\u003E Seq.take 10 |\u003E Seq.toArray\r\n\r\n\r\nDistribution Functions and Properties\r\n-------------------------------------\r\n\r\nDistributions can not just be used to generate non-uniform random samples.\r\nOnce parametrized they can compute a variety of distribution properties\r\nor evaluate distribution functions. Because it is often numerically more stable\r\nand faster to compute and work with such quantities in the logarithmic domain,\r\nsome of them are also available with the \u0060Ln\u0060-suffix.\r\n\r\n    [lang=fsharp]\r\n    // distribution properties of the gamma we\u0027ve configured above\r\n    let gammaStats =\r\n      ( gamma.Mean,\r\n        gamma.Variance,\r\n        gamma.StdDev,\r\n        gamma.Entropy,\r\n        gamma.Skewness,\r\n        gamma.Mode )\r\n\r\n    // probability distribution functions of the normal we\u0027ve configured above.\r\n    let nd = normal.Density(4.0)  (* PDF *)\r\n    let ndLn = normal.DensityLn(4.0)  (* ln(PDF) *)\r\n    let nc = normal.CumulativeDistribution(4.0)  (* CDF *)\r\n    let nic = normal.InverseCumulativeDistribution(0.7)  (* CDF^(-1) *)\r\n\r\n    // Distribution functions can also be evaluated without creating an object,\r\n    // but then you have to pass in the distribution parameters as first arguments:\r\n    let nd2 = Normal.PDF(3.0, sqrt 1.5, 4.0)\r\n    let ndLn2 = Normal.PDFLn(3.0, sqrt 1.5, 4.0)\r\n    let nc2 = Normal.CDF(3.0, sqrt 1.5, 4.0)\r\n    let nic2 = Normal.InvCDF(3.0, sqrt 1.5, 0.7)\r\n\r\n\r\nComposing Distributions\r\n-----------------------\r\n\r\nSpecifically for F# there is also a \u0060Sample\u0060 module that allows a somewhat more functional\r\nview on distribution sampling functions by having the random source passed in as last argument.\r\nThis way they can be composed and transformed arbitrarily if curried:\r\n\r\n    [lang=fsharp]\r\n    /// Transform a sample from a distribution\r\n    let s1 rng = tanh (Sample.normal 2.0 0.5 rng)\r\n\r\n    /// But we really want to transform the function, not the resulting sample:\r\n    let s1f rng = Sample.map tanh (Sample.normal 2.0 0.5) rng\r\n\r\n    /// Exactly the same also works with functions generating full sequences\r\n    let s1s rng = Sample.mapSeq tanh (Sample.normalSeq 2.0 0.5) rng\r\n\r\n    /// Now with multiple distributions, e.g. their product:\r\n    let s2 rng = (Sample.normal 2.0 1.5 rng) * (Sample.cauchy 2.0 0.5 rng)\r\n    let s2f rng = Sample.map2 (*) (Sample.normal 2.0 1.5) (Sample.cauchy 2.0 0.5) rng\r\n    let s2s rng = Sample.mapSeq2 (*) (Sample.normalSeq 2.0 1.5) (Sample.cauchySeq 2.0 0.5) rng\r\n\r\n    // Taking some samples from the composed function\r\n    Seq.take 10 (s2s (Random.system())) |\u003E Seq.toArray\r\n"},{"uri":"https://numerics.mathdotnet.com/Random.html","title":"Pseudo-Random Numbers\r\n","content":"    [hide]\r\n    #I \u0022../../out/lib/net40\u0022\r\n    #r \u0022MathNet.Numerics.dll\u0022\r\n    #r \u0022MathNet.Numerics.FSharp.dll\u0022\r\n    open System.Numerics\r\n    open MathNet.Numerics\r\n    open MathNet.Numerics.Random\r\n    open MathNet.Numerics.Distributions\r\n\r\nPseudo-Random Numbers\r\n=====================\r\n\r\nThe .Net Framework base class library (BCL) includes a pseudo-random number generator\r\nfor non-cryptography use in the form of the \u0060System.Random\u0060 class.\r\nMath.NET Numerics provides a few alternatives with different characteristics\r\nin randomness, bias, sequence length, performance and thread-safety. All these classes\r\ninherit from \u0060System.Random\u0060 so you can use them as a drop-in replacement\r\neven in third-party code.\r\n\r\nAll random number generators (RNG) generate numbers in a uniform\r\ndistribution. In practice you often need to sample random numbers with a different\r\ndistribution, like a Gaussian or Poisson. You can do that with one of our probability\r\ndistribution classes, or in F# also using the \u0060Sample\u0060 module. Once parametrized,\r\nthe distribution classes also provide a variety of other functionality around probability\r\ndistributions, like evaluating statistical distribution properties or functions.\r\n\r\n\r\nInitialization\r\n--------------\r\n\r\nWe need to reference Math.NET Numerics and open the namespaces for\r\nrandom numbers and probability distributions:\r\n\r\n    [lang=csharp]\r\n    using MathNet.Numerics.Random;\r\n    using MathNet.Numerics.Distributions;\r\n\r\n\r\nGenerating Random Numbers\r\n-------------------------\r\n\r\nLet\u0027s sample a few random values from a uniform distributed variable\r\n$X\\sim\\mathcal{U}(0,1)$, such that $0 \\le x \u003C 1$:\r\n\r\n    [lang=csharp]\r\n    // create an array with 1000 random values\r\n    double[] samples = SystemRandomSource.Doubles(1000);\r\n\r\n    // now overwrite the existing array with new random values\r\n    SystemRandomSource.Doubles(samples);\r\n\r\n    // we can also create an infinite sequence of random values:\r\n    IEnumerable\u003Cdouble\u003E sampleSeq = SystemRandomSource.DoubleSequence();\r\n\r\n    // take a single random value\r\n    System.Random rng = SystemRandomSource.Default;\r\n    double sample = rng.NextDouble();\r\n    decimal sampled = rng.NextDecimal();\r\n\r\nIn F# we can do exactly the same, or alternatively use the \u0060Random\u0060 module:\r\n\r\n    [lang=fsharp]\r\n    let samples = Random.doubles 1000\r\n\r\n    // overwrite the whole array with new random values\r\n    Random.doubleFill samples\r\n\r\n    // create an infinite sequence:\r\n    let sampleSeq = Random.doubleSeq ()\r\n\r\n    // take a single random value\r\n    let rng = Random.shared\r\n    let sample = rng.NextDouble()\r\n    let sampled = rng.NextDecimal()\r\n\r\nIf you have used the .Net BCL random number generators before, you have likely\r\nnoticed a few differences: we used special routines to create a full array or\r\nsequence in one go, we were able to sample a decimal number, an we used static functions\r\nand a shared default instance instead of creating our own instance.\r\n\r\nMath.NET Numerics provides a few alternative random number generators in their own types.\r\nFor example, \u0060MersenneTwister\u0060 implements the very popular mersenne twister algorithm. All these types\r\ninherit from \u0060System.Random\u0060, are fully compatible to it and can also be used exactly the same way:\r\n\r\n    [lang=csharp]\r\n    System.Random random = new SystemRandomSource();\r\n    var sample = random.NextDouble();\r\n\r\nHowever, unlike System.Random they can be made thread safe, use much more reasonable\r\ndefault seeds and have some convenient extra routines. The \u0060SystemRandomSource\u0060 class that\r\nwas used above uses System.Random to generate random numbers internally - but with all the extras.\r\n\r\n\r\nFull Range Integers and Decimal\r\n-------------------------------\r\n\r\nOut of the box, \u0060System.Random\u0060 only provides \u0060Next\u0060 methods to sample integers\r\nin the [0, Int.MaxValue) range and \u0060NextDouble\u0060 for floating point numbers in the [0,1) interval.\r\nDid you ever have a need to generate numbers of the full integer range including negative numbers,\r\nor a \u0060System.Decimal\u0060? Extending discrete random numbers to different ranges or types is non-trivial\r\nif the distribution should still be uniform over the chosen range. That\u0027s why we\u0027ve added a few extensions\r\nmethods which are available on all RNGs (including System.Random itself):\r\n\r\n* **NextInt64** generates a 64 bit integer, uniform in the range [0, Long.MaxValue)\r\n* **NextDecimal** generates a \u0060System.Decimal\u0060, uniform in the range [0.0, 1.0)\r\n* **NextFullRangeInt32** generates a 32 bit integer, uniform in the range [Int.MinValue, Int.MaxValue]\r\n* **NextFullRangeInt64** generates a 64 bit integer, uniform in the range [Long.MinValue, Long.MaxValue]\r\n\r\n\r\nSeeds\r\n-----\r\n\r\nAll RNGs can be initialized with a custom seed number. The same seed causes\r\nthe same number sequence to be generated, which can be very useful if you need results\r\nto be reproducible, e.g. in testing/verification. The exception is cryptography,\r\nwhere reproducible random number sequences would be a fatal security flaw,\r\nso our crypto random source does not accept a seed.\r\n\r\nIn the code samples above we did not provide a seed, so a default seed was used.\r\nIf no seed is provided, \u0060System.Random\u0060 uses a time based seed equivalent to the\r\none below. This means that all instances created within a short time-frame\r\n(which typically spans about a thousand CPU clock cycles) will generate\r\nexactly the same sequence. This can happen easily e.g. in parallel computing\r\nand is often unwanted. That\u0027s why all Math.NET Numerics RNGs are by default\r\ninitialized with a robust seed taken from the \u0060CryptoRandomSource\u0060 if available,\r\nor else a combination of a random number from a shared RNG, the time and a Guid\r\n(which are supposed to be generated uniquely, worldwide).\r\n\r\n    [lang=fsharp]\r\n    let someTimeSeed = RandomSeed.Time() // not recommended\r\n    let someGuidSeed = RandomSeed.Guid()\r\n    let someRobustSeed = RandomSeed.Robust() // recommended, used by default\r\n\r\nLet\u0027s generate random numbers like before, but this time with custom seed 42:\r\n\r\n    [lang=fsharp]\r\n    let samplesSeeded = Random.doublesSeed 42 1000\r\n    Random.doubleFillSeed 42 samplesSeeded\r\n    let samplesSeqSeeded = Random.doubleSeqSeed 42\r\n\r\nOr without the F# Random module, e.g. in C#:\r\n\r\n    [lang=csharp]\r\n    double[] samplesSeeded = SystemRandomSource.Doubles(1000, 42);\r\n    SystemRandomSource.Doubles(samplesSeeded, 42);\r\n    IEnumerable\u003Cdouble\u003E sampleSeqSeeded = SystemRandomSource.DoubleSequence(42);\r\n\r\n\r\nUniform Random Number Generators\r\n--------------------------------\r\n\r\nUp to now we\u0027ve used only \u0060SystemRandomSource\u0060, but there\u0027s much more:\r\n\r\n* **SystemRandomSource**: Wraps the .NET System.Random to provide thread-safety\r\n* **CryptoRandomSource**: Wraps the .NET RNGCryptoServiceProvider. *Not available in portable builds.*\r\n* **MersenneTwister**: Mersenne Twister 19937 generator\r\n* **Xorshift**: Multiply-with-carry XOR-shift generator\r\n* **Mcg31m1**: Multiplicative congruential generator using a modulus of 2^31-1 and a multiplier of 1132489760\r\n* **Mcg59**: Multiplicative congruential generator using a modulus of 2^59 and a multiplier of 13^13\r\n* **WH1982**: Wichmann-Hill\u0027s 1982 combined multiplicative congruential generator\r\n* **WH2006**: Wichmann-Hill\u0027s 2006 combined multiplicative congruential generator\r\n* **Mrg32k3a**: 32-bit combined multiple recursive generator with 2 components of order 3\r\n* **Palf**: Parallel Additive Lagged Fibonacci generator\r\n\r\nLet\u0027s sample a few uniform random values using Mersenne Twister in C#:\r\n\r\n    [lang=csharp]\r\n    // Typical way with an instance:\r\n    var random = new MersenneTwister(42); // seed 42\r\n    int sampleInt = random.Next();\r\n    double sampleDouble = random.NextDouble();\r\n    decimal sampleDecimal = random.NextDecimal();\r\n    double[] samples = random.NextDoubles(1000);\r\n    IEnumerable\u003Cdouble\u003E sampleSeq = random.NextDoubleSequence();\r\n\r\n    // Simpler and faster if you need a large sequence, only once:\r\n    double[] samples = MersenneTwister.Doubles(1000, 42) // 1000 numbers, seed 42\r\n    IEnumerable\u003Cdouble\u003E sampleSeq = MersenneTwister.DoubleSequence(42); // seed 42\r\n\r\nIn F# you can use the constructor as well, or alternatively use the \u0060Random\u0060 module.\r\nIn case of the latter, all objects will be cast to their common base type \u0060System.Random\u0060:\r\n\r\n    [lang=fsharp]\r\n    // By using the normal constructor (random1 has type MersenneTwister) \r\n    let random1 = MersenneTwister()\r\n    let random1b = MersenneTwister(42) // with seed\r\n\r\n    // By using the Random module (random2 has type System.Random)\r\n    let random2 = Random.mersenneTwister ()\r\n    let random2b = Random.mersenneTwisterSeed 42 // with seed\r\n    let random2c = Random.mersenneTwisterWith 42 false // opt-out of thread-safety\r\n\r\n    // Using some other algorithms:\r\n    let random3 = Random.crypto ()\r\n    let random4 = Random.xorshift ()\r\n    let random5 = Random.wh2006 ()\r\n\r\n\r\nShared Instances and Thread Safety\r\n----------------------------------\r\n\r\nGenerators make certain claims about how many random numbers they can generate\r\nuntil the whole sequence repeats itself. However, this only applies if you\r\ncontinue to sample from the same instance and its internal state.\r\nThe generator instances should therefore be reused within an application if long\r\nrandom sequences are needed. If you\u0027d create a new instance each time, the numbers\r\nit generates would be exactly as random as your seed - and thus not very random at all.\r\n\r\nAnother reason to share instances: most generators run an initialization routine before\r\nthey can start generating numbers which can be expensive. Some of them also maintain\r\ntheir internal state in large memory blocks, which can quickly add up when creating multiple\r\ninstances.\r\n\r\nUnfortunately the two generators provided by .NET are not thread-safe and thus cannot be\r\nshared between threads without manual locking. But all the RNGs provided by Math.NET Numerics,\r\nincluding the \u0060SystemRandomSource\u0060 and \u0060CryptoRandomSource\u0060 wrappers, *are* thread-safe by default,\r\nunless explicitly disabled by a constructor argument or by setting \u0060Control.ThreadSafeRandomNumberGenerators\u0060\r\n(which is used if the constructor argument is omitted).\r\n\r\nFor convenience a few generators provide a thread-safe shared instance\r\n\r\n    [lang=csharp]\r\n    var a = SystemRandomSource.Default;\r\n    var b = MersenneTwister.Default;\r\n\r\nOr with the F# module:\r\n\r\n    [lang=fsharp]\r\n    let a = Random.systemShared\r\n    let b = Random.mersenneTwisterShared\r\n\r\n    // or if you don\u0027t care, simply\r\n    let c = Random.shared;\r\n\r\n\r\nNon-Uniform Random Numbers\r\n--------------------------\r\n\r\nFor non-uniform random number generation you can use the wide range of probability\r\ndistributions in the \u0060MathNet.Numerics.Distributions\u0060 namespace.\r\n\r\n    [lang=csharp]\r\n    using MathNet.Numerics.Distributions;\r\n\r\n    // sample a single value from a standard distribution\r\n    double a = Normal.Sample(0.0, 1.0);\r\n\r\n    // sample using a custom random number generator\r\n    double b = Normal.Sample(new MersenneTwister(), 0.0, 1.0);\r\n\r\n    // sample a large number of values in one go\r\n    double[] c = new double[100000];\r\n    Normal.Samples(c, 0.0, 1.0);\r\n\r\nSee [Probability Distributions](Probability.html) for details.\r\n"},{"uri":"https://numerics.mathdotnet.com/Regression.html","title":"Curve Fitting: Linear Regression\r\n","content":"    [hide]\r\n    #I \u0022../../out/lib/net40\u0022\r\n    #r \u0022MathNet.Numerics.dll\u0022\r\n    #r \u0022MathNet.Numerics.FSharp.dll\u0022\r\n    open System.Numerics\r\n    open MathNet.Numerics\r\n    open MathNet.Numerics.LinearRegression\r\n    open MathNet.Numerics.LinearAlgebra\r\n\r\nCurve Fitting: Linear Regression\r\n================================\r\n\r\nRegression is all about fitting a low order parametric model or curve to data, so we can\r\nreason about it or make predictions on points not covered by the data. Both data and\r\nmodel are known, but we\u0027d like to find the model parameters that make the model fit best\r\nor good enough to the data according to some metric.\r\n\r\nWe may also be interested in how well the model supports the data or whether we better\r\nlook for another more appropriate model.\r\n\r\nIn a regression, a lot of data is reduced and generalized into a few parameters.\r\nThe resulting model can obviously no longer reproduce all the original data exactly -\r\nif you need the data to be reproduced exactly, have a look at interpolation instead.\r\n\r\n\r\nSimple Regression: Fit to a Line\r\n--------------------------------\r\n\r\nIn the simplest yet still common form of regression we would like to fit a line\r\n$y : x \\mapsto a \u002B b x$ to a set of points $(x_j,y_j)$, where $x_j$ and $y_j$ are scalars.\r\nAssuming we have two double arrays for x and y, we can use \u0060Fit.Line\u0060 to evaluate the $a$ and $b$\r\nparameters of the least squares fit:\r\n\r\n    [lang=csharp]\r\n    double[] xdata = new double[] { 10, 20, 30 };\r\n    double[] ydata = new double[] { 15, 20, 25 };\r\n\r\n    Tuple\u003Cdouble, double\u003E p = Fit.Line(xdata, ydata);\r\n    double a = p.Item1; // == 10; intercept\r\n    double b = p.Item2; // == 0.5; slope\r\n\r\nOr in F#:\r\n\r\n    [lang=fsharp]\r\n    let a, b = Fit.Line ([|10.0;20.0;30.0|], [|15.0;20.0;25.0|])\r\n\r\nHow well do these parameters fit the data? The data points happen to be positioned\r\nexactly on a line. Indeed, the [coefficient of determination](https://en.wikipedia.org/wiki/Coefficient_of_determination)\r\nconfirms the perfect fit:\r\n\r\n    [lang=csharp]\r\n    GoodnessOfFit.RSquared(xdata.Select(x =\u003E a\u002Bb*x), ydata); // == 1.0\r\n\r\n\r\nLinear Model\r\n------------\r\n\r\nIn practice, a line is often not an adequate model. But if we can choose a model that is linear,\r\nwe can leverage the power of linear algebra; otherwise we have to resort to iterative methods\r\n(see Nonlinear Optimization).\r\n\r\nA linear model can be described as linear combination of $N$ arbitrary but known\r\nfunctions $f_i(x)$, scaled by the model parameters $p_i$. Note that none of the functions\r\n$f_i$ depends on any of the $p_i$ parameters.\r\n\r\n$$$\r\ny : x \\mapsto p_1 f_1(x) \u002B p_2 f_2(x) \u002B \\cdots \u002B p_N f_N(x)\r\n\r\nIf we have $M$ data points $(x_j,y_j)$, then we can write the regression problem as an\r\noverdefined system of $M$ equations:\r\n\r\n$$$\r\n\\begin{eqnarray}\r\n  y_1 \u0026=\u0026 p_1 f_1(x_1) \u002B p_2 f_2(x_1) \u002B \\cdots \u002B p_N f_N(x_1)  \\\\\r\n  y_2 \u0026=\u0026 p_1 f_1(x_2) \u002B p_2 f_2(x_2) \u002B \\cdots \u002B p_N f_N(x_2)  \\\\\r\n  \u0026\\vdots\u0026  \\\\\r\n  y_M \u0026=\u0026 p_1 f_1(x_M) \u002B p_2 f_2(x_M) \u002B \\cdots \u002B p_N f_N(x_M)\r\n\\end{eqnarray}\r\n\r\nOr in matrix notation with the predictor matrix $X$ and the response $y$:\r\n\r\n$$$\r\n\\begin{eqnarray}\r\n  \\mathbf y \u0026=\u0026 \\mathbf X \\mathbf p  \\\\\r\n  \\begin{bmatrix}y_1\\\\y_2\\\\ \\vdots \\\\y_M\\end{bmatrix} \u0026=\u0026\r\n  \\begin{bmatrix}f_1(x_1) \u0026 f_2(x_1) \u0026 \\cdots \u0026 f_N(x_1)\\\\f_1(x_2) \u0026 f_2(x_2) \u0026 \\cdots \u0026 f_N(x_2)\\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots\\\\f_1(x_M) \u0026 f_2(x_M) \u0026 \\cdots \u0026 f_N(x_M)\\end{bmatrix}\r\n  \\begin{bmatrix}p_1\\\\p_2\\\\ \\vdots \\\\p_N\\end{bmatrix}\r\n\\end{eqnarray}\r\n\r\nProvided the dataset is small enough, if transformed to the normal equation\r\n$\\mathbf{X}^T\\mathbf y = \\mathbf{X}^T\\mathbf X \\mathbf p$ this can be solved efficiently by the\r\nCholesky decomposition (do not use matrix inversion!).\r\n\r\n    [lang=csharp]\r\n    Vector\u003Cdouble\u003E p = MultipleRegression.NormalEquations(X, y);\r\n\r\nUsing normal equations is comparably fast as it can dramatically reduce the linear algebra problem\r\nto be solved, but that comes at the cost of less precision. If you need more precision, try using\r\n\u0060MultipleRegression.QR\u0060 or \u0060MultipleRegression.Svd\u0060 instead, with the same arguments.\r\n\r\n\r\nPolynomial Regression\r\n---------------------\r\n\r\nTo fit to a polynomial we can choose the following linear model with $f_i(x) := x^i$:\r\n\r\n$$$\r\ny : x \\mapsto p_0 \u002B p_1 x \u002B p_2 x^2 \u002B \\cdots \u002B p_N x^N\r\n\r\nThe predictor matrix of this model is the [Vandermonde matrix](https://en.wikipedia.org/wiki/Vandermonde_matrix).\r\nThere is a special function in the \u0060Fit\u0060 class for regressions to a polynomial,\r\nbut note that regression to high order polynomials is numerically problematic.\r\n\r\n    [lang=csharp]\r\n    double[] p = Fit.Polynomial(xdata, ydata, 3); // polynomial of order 3\r\n\r\n\r\nMultiple Regression\r\n-------------------\r\n\r\nThe $x$ in the linear model can also be a vector $\\mathbf x = [x^{(1)}\\; x^{(2)} \\cdots x^{(k)}]$\r\nand the arbitrary functions $f_i(\\mathbf x)$ can accept vectors instead of scalars.\r\n\r\nIf we use $f_i(\\mathbf x) := x^{(i)}$ and add an intercept term $f_0(\\mathbf x) := 1$\r\nwe end up at the simplest form of ordinary multiple regression:\r\n\r\n$$$\r\ny : x \\mapsto p_0 \u002B p_1 x^{(1)} \u002B p_2 x^{(2)} \u002B \\cdots \u002B p_N x^{(N)}\r\n\r\nFor example, for the data points $(\\mathbf{x}_j = [x^{(1)}_j\\; x^{(2)}_j], y_j)$ with values\r\n\u0060([1,4],15)\u0060, \u0060([2,5],20)\u0060 and \u0060([3,2],10)\u0060 we can evaluate the best fitting parameters with:\r\n\r\n    [lang=csharp]\r\n    double[] p = Fit.MultiDim(\r\n        new[] {new[] { 1.0, 4.0 }, new[] { 2.0, 5.0 }, new[] { 3.0, 2.0 }},\r\n        new[] { 15.0, 20, 10 },\r\n        intercept: true);\r\n\r\nThe \u0060Fit.MultiDim\u0060 routine uses normal equations, but you can always choose to explicitly use e.g.\r\nthe QR decomposition for more precision by using the \u0060MultipleRegression\u0060 class directly:\r\n\r\n    [lang=csharp]\r\n    double[] p = MultipleRegression.QR(\r\n        new[] {new[] { 1.0, 4.0 }, new[] { 2.0, 5.0 }, new[] { 3.0, 2.0 }},\r\n        new[] { 15.0, 20, 10 },\r\n        intercept: true);\r\n\r\n\r\nArbitrary Linear Combination\r\n----------------------------\r\n\r\nIn multiple regression, the functions $f_i(\\mathbf x)$ can also operate on the whole\r\nvector or mix its components arbitrarily and apply any functions on them, provided they are\r\ndefined at all the data points. For example, let\u0027s have a look at the following complicated but still linear\r\nmodel in two dimensions:\r\n\r\n$$$\r\nz : (x, y) \\mapsto p_0 \u002B p_1 \\mathrm{tanh}(x) \u002B p_2 \\psi(x y) \u002B p_3 x^y\r\n\r\nSince we map (x,y) to (z) we need to organize the tuples in two arrays:\r\n\r\n    [lang=csharp]\r\n    double[][] xy = new[] { new[]{x1,y1}, new[]{x2,y2}, new[]{x3,y3}, ...  };\r\n    double[] z = new[] { z1, z2, z3, ... };\r\n\r\nThen we can call Fit.LinearMultiDim with our model, which will return an array with the best fitting 4 parameters $p_0, p_1, p_2, p_3$:\r\n\r\n    [lang=csharp]\r\n    double[] p = Fit.LinearMultiDim(xy, z,\r\n        d =\u003E 1.0,                                  // p0*1.0\r\n        d =\u003E Math.Tanh(d[0]),                      // p1*tanh(x)\r\n        d =\u003E SpecialFunctions.DiGamma(d[0]*d[1]),  // p2*psi(x*y)\r\n        d =\u003E Math.Pow(d[0], d[1]));                // p3*x^y\r\n\r\n\r\nEvaluating the model at specific data points\r\n--------------------------------------------\r\n\r\nLet\u0027s say we have the following model:\r\n\r\n$$$\r\ny : x \\mapsto a \u002B b \\ln x\r\n\r\nFor this case we can use the \u0060Fit.LinearCombination\u0060 function:\r\n\r\n    [lang=csharp]\r\n    double[] p = Fit.LinearCombination(\r\n        new[] {61.0, 62.0, 63.0, 65.0},\r\n        new[] {3.6,3.8, 4.8, 4.1},\r\n        x =\u003E 1.0,\r\n        x =\u003E Math.Log(x)); // -34.481, 9.316\r\n\r\nIn order to evaluate the resulting model at specific data points we can manually apply\r\nthe values of p to the model function, or we can use an alternative function with the \u0060Func\u0060\r\nsuffix that returns a function instead of the model parameters. The returned function\r\ncan then be used to evaluate the parametrized model:\r\n\r\n    [lang=csharp]\r\n    Func\u003Cdouble,double\u003E f = Fit.LinearCombinationFunc(\r\n        new[] {61.0, 62.0, 63.0, 65.0},\r\n        new[] {3.6, 3.8, 4.8, 4.1},\r\n        x =\u003E 1.0,\r\n        x =\u003E Math.Log(x));\r\n    f(66.0); // 4.548\r\n\r\n\r\nLinearizing non-linear models by transformation\r\n-----------------------------------------------\r\n\r\nSometimes it is possible to transform a non-linear model into a linear one.\r\nFor example, the following power function\r\n\r\n$$$\r\nz : (x, y) \\mapsto u x^v y^w\r\n\r\ncan be transformed into the following linear model with $\\hat{z} = \\ln z$ and $t = \\ln u$\r\n\r\n$$$\r\n\\hat{z} : (x, y) \\mapsto t \u002B v \\ln x \u002B w \\ln y\r\n\r\n    [lang=csharp]\r\n    var xy = new[] {new[] { 1.0, 4.0 }, new[] { 2.0, 5.0 }, new[] { 3.0, 2.0 }};\r\n    var z = new[] { 15.0, 20, 10 };\r\n\r\n    var z_hat = z.Select(r =\u003E Math.Log(r)).ToArray(); // transform z_hat = ln(z)\r\n    double[] p_hat = Fit.LinearMultiDim(xy, z_hat,\r\n        d =\u003E 1.0,\r\n        d =\u003E Math.Log(d[0]),\r\n        d =\u003E Math.Log(d[1]));\r\n    double u = Math.Exp(p_hat[0]); // transform t = ln(u)\r\n    double v = p_hat[1];\r\n    double w = p_hat[2];\r\n\r\n\r\nWeighted Regression\r\n-------------------\r\n\r\nSometimes the regression error can be reduced by dampening specific data points.\r\nWe can achieve this by introducing a weight matrix $W$ into the normal equations\r\n$\\mathbf{X}^T\\mathbf{y} = \\mathbf{X}^T\\mathbf{X}\\mathbf{p}$. Such weight matrices\r\nare often diagonal, with a separate weight for each data point on the diagonal.\r\n\r\n$$$\r\n\\mathbf{X}^T\\mathbf{W}\\mathbf{y} = \\mathbf{X}^T\\mathbf{W}\\mathbf{X}\\mathbf{p}\r\n\r\n    [lang=csharp]\r\n    var p = WeightedRegression.Weighted(X,y,W);\r\n\r\nWeighter regression becomes interesting if we can adapt them to the point of interest\r\nand e.g. dampen all data points far away. Unfortunately this way the model parameters\r\nare dependent on the point of interest $t$.\r\n\r\n    [lang=csharp]\r\n    // warning: preliminary api\r\n    var p = WeightedRegression.Local(X,y,t,radius,kernel);\r\n\r\n\r\nRegularization\r\n--------------\r\n\r\n\r\nIterative Methods\r\n-----------------\r\n"},{"uri":"https://numerics.mathdotnet.com/ReleaseNotes-MKL.html","title":"MKL Provider Release Notes\r\n","content":"# MKL Provider Release Notes\r\n[Math.NET Numerics](ReleaseNotes.html) | [MKL Provider](ReleaseNotes-MKL.html) | [OpenBLAS Provider](ReleaseNotes-OpenBLAS.html)\r\n\r\n### 3.0.0-beta3 - 2022-02-19\r\n* Fix typo in the binary file name\r\n\r\n### 3.0.0-beta2 - 2021-12-29\r\n* New binary names and package structure with runtime folders\r\n\r\n### 2.6.0-beta3 - 2021-12-19\r\n* Experimental build with runtime folders for sdk projects\r\n\r\n### 2.6.0-beta2 - 2021-12-09\r\n* r15 with Intel oneAPI 2021.4, preview for Numerics v5 with MathNet.Numerics.Pro\r\n* Note that MathNet.Numerics.Providers.MKL.dll is required for this to work with Numerics v5\r\n\r\n### 2.5.0 - 2021-01-01\r\n* r14 with Intel MKL 2020 Update 4\r\n* MKL Direct Sparse Solver provider *~Jong Hyun Kim*\r\n\r\n### 2.4.0 - 2020-05-22\r\n* r13 with Intel MKL 2020.0 Update 1\r\n\r\n### 2.3.0 - 2018-02-14\r\n* r12 with Intel MKL 2018.0 Update 1\r\n\r\n### 2.2.0 - 2016-10-30\r\n* r11 with Intel MKL 2017.0\r\n* Vector Functions v0.1: vector power\r\n* Fourier Transforms v1.0: basic FFT support\r\n\r\n### 2.1.0 - 2016-09-08\r\n* r10 with Intel MKL 2017.0\r\n\r\n### 2.0.0 - 2015-09-26\r\n* r9 with Intel MKL 11.3\r\n* Linear Algebra v2.0: automatic work array/buffer handling (breaking change)\r\n\r\n### 1.8.0 - 2015-05-09\r\n* r8 with Intel MKL 11.2 Update 3\r\n* New combined NuGet package including both 32 and 64 bit builds and a proper build target (Win only)\r\n\r\n### 1.7.0 - 2014-12-31\r\n* r7 with Intel MKL 11.2 Update 1\r\n* memory functions *~Marcus Cuda*\r\n\r\n### 1.6.0 - 2014-06-21\r\n* r6 with Intel MKL 11.1 Update 3\r\n* capability to control max number of threads\r\n\r\n### 1.5.0 - 2014-06-15\r\n* With Intel MKL 11.1 Update 3\r\n\r\n### 1.4.0 - 2014-03-01\r\n* With Intel MKL 11.1 Update 2\r\n* Capability querying support\r\n"},{"uri":"https://numerics.mathdotnet.com/ReleaseNotes-OpenBLAS.html","title":"OpenBLAS Provider Release Notes\r\n","content":"# OpenBLAS Provider Release Notes\r\n[Math.NET Numerics](ReleaseNotes.html) | [MKL Provider](ReleaseNotes-MKL.html) | [OpenBLAS Provider](ReleaseNotes-OpenBLAS.html)\r\n\r\n### 0.3.0-beta1 - 2022-02-21\r\n* New binary names and package structure with runtime folders\r\n\r\n### 0.2.0 - 2015-09-26\r\n* Initial version\r\n"},{"uri":"https://numerics.mathdotnet.com/ReleaseNotes.html","title":"Math.NET Numerics Release Notes\r\n","content":"# Math.NET Numerics Release Notes\r\n[Math.NET Numerics](ReleaseNotes.html) | [MKL Provider](ReleaseNotes-MKL.html) | [OpenBLAS Provider](ReleaseNotes-OpenBLAS.html)\r\n\r\n### 5.0.0 - 2022-04-03\r\n* COMPATIBILITY: net5.0, net48 better supported with explicit builds\r\n* COMPATIBILITY: netstandard1.x, net40, net45 no longer supported\r\n* BREAKING: drop all which was marked as obsolete\r\n* BREAKING: all native provider adapters moved out to separate NuGet packages\r\n* BREAKING: switch many usages of tuples to value tuples (experimental)\r\n* Linear Algebra: Fix sparse inplace pointwise multiplication and division *~jkalias*\r\n* Distributions: Logistic *~Bobby Ingram*\r\n* Distributions: Perf: Cauchy avoid duplicate evaluation *~Febin*\r\n* Random: NextBigIngegerSequence *~Silver-Fang*\r\n* Random: xoshiro256StarStar fix out of range exception *~Charlie Turndorf*\r\n* Precision: Perf: pre-compute negative powers *~Febin*\r\n* Optimizations: Remove static properties in LevenbergMarquardtMinimizer *~Jong Hyun Kim*\r\n* Root Finding: Newton-Raphson better handling of zero-evaluations\r\n* Fit.Curve and FindMinimum extended to accept two more parameters\r\n* Fixed an index out of bounds issue when calculating BFGS minimizer with one variable *~Shiney*\r\n* Fixed Sparse COO NormalizeDuplicates *~Mohamed Moussa*\r\n* Marcum-Q and Log1p functions *~CHUTORO*\r\n* Series: stable series summation\r\n* Cubic Spline: Extrema and Stationary Points *~Eduardo Rojas*\r\n* Statistics: Weighted Descriptive and Running Statistics *~Richard Allen*\r\n* Providers: binary names and loading changes to follow conventions and better x-plat\r\n* Providers: drop managed reference linear algebra provider\r\n* Providers: native providers no longer inherit managed providers, managed now sealed\r\n* Providers: MKL provider compilation switched to Intel oneAPI MKL\r\n* Providers: support for provider packages with runtime folders\r\n* Better support for System.Text.Json: Polynomial, DescriptiveStatistics *~Joseph Petersen*\r\n* Lots of internal cleanup, leveraging newer language features\r\n* Data: now released always together with Numerics (no longer separate versioning)\r\n* Control.Describe now includes CPU architecture and family identifier if know\r\n\r\n### 4.15.0 - 2021-01-07\r\n* Precision: Round (with integer part rounding) *~Jon Larborn*\r\n* Precision: RoundToMultiple, RoundToPower\r\n* F#: BigRational.FromDecimal *~Brian Berns*\r\n\r\n### 4.14.0 - 2021-01-01\r\n* Optimization: Avoid losing precision in golden section minimizer *~Daniel Fox*\r\n* Interpolation: Monotone-preserving Piecewise Cubic Hermite Polynomial (PCHIP) *~Febin*\r\n* Linear Algebra: Sparse COO format fix handling if not sorted or with duplicates *~Jong Hyun Kim*\r\n* Linear Algebra: Matrix.Resize\r\n\r\n### 4.13.0 - 2020-12-30\r\n* Linear Algebra: sparse solver native provider *~Jong Hyun Kim*\r\n* Polynomial: fix handling of zero polynomials *~Jakub Bialogrodzki*\r\n* AppSwitches support to disable native providers or their probing\r\n\r\n### 4.12.0 - 2020-08-92\r\n* Linear Algebra: allow zero-length vectors and matrices *~Evangelink*\r\n* Distributions: Beta-Binomial Distribution *~Andrew Willshire*\r\n* Special Functions: Generalized Hypergeometric, Rising and Falling Factorials *~Andrew Willshire*\r\n* Tests now work in more cultures *~Amaury Leve*\r\n* No more string resources\r\n* A couple immutable structs marked as readonly\r\n\r\n### 4.11.0 - 2020-05-24\r\n* Distributions: Skewed Generalized T and Error distributions *~Mikael Ohman*\r\n* BUG: Linear Algebra: fix Moore-Penrose Pseudo-Inverse for complex matrices *~Alex Hildebrand*\r\n* BUG: Linear Algebra: fix range in non-square diagonal sparse mixed products\r\n\r\n### 4.10.0 - 2020-05-24\r\n* Fractional Calculus: Riemann-Liouville fractional derivative *~Jong Hyun Kim*\r\n* Root Finding: accuracy range validation *~Ryan Grange*\r\n* Root Finding: behavior more consistent between native and managed provider\r\n\r\n### 4.9.1 - 2020-04-12\r\n* BUG: Optimization: weights were applied wrongly when evaluating the Jacobian *~Jong Hyun Kim, zhaochenxi*\r\n* BUG: Linear Algebra: F# Matrix.reduceRows was reducing columns instead of rows *~kayanme*\r\n* BUG: Distributions: Hypergeometric.CDF no longer returns values \u003E 1.0 *~Manor Askenazi*\r\n* Documentation: fix missing logarithms, drop old links *~Michel de Ruiter, Guney Ozsan*\r\n* Build: no longer code-sign the assemblies with a code-signing certificate, since it is too painful.\r\n\r\n### 4.9.0 - 2019-10-13\r\n* Integration: Substitution for open intervals *~Jong Hyun Kim*\r\n* Integration: Gauss-Kronrod Quadrature *~Jong Hyun Kim*\r\n* Integration: Complex contour *~Jong Hyun Kim*\r\n* Distributions: Three parameter Burr (Type XII) *~Philip Gruber*\r\n* Distributions: Inverse Gaussian *~Philip Gruber*\r\n* Distributions: Truncated Pareto *~Philip Gruber*\r\n* Optimization: Detect early completion in BFGS-B minimizer *~Tom McTiernan*\r\n\r\n### 4.8.1 - 2019-06-12\r\n* Packaging fix - signed edition was not properly strong named.\r\n\r\n### 4.8.0 - 2019-06-02\r\n* Optimization: Levenberg-Marquardt, Trust-Region Dogleg *~Jong Hyun Kim*\r\n* Optimization: Nelder-Mead-Simplex: Improve convergence for symmetrical functions *~Erik Ovegard*\r\n* BUG: Optimization: Nelder-Mead-Simplex did not return the best evaluated point in some cases *~Eric Scott Salem*\r\n* Factorial: first 170 values now constant (data segment) instead of precomputed on first use *~Portalez Regis*\r\n* Window Functions: Tukey window *~Marco Ross*\r\n\r\n### 4.7.0 - 2018-11-11\r\n* Special Functions: Airy functions Ai, Bi *~Jong Hyun Kim*\r\n* Special Functions: Bessel functions of the first and second kind *~Jong Hyun Kim*\r\n* Special Functions: Modified Bessel functions of the first and second kind *~Jong Hyun Kim*\r\n* Special Functions: Spherical Bessel functions of the first and second kind *~Jong Hyun Kim*\r\n* Special Functions: Hankel functions of the first and second kind *~Jong Hyun Kim*\r\n* Special Functions: Kelvin functions of the first and second kind, and derivatives *~Jong Hyun Kim*\r\n* Linear Algebra: optimized sparse implementation of transpose-multiply *~Richard Reader*\r\n* Linear Algebra: optimized range checking in vectors and matrices\r\n\r\n### 4.6.0 - 2018-10-19\r\n* Polynomial: New Polynomial data structure *~Tobias Glaubach*\r\n* Statistics: Correlate.Auto auto correlation *~Tobias Glaubach*\r\n* Curve Fitting: Fit.Curve for non-linear least-squares fitting to an arbitray function\r\n\r\n### 4.5.1 - 2018-05-22\r\n* Signed NuGet packages\r\n\r\n### 4.5.0 - 2018-05-22\r\n* Random: New Xoshiro256StarStar random source *~Colin Green*\r\n\r\n### 4.4.1 - 2018-05-06\r\n* Build: strong-name edition .Signed NuGet packages are available again\r\n\r\n### 4.4.0 - 2018-02-25\r\n* Linear Algebra: managed provider performance improvements on basic vector arithmetics\r\n\r\n### 4.3.0 - 2018-02-24\r\n* FFT: migrate managed algorithms to provider, streamline implementation wiring, scaling logic.\r\n* FFT: obsoleted algorithm-specific functions like Radix2Forward, they use Forward internally until v5.\r\n* FFT: migrate \u0022naive\u0022 implementation to tests as reference implementation.\r\n* Build: fix NuGet packaging sucht that the included assemblies are really code-signed.\r\n\r\n### 4.2.0 - 2018-02-21\r\n* Native Providers: MklProvider and similar types now public (entry point for memory management, etc)\r\n* Native Providers: All providers now support freeing resources without unloading the provider\r\n* Native Providers: MKL provider sets consistency, precision and accuracy modes earlier to ensure they are applied\r\n* Native Providers: If a provider has been loaded successfully, skip any future loading attempts (faster switching)\r\n* Build: add .NET Framework 4.6.1 target (main package), switch to 4.6.1 for testing projects\r\n\r\n### 4.1.0 - 2018-02-19\r\n* Curve Fitting: Fit.Power, Fit.Exponential, Fit.Logarithm (similar to excel trend curves)\r\n\r\n### 4.0.0 - 2018-02-11\r\n* Explicit builds for .NET Framework 4.0 and higher and for .Net Standard 1.3 and 2.0\r\n* F#: explicit builds for .NET Framework 4.5 and higher and for .Net Standard 1.6 and 2.0\r\n* BREAKING: drop obsolete functionality (which has been marked as obsolete for a while)\r\n* BREAKING: drop support for .NET 3.5 and PCL profiles\r\n* BREAKING: F#: drop support for .NET 4.0 and PCL profiles\r\n* BREAKING: F#: depends on FSharp.Core 4.3.3\r\n* BREAKING: Native provider implementation types internal (but can be constructed explicitly)\r\n* BREAKING: Native provider control API moved from Control to per-provider Control classes\r\n* BREAKING: Linear Algebra: Vector.Map consistent with Matrix.Map, automatic fallback to inplace\r\n* BREAKING: Linear Algebra: Storage providers must always force all parameters (no defaults)\r\n* BREAKING: Statistics: Ranks and RankInplace of single precision now return single precision arrays\r\n* BUG: Ode Solver: fix typo in the Runge-Kutta solvers on time-step handling *~Ksero*\r\n* BUG: fix Matrix.GetHashCode for wide matrices *~mjmckp*\r\n* BUG: Distributions: BetaScaled no longer ignores optional random source parameter\r\n* BUG: Trigonometry: Complex trigonometric functions behave better on large imput *~diluculo*\r\n* BUG: Trigonometry: Fix imaginary part sign of complex hyperbolic cotangent\r\n* Control.Describe: human readable summary of the effective Math.NET Numerics configuration\r\n* Providers: Native Provider support in .NET Standard 2.0 (but not in 1.x).\r\n* Linear Algebra: F# vector/matrix functions to accept all #seq instead of lists only\r\n* Linear Algebra: Vector MapInplace implemented at storage level\r\n* Curve Fitting: Fit.LineThroughOrigin shortcut\r\n* Optimization: Limited-Memory BFGS *~Florian Wechsung*\r\n* Root Finding: Broyden: step size for calculating appox Jacobian, more robust step size formula *~Aappo Pulkkinen*\r\n* Statistics: Kernel Density Estimation *~Christoph Albert*\r\n* Statistics: GoodnessOfFit CoefficientOfDetermination *~Jon Smit*\r\n* Fixed a whole range of inline documentation typos, misc code quality fixes *~Jonas Nyrup*\r\n* Examples: moved to examples folder, new framework target integration project file examples\r\n* Benchmarks: builds for both net46 and netcoreapp2.0\r\n* Assemblies are now code-signed with an X.509 certificate, using SHA2-256 hashes\r\n\r\n### 4.0.0-beta07 - 2018-02-10\r\n* Curve Fitting: Fit.LineThroughOrigin shortcut\r\n* Build: Target FSharp.Core 4.3.3 (for better netstandard2.0 compatibility)\r\n* Build: use latest SDKs and runtimes, cleanups\r\n\r\n### 4.0.0-beta06 - 2018-02-03\r\n* Rework conditional compilation to simplify and increase the .NET Standard api surface\r\n* BREAKING: Native provider implementation types internal (but can be constructed explicitly)\r\n* BREAKING: Native provider control API moved from Control to per-provider Control classes\r\n* Control.Describe: human readable summary of the effective Math.NET Numerics configuration\r\n* Fixed a whole range of inline documentation typos *~Jonas Nyrup*\r\n* Build: reworked test build targets, switched to Paket magic mode\r\n* Examples: moved to examples folder, new framework target integration project file examples\r\n\r\n### 4.0.0-beta05 - 2018-01-22\r\n* BUG: Distributions: BetaScaled no longer ignores optional random source parameter\r\n* BUG: Trigonometry: Complex trigonometric functions behave on large imput *~diluculo*\r\n* All: code quality fixes *~Jonas Nyrup*\r\n\r\n### 4.0.0-beta04 - 2018-01-13\r\n* BREAKING: Linear Algebra: Vector.Map consistent with Matrix.Map, automatic fallback to inplace\r\n* BREAKING: Linear Algebra: Storage providers must always force all parameters (no defaults)\r\n* Linear Algebra: F# vector/matrix functions to accept all #seq instead of lists only\r\n* Linear Algebra: Vector MapInplace implemented at storage level\r\n\r\n### 4.0.0-beta03 - 2018-01-09\r\n* Optimization: Limited-Memory BFGS *~Florian Wechsung*\r\n* BUG: Trigonometry: Fix imaginary part sign of complex hyperbolic cotangent\r\n\r\n### 4.0.0-beta02 - 2018-01-07\r\n* Root Finding: Broyden: step size for calculating appox Jacobian, more robust step size formula *~Aappo Pulkkinen*\r\n* Statistics: Kernel Density Estimation *~Christoph Albert*\r\n\r\n### 4.0.0-beta01 - 2018-01-07\r\n* BREAKING: drop obsolete functionality (which has been marked as obsolete for a while)\r\n* BREAKING: drop support for .NET 3.5 and PCL profiles\r\n* BREAKING: F#: drop support for .NET 4.0 and PCL profiles\r\n* BREAKING: F#: depends on FSharp.Core 4.2.3\r\n* Explicit builds for .NET Framework 4.0 and higher and for .Net Standard 1.3 and 2.0\r\n* F#: explicit builds for .NET Framework 4.5 and higher and for .Net Standard 1.6 and 2.0\r\n* Assemblies are now code-signed with an X.509 certificate, using SHA2-256 hashes\r\n* BUG: Ode Solver: fix typo in the Runge-Kutta solvers on time-step handling *~Ksero*\r\n* BUG: fix Matrix.GetHashCode for wide matrices *~mjmckp*\r\n\r\n### 3.20.2 - 2018-01-22\r\n* Bugfixes backported from v4:\r\n* BUG: Distributions: BetaScaled no longer ignores optional random source parameter\r\n* BUG: Trigonometry: Complex trigonometric functions behave on large imput *~diluculo*\r\n\r\n### 3.20.1 - 2018-01-13\r\n* Bugfixes backported from v4:\r\n* BUG: Trigonometry: Fix imaginary part sign of complex hyperbolic cotangent\r\n* BUG: Ode Solver: fix typo in the Runge-Kutta solvers on time-step handling *~Ksero*\r\n* BUG: fix Matrix.GetHashCode for wide matrices *~mjmckp*\r\n\r\n### 3.20.0 - 2017-07-15\r\n* Optimization: non-linear optimization algorithms *~Scott Stephens, Erik Ovegard, bdodson, et al.*\r\n* Native Providers: from now on also supported in the .NET 3.5 build.\r\n* BUG: Special Functions: allow more iterations in BetaRegularized *~Elias Abou Jaoude*\r\n\r\n### 3.19.0 - 2017-04-29\r\n* Statistics: RunningStatistics.Combine to better handle empty statistics *~Lucas Godshalk*\r\n* Linear Algebra: Cholesky.Factorize to reuse the factorization matrix *~mjmckp*\r\n* Linear Algebra: Fix docs for DoPointwiseMultiply *~Jakub Arnold*\r\n\r\n### 3.18.0 - 2017-04-09\r\n* FFT: single-precision support *~AlexHild*\r\n\r\n### 3.17.0 - 2017-01-15\r\n* Random: random sources (all except crypto) now support ephemeral serialization.\r\n* Linear Algebra: explicit impl to copy a range of a row of a sparse matrix to a range of a sparse vector *~arthurvb*\r\n* Linear Algebra: explicitly demand fully modifiable matrix where needed, fixes issues with diagonal matrices.\r\n* FFT: leverage new matrix internal array access approach in 2D matrix transformations.\r\n\r\n### 3.16.0 - 2017-01-03\r\n* Root Finding: improve accuracy handling *~Konstantin Tretyakov*\r\n* Regression: GoodnessOfFit StandardError *~David Falkner*\r\n\r\n### 3.15.0 - 2016-12-27\r\n* FFT: MKL native provider backend.\r\n* FFT: 2D and multi-dimensional FFT (only supported by MKL provider, managed provider pending).\r\n* FFT: real conjugate-even FFT (only leveraging symmetry in MKL provider).\r\n* FFT: managed provider significantly faster on x64.\r\n* Linear Algebra: pointwise trigonometric and basic functions *~Albert Pang*\r\n* Linear Algebra: better support for F# built-in operators (sqrt, sin, exp, ..) *~Albert Pang*\r\n* Linear Algebra: pointwise power operator (F#)\r\n* Linear Algebra: enable experimental matrix product implementation\r\n* Linear Algebra: better support for matrix to/from row-major arrays and enumerables\r\n* Linear Algebra: transport allows specifying a result matrix to transpose into, inplace if square\r\n* Linear Algebra: vector and matrix AsArray and similar to access internal arrays if applicable\r\n* Linear Algebra: vector and matrix pointwise min/max and absmin/absmax\r\n* Linear Algebra: dot-power on vectors and matrices, supporting native providers.\r\n* Linear Algebra: matrix Moore-Penrose pseudo-inverse (SVD backed).\r\n* Provider Control: separate Control classes for LA and FFT Providers.\r\n* Provider Control: avoid internal exceptions on provider discovery.\r\n* Distributions: fix misleading inline docs on Negative-Binomial.\r\n* Generate: linear integer ranges\r\n* Root Finding: extend zero-crossing bracketing in derivative-free algorithms.\r\n* Window: periodic versions of Hamming, Hann, Cosine and Lanczos windows.\r\n* Special Functions: more robust GammaLowerRegularizedInv (and Gamma.InvCDF).\r\n* BUG: ODE Solver: fix bug in Runge-Kutta second order routine *~Ksero*\r\n\r\n### 3.13.1 - 2016-09-06\r\n* BUG: Random: Next(x,x\u002B1) must always return x *~Juri*\r\n\r\n### 3.13.0 - 2016-08-18\r\n* Linear Algebra: faster tall, wide managed matrix multiplication. *~Aixile*\r\n* Euclid: Integer Log2 (DeBruijn sequencences algorithm).\r\n* Integration: Gauss-Legendre documentation, cleanup. *~Larz White*\r\n* Random: Integer sub-range sampling to use rejection sampling to avoid bias.\r\n* Random: Improvements on integer and byte sampling.\r\n* BUG: Random: CryptoRandomSource must not generate 1.0 samples.\r\n* BUG: Statistics: fixed bug in WeightedPearson Correlation. *~Jon Smit*\r\n\r\n### 3.12.0 - 2016-07-03\r\n* ODE Solver: Runge-Kutta (order 2, 4) and Adams-Bashforth (order 1-4) algorithms *~Yoonku Hwang*\r\n* Linear Algebra: faster multiplication of sparse with dense matrices *~Arthur*\r\n* BUG: Integration: Gauss-Legendre on order 256 *~Sergey Kosukhin*\r\n* BUG: Distributions: ChiSquared sampling was taking a square root where it should not *~Florian Wechsung*\r\n\r\n### 3.11.1 - 2016-04-24\r\n* BUG: Linear Algebra: sparse vector pointwise multiply/divide to itself\r\n* BUG: Linear Algebra: Vector.ToVectorString if the first column is wider than maxWidth\r\n\r\n### 3.11.0 - 2016-02-13\r\n* Special Functions: error functions to use static coefficient arrays (perf) *~Joel Sleppy*\r\n* Integration: Gauss-Legendre Rule (1D, 2D) *~Larz White*\r\n* Complex: more robust magnitude and division for numbers close to MaxValue or Epsilon *~MaLiN2223*\r\n* Native Providers: lazy default provider discovery \u0026 initialization *~Kuan Bartel*\r\n* FSharp Package: Quaternion type *~Phil Cleveland*\r\n\r\n### 3.10.0 - 2015-12-30\r\n* Statistics: single-precision floating point support.\r\n* Statistics: very limited support for int32 and complex numbers.\r\n* Statistics: Min/Max Absolute, MagnitudePhase (complex).\r\n* Statistics: FiveNumberSummary to use actual Median instead of R8 quantile.\r\n* Linear Algebra: matrix Rank to use relative epsilon.\r\n* Linear Algebra: extensions to convert between single/double precision, complex/real.\r\n* Linear Algebra: Vector/Matrix storage DataContracts for ephemeral serialization.\r\n* Regression: more helpful exceptions and messages.\r\n* Random: \u0027Next\u0027 integer sampling no longer involves floating points, avoids one-off error in MersenneTwister.\r\n* Precision: EpsilonOf for single-precision numbers, drop no longer needed portable fallbacks.\r\n\r\n### 3.9.0 - 2015-11-25\r\n* Distributions: Normal.CDF avoids problematic subtraction by using Erfc instead of Erf.\r\n* Statistics: geometric and harmonic mean.\r\n* Statistics: DataContracts for ephemeral serialization on RunningStatistics, DescriptiveStatistics and Histogram.\r\n* BUG: Statistics: Histogram did not adjust lower bound correctly when value was equal to the bound *~Volker Breuer*\r\n* Linear Algebra: minor optimization on how we call Array.Copy.\r\n* BUG: Linear Algebra: fix bug in Complex and Complex32 SparseMatrix.ToTypeString.\r\n\r\n### 3.8.0 - 2015-09-26\r\n* Distributions: PDF and CDF more robust for large distribution parameters.\r\n* Distributions: BetaScaled distribution.\r\n* Distributions: method to create a PERT distribution (based on BetaScaled) *~John C Barstow*\r\n* Distributions: Weibull.Estimate *~Jon Larborn*\r\n* Random: NextBoolean extensions.\r\n* Root Finding: RootFinding.Secant (based on NewtonRaphson) *~grovesNL*\r\n* Linear Algebra: Matrix Rank calculation now uses a tolerance based on the matrix size.\r\n* Linear Algebra: Alternative CreateMatrix/Vector functions with type parameter on functions instead of type.\r\n* Linear Algebra: MKL LinearAlgebra provider requires at least native provider r9 (linear algebra v2.0).\r\n* Native Providers: automatic handling of intermediate work arrays/buffers in MKL and OpenBLAS providers *~Marcus Cuda, Kuan Bartel*\r\n* Native Providers: automatically use native provider if available.\r\n* Native Providers: new Control.TryUse* to make it simpler to use providers if available but without failing if not.\r\n* Native Providers: improved error state checking and handling *~Marcus Cuda, Kuan Bartel*\r\n* Combinatorics: generate or select random permutation, combination or variation (shuffling)\r\n* Finance: rename CompoundMonthlyReturn to CompoundReturn (old now obsolete).\r\n\r\n### 3.7.1 - 2015-09-10\r\n* BUG: Linear Algebra: fix optimized path of adding a sparse matrix to itself.\r\n\r\n### 3.7.0 - 2015-05-09\r\n* Statistics: RunningStatistics now propagates min/max on Combine, handles NaN on Push.\r\n* Statistics: new MovingStatistics providing descriptive statistics over a moving window *~Marcus Cuda*\r\n* Statistics: new Statistics.MovingAverage.\r\n* Statistics: Improved Histogram handling of small-width buckets *~Justin Needham*\r\n* Distributions: ChiSquare.InvCDF *~logophobia*\r\n* FFT: Fourier.FrequencyScale to generate the frequency corresponding to each index in frequency space.\r\n* BUG: FFT: fix Bluestein algorithm for sequences with more than 46341 samples but not power-of-two.\r\n* Linear Algebra: SparseVector.AbsoluteMaximumIndex *~Matt Heffron*\r\n* MKL Native Provider: OSX build script *~Marcus Cuda*\r\n* MKL Native Provider: new combined NuGet package with a proper build target (no more manual file handling needed).\r\n* OpenBLAS Native Provider: a new linear algebra provider using OpenBLAS *~Kuan Bartel*\r\n* CUDA Native Provider: a new GPU-based linear algebra provider using Nvidia CUDA *~Matthew A. Johnson*\r\n* Native Providers: now versioned separately for each kind (MKL, CUDA, OpenBLAS).\r\n\r\n### 3.6.0 - 2015-03-22\r\n* Distributions: ChiSquare.CDF more robust for large numbers *~Baltazar Bieniek*\r\n* Linear Algebra: MatrixStorage.Map2 equivalent to VectorStorage.Map2\r\n* Linear Algebra: Matrix and Vector Find/Find2, Exists/Exists2, ForAll/ForAll2\r\n* Linear Algebra: more consistent range checking in MatrixStorage.Clear and related\r\n* Linear Algebra: mixed-storage fall back implementations now leverage higher-order functions\r\n* BUG: Linear Algebra: fix loop range in MatrixStorage.ClearColumns (built-in storage not affected)\r\n* BUG: Linear Algebra: fix sparse matrix equality.\r\n* BUG: Linear Algebra: ArgumentException instead of index exception when trying to create an empty matrix.\r\n* Generate: Unfold, Fibonacci; Normal and Standard replacing Gaussian and Stable.\r\n* Native Providers: NativeProviderLoader to automatically load the provider for the matching processor architecture (x86, x64) *~Kuan Bartel*\r\n* Native Providers: Control.NativeProviderPath allowing to explicitly declare where to load binaries from.\r\n* MKL Native Provider: support for native complex eigen-value decomposition *~Marcus Cuda*\r\n* MKL Native Provider: non-convergence checks in singular-value and eigen-value decompositions *~Marcus Cuda*\r\n\r\n### 3.5.0 - 2015-01-10\r\n* Differentiation: derivative, partial and mixed partial; hessian \u0026 jacobian *~Hythem Sidky*\r\n* Differentiation: Differentiate facade class for simple use cases\r\n* Differentiation: F# module for better F# function support.\r\n* Linear Algebra: matrix ToRowArrays/ToColumnArrays\r\n* Linear Algebra: F# insertRow, appendRow, prependRow and same also for columns\r\n* Linear Algebra: F# append, stack and ofMatrixList2\r\n* Precision: measured machine epsilon, positive vs negative epsilon\r\n\r\n### 3.4.0 - 2015-01-04\r\n* Special Functions: Generalized Exponential Integral *~Ashley Messer*\r\n* Special Functions: Regularized Incomplete Gamma domain extended to a=0 *~Ashley Messer*\r\n* Statistics: weighted Pearson correlation *~ViK*\r\n* MKL Native Provider: memory functions to free buffers and gather usage statistics *~Marcus Cuda*\r\n* F#: depend on new official FSharp.Core NuGet package instead of FSharp.Core.Microsoft.Signed\r\n* F#: simpler NuGet package dependencies (no more need for framework groups)\r\n* Build: vagrant bootstrap now uses the latest xamarin mono packages\r\n\r\n### 3.3.0 - 2014-11-26\r\n* Linear Algebra: Vector.Fold2 (fold2 in F#), storage optimized\r\n* Linear Algebra: Minor change how matrix products call the LA provider\r\n* Linear Algebra: Random generation now leveraging array sampling routines\r\n* BUG: Linear Algebra: fix bug when manually assigning System.Random to random distribution\r\n* Root Finding: Change Brent tolerance check, add bracket check *~Hythen Sidky*\r\n* Root Finding: Auto zero-crossing bracketing in FindRoots facade (not in algorithms)\r\n* Statistics: RootMeanSquare (RMS)\r\n* Distributions: Array sampling routines now available through interface\r\n* Distributions: Categorical sampling now explicitly skips p=0 categories\r\n* Generate: leverage array sampling routines for random data generation\r\n* Generate: square, triangle and sawtooth waves\r\n* Distance: Jaccard Index\r\n* F#: explicitly depend on official FSharp.Core NuGet packages\r\n* F#: NuGet package with iPython IfSharp F# module integration load script\r\n* F#: load scripts with better packet support (and NuGet with -ExcludeVersion)\r\n* Build: unified build.sh and buildn.sh into combined build.sh\r\n* Build: use Paket instead of NuGet to maintain NuGet dependencies\r\n* Build: for core add PCL profiles 7, 78 and 259; for F# extensions drop PCL profile 328\r\n\r\n### 3.2.3 - 2014-09-06\r\n* BUG: MatrixNormal distribution: fix density for non-square matrices *~Evelina Gabasova*\r\n\r\n### 3.2.2 - 2014-09-05\r\n* BUG: MatrixNormal distribution: density computation switched row and column covariance *~Evelina Gabasova*\r\n\r\n### 3.2.1 - 2014-08-05\r\n* Package fix: make sure .NET 3.5-only dependencies are not installed on .Net 4 and newer.\r\n\r\n### 3.2.0 - 2014-08-05\r\n* Linear Algebra: Vector.Map2 (map2 in F#), storage-optimized\r\n* Linear Algebra: fix RemoveColumn/Row early index bound check (was not strict enough)\r\n* Statistics: Entropy *~Jeff Mastry*\r\n* Interpolation: use Array.BinarySearch instead of local implementation *~Candy Chiu*\r\n* Resources: fix a corrupted exception message string\r\n* Portable Build: support .NET 4.0 as well by using profile 328 instead of 344.\r\n* .NET 3.5: F# extensions now support .Net 3.5 as well\r\n* .NET 3.5: NuGet package now contains proper 3.5-only TPL package dependency; also in Zip package\r\n\r\n### 3.1.0 - 2014-07-20\r\n* Random: generate a sequence of integers within a range in one go\r\n* Distributions: all distributions must have static routines to sample an array in one go\r\n* Linear Algebra: fix Matrix.StrictlyLowerTriangle\r\n* Linear Algebra: fix vector DoOuterProduct *~mjmckp*\r\n* Linear Algebra: enumerators accept Zeros-parameter (like map/fold already does)\r\n* Linear Algebra: Vector.MapConvert (consistency)\r\n* Linear Algebra: proper term for \u0027conjugate symmetric\u0027 is \u0027Hermitian\u0027\r\n* Interpolation: new Step, LogLinear and transformed interpolators *~Candy Chiu*\r\n* Interpolation: check for min required number of data points, throw ArgumentException if not.\r\n* Root Finding: F# FindRoots.broyden module function *~teramonagi*\r\n* Misc docs fixes\r\n\r\n### 3.0.2 - 2014-06-26\r\n* BUG: fixing a bug in Matrix.RemoveRow range checks.\r\n\r\n### 3.0.1 - 2014-06-24\r\n* BUG: fixing a bug in new Matrix.ToMatrixString and Vector.ToVectorString routines.\r\n\r\n### 3.0.0 - 2014-06-21\r\n* First stable v3 release:\r\n   * [Upgrade Notes](https://github.com/mathnet/mathnet-numerics/wiki/Upgrading-to-Version-3)\r\n   * Stable API, no more breaking changes for all future v3 releases (except previews).\r\n   * Finally unlocks development and contributions around non-linear optimization and native providers over the next few minor releases.\r\n* Native Providers: option to control max number of threads used by MKL.\r\n* F#: Fit.multiDim; Matrix.qr, svd, eigen, lu and cholesky.\r\n\r\n### 3.0.0-beta05 - 2014-06-20\r\n* 2nd Candidate for v3.0 Release\r\n* BUG: Distance: fix bug in Hamming distance that skipped the first pair.\r\n* F#: packages now include a MathNet.Numerics.fsx script that includes FSI printers and references the assemblies.\r\n* Linear Algebra: improved matrix and vector ToString formatting, more compact, adaptive to actual numbers.\r\n* Linear Algebra: CoerceZero for matrix and vector to replace small numbers with zero.\r\n* Regression: DirectRegressionMethod option to specify as argument which direct method should be used.\r\n* Control: drop MaxToStringRows/Columns properties (no longer used)\r\n* Random: clarify bad randomness properties of SystemRandomSource.FastDoubles (trade off)\r\n\r\n### 3.0.0-beta04 - 2014-06-16\r\n* Candidate for v3.0 Release\r\n* Linear Algebra:\r\n   * FoldRows renamed to FoldByRow, now operates on and returns arrays; same for columns. **Breaking.**\r\n   * New FoldRows and ReduceRows that operate on row vectors; same for columns\r\n   * Split Map into Map and MapConvert (allows optimization in common in-place case)\r\n   * Row and column sums and absolute-sums\r\n   * F# DiagonalMatrix module to create diagonal matrices without using the builder\r\n   * F# Matrix module extended with sumRows, sumAbsRows, normRows; same for columns\r\n* Build: extend build and release automation, automatic releases also for data extensions and native providers\r\n\r\n### 3.0.0-beta03 - 2014-06-05\r\n* Linear Algebra: vector outer product now follows common style, supports explicit result argument, more efficient.\r\n* Interpolation: must not modify/sort original data; alternative Sorted and Inplace functions.\r\n* Distributions: static IsValidParameterSet functions.\r\n* Distributions: all distributions are now immutable in their distribution parameters. **Breaking.**\r\n* NuGet: attempt to create proper symbol\u002Bsource packages on symbolsource; primary packages smaller, w/o pdbs\r\n* Build: skip long tests with new \u0022quick\u0022 argument (FAKE)\r\n* Build: clearing is more explicit, fixes most locking issues if solution is also open in IDE.\r\n* Build: automated publishing docs, api, git release tag (maintainer)\r\n\r\n### 3.0.0-beta02 - 2014-05-29\r\n* Linear Algebra:\r\n   * optimized sparse-sparse and sparse-diagonal matrix products. *~Christian Woltering*\r\n   * transpose at storage level, optimized sparse transpose. *~Christian Woltering*\r\n   * optimized inplace-map, indexed submatrix-map.\r\n   * optimized clearing a set of rows or columns.\r\n   * matrix FoldRows/FoldColumns.\r\n   * matrix column/row norms, normalization.\r\n   * prefer enums over boolean parameters (e.g. \u0060Zeros.AllowSkip\u0060).\r\n   * IsSymmetric is now a method, add IsConjugateSymmetric. **Breaking.**\r\n   * Eigenvalue decomposition can optionally skip symmetry test.\r\n   * Direct diagonal-scalar division implementation\r\n* Test Functions: Rosenbrock, Rastrigin, DropWave, Ackley, Bohachevsky, Matyas, SixHumpCamel, Himmelblau\r\n* Statistics: DescriptiveStatistics support for larger datasets.\r\n* MKL: native providers must not require MFC to compile.\r\n* Sorting helpers support sub-range sorting, use insertion sort on very small sets.\r\n* Build: extend usage of FAKE, automate docs, api, Zip and NuGet package generation.\r\n* Portable: replace PCL profile 136 with profile 344, support for WP8.1\r\n* Xamarin: prepare for better Xamarin Android/iOS support and for adding to the Xamarin store (free).\r\n* Misc code style fixes.\r\n* Update Vagrant setup to official Ubuntu 14.04 LTS box and proper apt-style Mono\u002BF# provisioning.\r\n\r\n### 3.0.0-beta01 - 2014-04-01\r\n* See also: [Roadmap](https://sdrv.ms/17wPFlW) and [Towards Math.NET Numerics Version 3](https://christoph.ruegg.name/blog/towards-mathnet-numerics-v3.html).\r\n* **Major release with breaking changes**\r\n* All obsolete code has been removed\r\n* Reworked redundancies, inconsistencies and unfortunate past design choices.\r\n* Significant namespace simplifications (-30%).\r\n* Linear Algebra:\r\n   * Favor and optimize for generic types, e.g. \u0060Vector\u003Cdouble\u003E\u0060.\r\n   * Drop the \u0060.Generic\u0060 in the namespaces and flattened solver namespaces.\r\n   * F#: all functions in the modules now fully generic, including the \u0060matrix\u0060 function.\r\n   * F#: \u0060SkipZeros\u0060 instead of the cryptic \u0060nz\u0060 suffix for clarity.\r\n   * Add missing scalar-matrix routines.\r\n   * Optimized mixed dense-diagonal and diagonal-dense operations (500x faster on 250k set).\r\n   * More reasonable choice of return structure on mixed operations (e.g. dense\u002Bdiagonal).\r\n   * Add point-wise infix operators \u0060.*\u0060, \u0060./\u0060, \u0060.%\u0060 where supported (F#)\r\n   * Vectors explicitly provide proper L1, L2 and L-infinity norms.\r\n   * All norms return the result as double (instead of the specific value type of the matrix/vector).\r\n   * Matrix L-infinity norm now cache-optimized (8-10x faster).\r\n   * Vectors have a \u0060ConjugateDotProduct\u0060 in addition to \u0060DotProduct\u0060.\r\n   * \u0060Matrix.ConjugateTransposeAndMultiply\u0060 and variants.\r\n   * Matrix Factorization types fully generic, easily accessed by new \u0060Matrix\u003CT\u003E\u0060 member methods (replacing the extension methods). Discrete implementations no longer visible.\r\n   * QR factorization is thin by default.\r\n   * Matrix factorizations no longer clone their results at point of access.\r\n   * Add direct factorization-based \u0060Solve\u0060 methods to matrix type.\r\n   * Massive iterative solver implementation/design simplification, now mostly generic and a bit more functional-style.\r\n   * Renamed iterative solver stop criteria from \u0027criterium\u0027 to \u0027criterion\u0027.\r\n   * New MILU(0) iterative solver preconditioner that is much more efficient and fully leverages sparse data. *~Christian Woltering*\r\n   * Matrices/Vectors now have more consistent enumerators, with a variant that skips zeros (useful if sparse).\r\n   * Matrix/Vector creation routines have been simplified and usually no longer require explicit dimensions. New variants to create diagonal matrices, or such where all fields have the same value. All functions that take a params array now have an overload accepting an enumerable (e.g. \u0060OfColumnVectors\u0060).\r\n   * Generic Matrix/Vector creation using builders, e.g. \u0060Matrix\u003Cdouble\u003E.Build.DenseOfEnumerable(...)\u0060\r\n   * Create a matrix from a 2D-array of matrices (top-left aligned within the grid).\r\n   * Create a matrix or vector with the same structural type as an example (\u0060.Build.SameAs(...)\u0060)\r\n   * Removed non-static Matrix/Vector.CreateMatrix/CreateVector routines (no longer needed)\r\n   * Add Vector.OfArray (copying the array, consistent with Matrix.OfArray - you can still use the dense vector constructor if you want to use the array directly without copying).\r\n   * More convenient and one more powerful overload of \u0060Matrix.SetSubMatrix\u0060.\r\n   * Matrices/Vectors expose whether storage is dense with a new IsDense property.\r\n   * Various minor performance work.\r\n   * Matrix.ClearSubMatrix no longer throws on 0 or negative col/row count (nop)\r\n   * BUG: Fix bug in routine to copy a vector into a sub-row of a matrix.\r\n   * Both canonical modulus and remainder operations on matrices and vectors.\r\n   * Matrix kernel (null space) and range (column space)\r\n   * Storage-aware non-inplace functional map on vectors and matrices\r\n   * Pointwise power, exponential and natural logarithm for vectors and matrices.\r\n   * Matrix positive-integer power\r\n   * Matrix RemoveRow/RemoveColumn; more efficient InsertRow/InsertColumn\r\n* Native Linear Algebra/Intel MKL:\r\n   * Thin QR factorization uses MKL if enabled for all types (previously just \u0060double\u0060)\r\n   * Sparse matrix CSR storage format now uses the much more common row pointer convention and is fully compatible with MKL (so there is nothing in the way to add native provider support).\r\n   * Providers have been moved to a \u0060Providers\u0060 namespace and are fully generic again.\r\n   * Simpler provider usage: \u0060Control.UseNativeMKL()\u0060, \u0060Control.UseManaged()\u0060.\r\n   * MKL native provider now supports capability querying (so we can extend it much more reliably without breaking your code).\r\n   * MKL native provider consistency, precision and accuracy now configurable (trade-off).\r\n   * Native Provider development has been reintegrated into the main repository; we can now directly run all unit tests against local native provider builds. Covered by FAKE builds.\r\n* Statistics:\r\n   * Pearson and Spearman correlation matrix of a set of arrays.\r\n   * Spearman ranked correlation optimized (4x faster on 100k set)\r\n   * Skewness and PopulationSkewness; Kurtosis and PopulationKurtosis.\r\n   * Single-pass \u0060MeanVariance\u0060 and \u0060MeanStandardDeviation\u0060 methods (often used together).\r\n   * Some overloads for single-precision values.\r\n   * Add \u0060Ranks\u0060, \u0060QuantileRank\u0060 and \u0060EmpiricalCDF\u0060.\r\n   * F# module for higher order functions.\r\n   * Median direct implementation (instead of R8-compatible 0.5-quantile)\r\n   * New RunningStatistics that can be updated and merged\r\n   * BUG: DescriptiveStatistics must return NaN if not enough data for a specific statistic.\r\n* Probability Distributions:\r\n   * Direct static distributions functions (PDF, CDF, sometimes also InvCDF).\r\n   * Direct static sample functions, including such to fill an existing array in one call.\r\n   * New Trigangular distribution *~Superbest, David Prince*\r\n   * Add InvCDF to Gamma, Student-T, FisherSnedecor (F), and Beta distributions.\r\n   * Major API cleanup, including xml docs\r\n   * Xml doc and ToString now use well-known symbols for the parameters.\r\n   * Maximum-likelihood parameter estimation for a couple distributions.\r\n   * All constructors now optionally accept a random source as last argument.\r\n   * Use less problematic RNG-seeds by default, if no random source is provided.\r\n   * Simpler and more composable random sampling from distributions.\r\n   * Much more distribution\u0027s actual sample distribution is verified in tests (all continuous, most discrete).\r\n   * Binomial.CDF now properly leverages BetaRegularized.\r\n   * BUG: Fix hyper-geometric CDF semantics, clarify distribution parameters.\r\n   * BUG: Fix Zipf CDF at x=1.\r\n   * BUG: Fix Geometric distribution sampling.\r\n   * BUG: Fix Categorical distribution properties. *~David Prince*\r\n* Random Numbers:\r\n   * All RNGs provide static Sample(values) functions to fill an existing array.\r\n   * Thread-safe System.Random available again as \u0060SystemRandomSource\u0060.\r\n   * Fast and simple to use static \u0060SystemRandomSource.Doubles\u0060 routine with lower randomness guarantees.\r\n   * Shared \u0060SystemRandomSource.Default\u0060 and \u0060MersenneTwister.Default\u0060 instances to skip expensive initialization.\r\n   * Using thread-safe random source by default in distributions, Generate, linear algebra etc.\r\n   * Tests always use seeded RNGs for reproducability.\r\n   * F#: direct sampling routines in the \u0060Random\u0060 module, also including default and shared instances.\r\n* Linear Regression:\r\n   * Reworked \u0060Fit\u0060 class, supporting more simple scenarios.\r\n   * New \u0060.LinearRegression\u0060 namespace with more options.\r\n   * Better support for simple regression in multiple dimensions.\r\n   * Goodness of Fit: R, RSquared *~Ethar Alali*\r\n   * Weighted polynomial and multi-dim fitting.\r\n   * Use more efficient LA routines *~Thomas Ibel*\r\n* Interpolation:\r\n   * Return tuples instead of out parameter.\r\n   * Reworked splines, drop complicated and limiting inheritance design. More functional approach.\r\n   * More efficient implementation for non-cubic splines (especially linear spline).\r\n   * \u0060Differentiate2\u0060 instead of \u0060DifferentiateAll\u0060.\r\n   * Definite \u0060Integrate(a,b)\u0060 in addition to existing indefinite \u0060Integrate(t)\u0060.\r\n   * Use more common names in \u0060Interpolate\u0060 facade, e.g. \u0022Spline\u0022 is a well known name.\r\n* Root Finding: Chebychev polynomial roots.\r\n* Root Finding: Cubic polynomials roots. *~Candy Chiu*\r\n* Trig functions: common short names instead of very long names. Add sinc function.\r\n* Excel functions: TDIST, TINV, BETADIST, BETAINV, GAMMADIST, GAMMAINV, NORMDIST, NORMINV, NORMSDIST, NORMSINV QUARTILE, PERCENTILE, PERCENTRANK.\r\n* Special functions: BetaRegularized more robust for large arguments.\r\n* Special functions: new \u0060GammaLowerRegularizedInv\u0060.\r\n* New distance functions in \u0060Distance\u0060: euclidean, manhattan, chebychev distance of arrays or generic vectors. SAD, MAE, SSD, MSE metrics. Pearson\u0027s, Canberra and Minkowski distance. Hamming distance.\r\n* Windows: ported windowing functions from Neodym (Hamming, Hann, Cosine, Lanczos, Gauss, Blackmann, Bartlett, ...)\r\n* BigInteger factorial\r\n* Build:\r\n   * FAKE-based build (in addition to existing Visual Studio solutions) to clean, build, test, document and package independently of the CI server.\r\n   * Finally proper documentation using FSharp.Formatting with sources included in the repository so it is versioned and can be contributed to with pull requests.\r\n   * NuGet packages now also include the PCL portable profile 47 (.NET 4.5, Silverlight 5, Windows 8) in addition to the normal .Net 4.0 build and PCL profile 136 (.Net 4.0, WindowsPhone 8, Silverlight 5, Windows 8) as before. Profile 47 uses \u0060System.Numerics\u0060 for complex numbers, among others, which is not available in profile 136.\r\n   * NuGet packages now also include a .NET 3.5 build of the core library.\r\n   * IO libraries have been removed, replaced with new \u0060.Data\u0060 packages (see list on top).\r\n   * Alternative strong-named versions of more NuGet packages (mostly the F# extensions for now), with the \u0060.Signed\u0060 suffix.\r\n   * Reworked solution structure so it works in both Visual Studio 11 (2012) and 12 (2013).\r\n   * We can now run the full unit test suite against the portable builds as well.\r\n   * Builds should now also work properly on recent Mono on Linux (including F# projects).\r\n   * Fixed builds on platforms with case sensitive file systems. *~Gauthier Segay*\r\n* Integration: simplification of the double-exponential transformation api design.\r\n* FFT: converted to static class design and shorter names for simpler usage. Drop now redundant \u0060Transform\u0060 class.\r\n* Generate: ported synthetic data generation and sampling routines from Neodym (includes all from old Signals namespace). F# module for higher order functions.\r\n* Euclid: modulus vs remainder (also BigInteger), integer theory (includes all from old NumberTheory namespace).\r\n* Complex: common short names for Exp, Ln, Log10, Log.\r\n* Complex: fix issue where a *negative zero* may flip the sign in special cases (like \u0060Atanh(2)\u0060, where incidentally MATLAB and Mathematica do not agree on the sign either).\r\n* Complex: routines to return all two square and three cubic roots of a complex number.\r\n* Complex: More robust complex Asin/Acos for large real numbers.\r\n* Evaluate: routine to evaluate complex polynomials, or real polynomials at a complex point.\r\n* CommonParallel now also supported in .NET 3.5 and portable profiles; TaskScheduler can be replaced with custom implementation *~Thomas Ibel*\r\n* F# BigRational type cleaned up and optimized *~Jack Pappas*\r\n* F# BigRational IsZero, IsOne, IsInteger, create from fraction.\r\n* F# BigRational Reciprocal, Power operator support (**), support for negative integer powers.\r\n* F# functions now use the clearer \u0060Func\u0060 suffix instead of just \u0060F\u0060 if they return a function.\r\n* Precision: reworked, now much more consistent. **If you use \u0060AlmostEqual\u0060 with numbers-between/ULP semantics, please do review your code to make sure you\u0027re still using the expected variant!**. If you use the decimal-places semantics, you may need to decrement the digits argument to get the same behavior as before.\r\n* Much less null checks, our code generally only throws \u0060ArgumentNullException\u0060 if an unexpected null argument would *not* have caused an immediate \u0060NullReferenceException\u0060.\r\n* Cases where \u0060ArgumentOutOfRangeExceptions\u0060 where thrown with wrong arguments (i.e. no parameter name) now throw \u0060ArgumentException\u0060 instead.\r\n* Tests now have category attributes (to selectively run or skip categories).\r\n\r\n### 2.6.2 - 2013-10-21\r\n* Patch release, fixing the NuGet package to work better in WindowsPhone 8 projects. Assemblies are not changed.\r\n\r\n### 2.6.1 - 2013-08-13\r\n* BUG: fixing a bug in \u0060ArrayStatistics.Variance\u0060 on arrays longer than 46341 entries.\r\n\r\n### 2.6.0 - 2013-07-26\r\n* See also: [What\u0027s New in Math.NET Numerics 2.6](https://christoph.ruegg.name/blog/new-in-mathnet-numerics-2-6.html)\r\n* Linear Curve Fitting: Linear least-squares fitting (regression) to lines, polynomials and linear combinations of arbitrary functions. Multi-dimensional fitting. Also works well in F# with the F# extensions.\r\n* Root Finding:\r\n   * Brent\u0027s method. *~Candy Chiu, Alexander T\u00E4schner*\r\n   * Bisection method. *~Scott Stephens, Alexander T\u00E4schner*\r\n   * Broyden\u0027s method, for multi-dimensional functions. *~Alexander T\u00E4schner*\r\n   * Newton-Raphson method.\r\n   * Robust Newton-Raphson variant that tries to recover automatically in cases where it would fail or converge too slowly. This modification makes it more robust e.g. in the presence of singularities and less sensitive to the search range/interval.\r\n   * All algorithms support a TryFind-pattern which returns success instead of throwing an exception.\r\n   * Special case for quadratic functions, in the future to be extended e.g. to polynomials.\r\n   * Basic bracketing algorithm\r\n   * Also works well in F# with the F# extensions.\r\n* Linear Algebra:\r\n   * Native eigenvalue decomposition (EVD) support with our MKL packages *~Marcus Cuda*\r\n   * Add missing scalar-vector operations (s-v, s/v, s%v) *~Thomas Ibel*\r\n   * Support for new F# 3.1 row/column slicing syntax on matrices\r\n   * Matrices learned proper OfColumn/RowVectors, analog also in F#.\r\n   * Documentation Fixes *~Robin Neatherway*\r\n   * BUG: Fixed exception text message when creating a matrix from enumerables (rows vs columns) *~Thomas Ibel*\r\n   * We\u0027re phasing out MathNet.Numerics.IO that used to be included in the main package for matrix file I/O for text and Matlab formats. Use the new .Data.Text and .Data.Matlab packages instead.\r\n* Statistics: Spearman Rank Correlation Coefficient *~Iain McDonald*\r\n* Statistics: Covariance function, in Array-, Streaming- and common Statistics.\r\n* Distributions: Categorical: distribution more consistent, no longer requires normalized pdf/cdf parameters\r\n* Distributions: Categorical: inverse CDF function *~Paul Varkey*\r\n* BUG: Distributions: Fixed static sampling methods of the \u0060Stable\u0060 distribution. *~Artyom Baranovskiy*\r\n* BUG: Fixed a bug in the Gamma Regularized special function where in some cases with large values it returned 1 instead of 0 and vice versa.\r\n* The F# extensions now have a strong name in (and only in) the signed package as well (previously had not been signed). *~Gauthier Segay*\r\n* Evaluate.Polynomial with new overload which is easier to use.\r\n* Fixed a couple badly designed unit tests that failed on Mono.\r\n* Repository now Vagrant-ready for easy testing against recent Mono on Debian.\r\n\r\n### 2.5.0 - 2013-04-14\r\n* See also: [What\u0027s New in Math.NET Numerics 2.5](https://christoph.ruegg.name/blog/new-in-mathnet-numerics-2-5.html)\r\n* Statistics: Empty statistics now return NaN instead of either 0 or throwing an exception. *This may break code in case you relied upon the previous unusual and inconsistent behavior.*\r\n* Linear Algebra: More reasonable ToString behavior for matrices and vectors. *This may break code if you relied upon ToString to export your full data to text form intended to be parsed again later. Note that the classes in the MathNet.Numerics.IO library are more appropriate for storing and loading data.*\r\n* Statistics:\r\n   * More consistent behavior for empty and single-element data sets: Min, Max, Mean, Variance, Standard Deviation etc. no longer throw exceptions if the data set is empty but instead return NaN. Variance and Standard Deviation will also return NaN if the set contains only a single entry. Population Variance and Population Standard Deviation will return 0 in this case.\r\n   * Reworked order statistics (Quantile, Quartile, Percentile, IQR, Fivenum, etc.), now much easier to use and supporting compatibility with all 9 R-types, Excel and Mathematica. The obsolete Percentile class now leverages the new order statistics, fixing a range check bug as side effect.\r\n   * New Hybrid Monte Carlo sampler for multivariate distributions. *~manyue*\r\n   * New financial statistics: absolute risk and return measures. *~Phil Cleveland*\r\n   * Explicit statistics for sorted arrays, unsorted arrays and sequences/streams. Faster algorithms on sorted data, also avoids multiple enumerations.\r\n   * Some statistics like Quantile or empirical inverse CDF can optionally return a parametric function when multiple evaluations are needed, like for plotting.\r\n* Linear Algebra:\r\n   * More reasonable ToString behavior for matrices and vectors: \u0060ToString\u0060 methods no longer render the whole structure to a string for large data, among others because they used to wreak havoc in debugging and interactive scenarios like F# FSI. Instead, ToString now only renders an excerpt of the data, together with a line about dimension, type and in case of sparse data a sparseness indicator. The intention is to give a good idea about the data in a visually useful way. How much data is shown can be adjusted in the Control class. See also ToTypeString and ToVector/MatrixString.\r\n   * Performance: reworked and tuned common parallelization. Some operations are up to 3 magnitudes faster in some extreme cases. Replaced copy loops with native routines. More algorithms are storage-aware (and should thus perform better especially on sparse data). *~Thomas Ibel, Iain McDonald, Marcus Cuda*\r\n   * Fixed range checks in the Thin-QR decomposition. *~Marcus Cuda*\r\n   * BUG: Fixed bug in Gram Schmidt for solving tall matrices. *~Marcus Cuda*\r\n   * Vectors now implement the BCL IList interfaces (fixed-length) for better integration with existing .NET code. *~Scott Stephens*\r\n   * Matrix/Vector parsing has been updated to be able to parse the new visual format as well (see ToMatrixString).\r\n   * DebuggerDisplay attributes for matrices and vectors.\r\n   * Map/IndexedMap combinators with storage-aware and partially parallelized implementations for both dense and sparse data.\r\n   * Reworked Matrix/Vector construction from arrays, enumerables, indexed enumerables, nested enumerables or by providing an init function/lambda. Non-obsolete constructors now always use the raw data array directly without copying, while static functions always return a matrix/vector independent of the provided data source.\r\n   * F#: Improved extensions for matrix and vector construction: create, zeroCreate, randomCreate, init, ofArray2, ofRows/ofRowsList, ofColumns/ofColumnsList, ofSeqi/Listi (indexed). Storage-aware for performance.\r\n   * F#: Updated map/mapi and other combinators to leverage core implementation, added -nz variants where zero-values may be skipped (relevant mostly for sparse matrices).\r\n   * F#: Idiomatic slice setters for sub-matrices and sub-vectors\r\n   * F#: More examples for matrix/vector creation and linear regression in the F# Sample-package.\r\n* Control: Simpler usage with new static ConfigureAuto and ConfigureSingleThread methods. Resolved misleading configuration logic and naming around disabling parallelization.\r\n* Control: New settings for linear algebra ToString behavior.\r\n* Fixed range check in the Xor-shift pseudo-RNG.\r\n* Parallelization: Reworked our common logic to avoid expensive lambda calls in inner loops. Tunable.\r\n* F#: Examples (and thus the NuGet Sample package) are now F# scripts prepared for experimenting interactively in FSI, instead of normal F# files. Tries to get the assembly references right for most users, both within the Math.NET Numerics solution and the NuGet package.\r\n* Various minor improvements on consistency, performance, tests, xml docs, obsolete attributes, redundant code, argument checks, resources, cleanup, nuget, etc.\r\n\r\n### 2.4.0 - 2013-02-03\r\n* Drops the dependency on the zlib library. We thus no longer have any dependencies on other packages. *~Marcus Cuda, Thomas Ibel*\r\n* Adds Modified Bessel \u0026 Struve special functions *~Wei Wu*\r\n* BUG: Fixes a bug in our iterative kurtosis statistics formula *~Artyom Baranovskiy*\r\n* Linear Algebra: Performance work, this time mostly around accessing matrix rows/columns as vectors. Opting out from targeted patching in our matrix and vector indexers to allow inlining.\r\n* Linear Algebra: Fixes an issue around Thin-QR solve *~Marcus Cuda*\r\n* Linear Algebra: Simplifications around using native linear algebra providers (see Math.NET Numerics With Native Linear Algebra)\r\n* F#: Adds the BigRational module from the F# PowerPack, now to be maintained here instead. *~Gustavo Guerra*\r\n* F#: Better support for our Complex types (close to the F# PowerPack Complex type) *~Gustavo Guerra*\r\n\r\n### 2.3.0 - 2013-11-25\r\n* Portable Library: Adds support for WP8 (.NET 4.0 and higher, SL5, WP8 and .NET for Windows Store apps)\r\n* Portable Library: New: portable build also for F# extensions (.NET 4.5, SL5 and .NET for Windows Store apps)\r\n* Portable Library: NuGet: portable builds are now included in the main packages, no more need for special portable packages\r\n* Linear Algebra: Continued major storage rework, in this release focusing on vectors (previous release was on matrices)\r\n* Linear Algebra: Thin QR decomposition (in addition to existing full QR)\r\n* Linear Algebra: Static CreateRandom for all dense matrix and vector types\r\n* Linear Algebra: F#: slicing support for matrices and vectors\r\n* Distributions: Consistent static Sample methods for all continuous and discrete distributions (was previously missing on a few)\r\n* F#: better usability for random numbers and distributions.\r\n* F# extensions are now using F# 3.0\r\n* Updated Intel MKL references for our native linear algebra providers\r\n* Various bug, performance and usability fixes\r\n"},{"uri":"https://numerics.mathdotnet.com/Users.html","title":"Who is using Math.NET Numerics?\r\n","content":"Who is using Math.NET Numerics?\r\n===============================\r\n\r\n*This page collects anything that references and/or uses Math.NET Numerics.\r\nFeel free to [add, edit or remove your own work](https://github.com/mathnet/mathnet-numerics/blob/master/docs/content/Users.md) by submitting a pull request.*\r\n\r\nOpen Source\r\n-----------\r\n\r\n* [MyMediaLite Recommender System Library](https://www.ismll.uni-hildesheim.de/mymedialite/)\r\n* [FermiSim, studying potential solutions to the Fermi paradox via computational simulation of models for space colonisation](https://launchpad.net/fermisim)\r\n* [Three-Dimensional Model Shape Description and Retrieval Based on LightField Descriptors](https://code.google.com/p/lightfieldretrieval/)\r\n* [Virtual Photonics Technology Initiative](https://virtualphotonics.codeplex.com/)\r\n* [SharpFE: a lightweight, expandable finite element solver for .net](https://github.com/iainsproat/SharpFE)\r\n* [FsLab: Machine Learning and Data Science with F#](https://fslab.org/)\r\n* [Simple FM Matrix](https://cs.mcgill.ca/~ryang6/simplefmmatrix/)\r\n* [mathlib.net](https://mathlibproject.codeplex.com/)\r\n* [PhysicsPad](https://github.com/Amichai/PhysicsPad)\r\n* [DRFCSharp: Discriminative Random Fields implementation for C#](https://github.com/exitmouse/drfcsharp)\r\n* [SharpBench: Benchmarking system for Mono/.Net](https://github.com/ranma42/SharpBench)\r\n* [Behavioral Rating of Dancing Human Crowds based on Motion Patterns](https://emotiondetection.codeplex.com/)\r\n* [NPSS Framework for numerical computations of Laguerre series](https://www.openhub.net/p/npss)\r\n* [FIRST Robotics Scout App](https://frcscout.codeplex.com/)\r\n* [Improvisation: Automatic Music Composition and Melody Generation](https://github.com/ArmenAg/Improvisation)\r\n* [Epicycle Math Library](https://github.com/open-epicycle/Epicycle.Math-cs)\r\n* [LitePlacer machine user interface and control software](https://github.com/jkuusama/LitePlacer)\r\n* [Computator.NET](https://github.com/PawelTroka/Computator.NET)\r\n* [EV2020: Project Electric Transportation 2020](https://github.com/EraYaN/EV202)\r\n* [HexLight GUI: RGB LED controller](https://github.com/jorticus/hexlight-gui)\r\n* [HydroNumerics](https://code.google.com/archive/p/hydronumerics/)\r\n* [SolidWorks to URDF Exporter](https://bitbucket.org/brawner/sw2urdf)\r\n* [Reinforcement Simulator](https://github.com/lg-octaviano/Reinforcement_Simulator)\r\n* [Maintenance Game](https://github.com/KaptenJon/MaintenanceGame)\r\n* [Monica](https://github.com/zhuazhua/Monica)\r\n* [Math.Net PowerShell](https://mathnetpowershell.codeplex.com/) (unaffiliated)\r\n* [Math.NET Symbolics](https://symbolics.mathdotnet.com) and other [Math.NET](https://www.mathdotnet.com) projects.\r\n\r\nClosed Source\r\n-------------\r\n\r\n* [C# Pad](https://www.csharppad.com)\r\n* [Colectica](https://www.colectica.com) Data Documentation\r\n* [Instarange Simulation](https://instarange.com) by Instarange (Pty) Ltd\r\n* [SpectraFox](https://www.spectrafox.com/) STM / AFM spectroscopy analysis\r\n* [Colymp](https://colymp.com/) Color Management Software\r\n* [ILNumerics](https://ilnumerics.net/)\r\n* [GazeSpeaker](https://www.gazespeaker.org) Free software to help people with disabilities\r\n* [ModVal.org](https://www.modval.org) Quant model repository for regulatory and internal model validation.\r\n* [Passivefilter](https://sites.google.com/site/passivefilter/home) Filter synthesis\r\n* [Qunatellia](https://www.quantellia.com) World Modeler\r\n* [Umberto NXT](https://www.umberto.de) Carbon footprint, resource efficiency, life-cycle assessment, eco-efficiency.\r\n* Agilent Waveform Creator: [Easily create custom Waveform plug-ins with Waveform Creator application software](https://cp.literature.agilent.com/litweb/pdf/5991-3203EN.pdf) (PDF)\r\n* Multiple medical hearing care companies\r\n\r\nBlogs, Tutorials \u0026 Examples\r\n---------------------------\r\n\r\n* [Yin Zhu: Tutorial: Using Math.NET Numerics in F#](https://msdn.microsoft.com/en-us/library/hh304363.aspx)\r\n* [Don Syme: Getting Started with Math.NET and F# Programming](https://blogs.msdn.com/b/dsyme/archive/2012/07/06/getting-started-with-math-net-and-f-programming.aspx)\r\n* [Libor Tinka: Linear and Nonlinear Least-Squares with Math.NET](https://www.imagingshop.com/articles/least-squares)\r\n* [Carl Nolan: Co-occurrence Approach to an Item Based Recommender](https://code.msdn.microsoft.com/Co-occurrence-Approach-to-57027db7)\r\n* [Gustavo Guerra: F# as a Octave/Matlab Replacement for Machine Learning](https://functionalflow.co.uk/blog/2011/10/27/f-as-a-octavematlab-replacement-for-machine-learning/)\r\n* [Mathias Brandewinder: Simplify data with SVD and Math.NET in F#](https://clear-lines.com/blog/post/Simplify-data-with-SVD-and-MathNET-in-FSharp.aspx)\r\n* [Mathias Brandewinder: Recommendation Engine using Math.NET, SVD and F#](https://clear-lines.com/blog/post/Recommendation-Engine-with-SVD-and-MathNET-in-FSharp.aspx)\r\n* [Thomas Jungblut: Stochastic Logistic Regression in F#](https://codingwiththomas.blogspot.ch/2014/05/stochastic-logistic-regression-in-f.html)\r\n* [Calvin Bottoms: Set-Based Operations: They\u2019re Not Just For Databases](https://calvinbottoms.blogspot.ch/2012/01/set-based-operations-theyre-not-just.html)\r\n* [Chao-Jen Chen: F#: Simulate entire GBM path](https://programmingcradle.blogspot.ch/2012/09/f-simulate-entire-gbm-path.html)\r\n* [Chao-Jen Chen: F#: K-S test on final prices of GBM paths ](https://programmingcradle.blogspot.ch/2012/09/f-k-s-test-on-final-prices-of-gbm-paths.html)\r\n* [Dawid Kowalski: F#, Deedle and Computational Investing](https://dkowalski.com/blog/archive/2014/01/11/f-deedle-and-computational-investing.aspx)\r\n* [Jason Fossen: PowerShell for Math.NET Numerics](https://cyber-defense.sans.org/blog/2015/06/27/powershell-for-math-net-numerics)\r\n* [Jason Fossen: TrueRNG Random Numbers with PowerShell and Math.NET Numerics](https://cyber-defense.sans.org/blog/2015/07/24/truerng-usb-random-numbers-powershell-mathnet-numerics)\r\n* [Thomasz Jaskula: Data Science tools in F# through univariante linear regression](https://jaskula.fr/blog/2015/12-02-data-science-tools-in-f-through-univariante-linear-regression/)\r\n* [Christoph R\u00FCegg: Linear Regression With Math.NET Numerics](https://christoph.ruegg.name/blog/linear-regression-mathnet-numerics.html)\r\n\r\nBooks\r\n-----\r\n\r\n* Expert F# 3.0 *by Don Syme, Adam Granicz, Antonio Cisternino*. Apress.\r\n* F# for Quantitative Finance *by Johan Astborg*. Packt Publishing.\r\n* F# Deep Dives *by Tomas Petricek, Philip Trelford*. Manning Publications.\r\n* Computer Graphics: Principles and Practices *by John F. Hughes, Andries van Dam, Morgan McGuire, David F. Sklar, James D. Foley, Steven K. Feiner, Kurt Akeley*. Addison-Wesley Professional, 3rd edition.\r\n* Machine Learning Projects for .NET Developers *by Matthias Brandewinder*. Apress.\r\n* C# for Financial Markets *by Daniel J. Duffy, Andrea Germani*. Wiley Finance.\r\n\r\nPapers and Thesis\r\n-----------------\r\n\r\n* Dalchau, Neil; Grant, Paul K.; Vaidyanathan, Prashant; Spaccasassi, Carlo; Gravill, Colin; Phillips, Andrew (2019). *Scalable dynamic characterization of synthetic gene circuits.* Microsoft Research. DOI 10.1101/635672.\r\n* Gao, Peichao; Cushman, Samuel A.; Liu, Gang; Ye, Sijing; Shen, Shi; Cheng, Changxiu (2019). *FracL: A Tool for Characterizing the Fractality of Landscape Gradients from a New Perspective.* MDPI Iternationa Journal of Geo-Information. DOI 10.3390/ijgi8100466.\r\n* Vlasenko, Alexander; Vlasenko, Nataliia; Vynokurova, Olena; Bodyanskiy, Yevgeniy; Peleshko, Dmytro (2019). *A Novel Ensemble Neuro-Fuzzy Model for Financial Time Series Forecasting.* MDPI data. DOI 10.3390/data4030126.\r\n* Falke, Martin; H\u00F6glund, Lucas (2019). *Implementing gaze tracking with a simple web camera.* KTH School of Electrical Engineering and Computer Science, Stockholm.\r\n* Rottsch\u00E4fer, Marcus Philip (2019). *Simultaneous Visual Analysis of Multidimensional Data and Attributes.* Institute for Visualization and Interactive Systems, University of Stuttgart.\r\n* Azimov, R., Grigorev, S. (2019). *Path Querying with Conjunctive Grammars by Matrix Multiplication.* Program Comput Soft 45, 357\u2013364. DOI 10.1134/S0361768819070041\r\n* Honfi, D., Micskei, Z. (2019). *Classifying generated white-box tests: an exploratory study.* Software Qual J 27, 1339\u20131380. DOI 10.1007/s11219-019-09446-5.\r\n* Sowa, Marcin (2018). *A Harmonic Balance Methodology for Circuits with Fractional and Nonlinear Elements.* Circuits Syst Signal Process 37:4695\u20134727. DOI 10.1007/s00034-018-0794-8.\r\n* Schaffranek, Richard (2015). *Parallel planning - An experimental study in spectral graph matching.* Vienna University of Technology. Proceedings of the 10th International Space Syntax Symposium.\r\n* De Feber, Max (2017). *Real-time numerical modeling of subsea cable dynamics - Visualized in Augmented Reality.* Offshore \u0026 Dredging Engineering, Delft University of Technology.\r\n* Nkurikiyeyezu, K.; Ahishakiye, F.; Nsengimana, C.; Ntagwirumugara, E. (2015). *Toolkits for Real Time Digital Audio Signal Processing Teaching Laboratory.* University of Rwanda. Journal of Signal and Information Processing. DOI 10.4236/jsip.2015.62009\r\n* Czarnowska, Lucyna; Litwin, Wojciech; Stanek, Wojciech (2015). *Selection of Numerical Methods and their Application to the Thermo-Ecological Life Cycle Cost of Heat Exchanger Components*. Silesian University of Technology.\r\n* Schmollinger, Stefan; M\u00FClhaus, Timo; et al (2014). *Nitrogen-Sparing Mechanisms in Chlamydomonas Affect the Transcriptome, the Proteome, and Photosynthetic Metabolism.* The Plant Cell. DOI 10.1105/tpc.113.122523\r\n* Mettler, Tabea; M\u00FClhaus, Timo; et al (2014). *Systems Analysis of the Response of Photosynthesis, Metabolism, and Growth to an Increase in Irradiance in the Photosynthetic Model Organism Chlamydomonas reinhardtii.* The Plant Cell. DOI 10.1105/tpc.114.124537.\r\n* Blah\u00FAt, Jozef (2014). *Design and Implementation of Application for Measured Data Processing*. Brno University of Technology.\r\n* Mueller, Caitlin; Ochsendorf John (2013). *From Analysis to Design: A New Computational Strategy for Structural Creativity.* Massachusetts Institute of Technology. 2nd International Workshop on Design in Civil and Environmental Engineering.\r\n* Puwalowski, Mateusz (2013). *Ukryte Indeksowanie Semantyczne.* Uniwersytet Gdanski.\r\n* Botter, R (2013). *Effici\u00EBnt begroten met historische projectgegevens.* Technische Universiteit Eindhoven.\r\n* Parma, Alessio (2013). *Una libreria per la simulazione a eventi discreti in .NET.* Universit\u00E0 Degli Studi Di Genova.\r\n* Singh, Rohit; Gulwani, Sumit; Rajamani Sriram (2012). *Automatically Generating Algebra Problems.* Microsoft Research. Association for the Advancement of Artificial Intelligence.\r\n* Grahl Pereira, Andr\u00E9; Petry, Adriano (2012). *Data Assimilation using NeuroEvolution of Augmenting Topologies.* IJCNN. WCCI 2012 IEEE World Congress on Computational Intelligence.\r\n* Lauppe, Joost (2012). *Reinforcement Toolbox: A Parametric Reinforcement Modeling Tool for Curved Surface Structures.* Delft University of Technology.\r\n* Lundstr\u00F6m, Lukas (2012). *Weather data for building simulation: New actual weather files for North Europe combining observed weather and modeled solar radiation.* School of Sustainable Development of Society and Technology, HST.\r\n* AT Council (2012). *Seismic Performance Assessment of Buildings Volume 2 - Implementation Guide.* FEMA, U.S. Department of Homeland Security.\r\n* Ma, Jiangshan (2012). *Hyperpath-based Strategic Route Guidance Considering Travel Time Uncertainty.* Transportation Studies Unit, Tokyo Institute of Transportation.\r\n* Fisher, Michael (2012). *Research and Development of a VST Plugin for the Autonomous Post Production of a Stereo Piano Recording.* University of Huddersfield.\r\n* Williams, Liam (2012). *Spotting The Wisdom In The Crowds.* Imperial College London.\r\n* Schr\u00E4der, Niklas (2011). *Detecting falls and poses in image silhouettes (M.Sc).* Chalmers University of Technology, Gothenburg, Sweden. ISSN 1652-8557.\r\n* Nelson, Peter (2011). *3D Mapping for Robotic Search and Rescue.* New College.\r\n* Adelson, Michael (2011). *Emotiv Experimenter: An experimentation and mind-reading application for the Emotiv EPOC.* Princeton University.\r\n* Schindlberger, Michael (2011). *Elastic Properties of Growing 2D Foam (M.Sc).* University of Zurich.\r\n* Krejcar, Ondrej; Jirka, Jakub; Janckulik, Dalibor (2011). *Use of Mobile Phones as Intelligent Sensors for Sound Input Analysis and Sleep State Detection.* Sensors (11): 6037\u20136055. ISSN 1424-8220.\r\n* Keglevic, Manuel; Schulz, Thomas (2011). *NoNoise - Music Library Visualization.* Vienna University of Technology.\r\n* Kraus, Jan; Bubla, Viktor; Kukacka, Leos (2011). *Data Modeling for Reduction of Volume in Large Archives of Power Quality Data.* 21st International Conference on Electricity Distribution. TUL CZ.\r\n* Ferreira, Andr\u00E9 Filipe Mateus. *SoundLog: Make More Noise (M.Sc).* Universidade T\u00E9cnica de Lisboa.\r\n* Nunes, Jos\u00E9; S\u00E1, Luis; Perdig\u00E3o, Fernando (2011). *Talking Avatar for Web-based Interfaces.* Instituto de Telecomunica\u00E7\u00F5es, Coimbra, Portugal.\r\n* Dostra\u0161il, Pavel; Jir\u00E1sko, Petr (2011). *Productive Design and Calculation of Intermittent Mechanisms with Radial Parallel Cams.* International Journal of Mechanical, Aerospace, Industrial, Mechatronic and Manufacturing Engineering Vol:5, No:11, 2011.\r\n* Miller, Justin (2010). *Design of a Wireless Acquisition System for a Digital Stethoscope (B.Sc).* University of Southern Queensland.\r\n* Skrehota, Ondrej (2010). *Quantitative structure-property relationship modeling algorithms, challenges and IT solutions.* Masaryk University.\r\n* L\u00CD\u0160KA, Ondrej; \u017DIDEK, Kamil (2010). *Accelerometers usability for danger tilt off-highway vehicles and signal filtration with kalman filter.* Journal of applied science in the thermodynamics and fluid mechanics 4 (2): 1\u20136. ISSN 1802-9388.\r\n* Team Limawai (2010). *Ka\u0060imiolakai ROV.* 2010 MATE International UROV Competition. Kapi\u0060olani Community College.\r\n* Hebel, Tobias (2010). *Location Provider.* Universit\u00E4t Koblenz Landau.\r\n* Bischoff, Sebastian (2009). *Konzeption und Umsetzung einer RIA zur untersuchungsbegleitenden Erfassung von RNFLT-Scans und Untersuchung von Klassifikatoren f\u00FCr die diagnostische Unterst\u00FCtzung bei neurodegenerativen Erkrankungen am Beispiel der Multiplen Sklerose.* Fachhochschule Brandenburg.\r\n"}]